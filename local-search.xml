<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>八皇后问题</title>
    <link href="/2020/08/09/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/09/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<div class="hljs"><pre><code class="hljs perl"><span class="hljs-comment">## Hello Halo</span>如果你看到了这一篇文章，那么证明你已经安装成功了，感谢使用 [Halo](https:<span class="hljs-regexp">//halo</span>.run) 进行创作，希望能够使用愉快。<span class="hljs-comment">## 相关链接</span>  - 官网：[https:<span class="hljs-regexp">//halo</span>.run](https:<span class="hljs-regexp">//halo</span>.run)\n<span class="hljs-string">" +</span><span class="hljs-string">        "</span>- 社区：[https:<span class="hljs-regexp">//bbs</span>.halo.run](https:<span class="hljs-regexp">//bbs</span>.halo.run)\n<span class="hljs-string">" +</span><span class="hljs-string">        "</span>- 主题仓库：[https:<span class="hljs-regexp">//halo</span>.run/<span class="hljs-regexp">s/themes](https://halo</span>.run/<span class="hljs-keyword">s</span>/themes)\n<span class="hljs-string">" +</span><span class="hljs-string">        "</span>- 开源地址：[https:<span class="hljs-regexp">//github</span>.com/halo-dev/halo](https:<span class="hljs-regexp">//github</span>.com/halo-dev/halo)\n<span class="hljs-string">" +</span><span class="hljs-string">        "</span>\n<span class="hljs-string">" +</span><span class="hljs-string">        "</span>在使用过程中，有任何问题都可以通过以上链接找寻答案，或者联系我们。\n<span class="hljs-string">" +</span><span class="hljs-string">        "</span>\n<span class="hljs-string">" +</span><span class="hljs-string">        "</span>&gt; 这是一篇自动生成的文章，请删除这篇文章之后开始你的创作吧！\n<span class="hljs-string">" +</span><span class="hljs-string">        "</span>\n</code></pre></div><h2 id="关于页面"><a href="#关于页面" class="headerlink" title="关于页面"></a>关于页面</h2><p>这是一个自定义页面，你可以在后台的 <code>页面</code> -&gt; <code>所有页面</code> -&gt; <code>自定义页面</code> 找到它，你可以用于新建关于页面、留言板页面等等。发挥你自己的想象力！</p><blockquote><p>这是一篇自动生成的页面，你可以在后台删除它。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之抽象工厂模式</title>
    <link href="/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p><p><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</p><p><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory*。接着定义工厂类 *ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。然后创建一个工厂创造器/生成器类 <em>FactoryProducer</em>。</p><p>演示类使用 <em>FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape<em>Type（</em>CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory</em> 传递颜色信息 <em>Color</em>Type（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt=""></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建两个接口:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绘图方法，由实现类来实现此方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Color</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 填充颜色方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制矩形......"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制圆形......"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制正方形......"</span>);        &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Color</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"填充蓝色........."</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Green</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Color</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"填充绿色........."</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Color</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"填充红色........."</span>);    &#125;&#125;</code></pre></div><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建三个枚举类，可供选择Shape类型和Color类型及Factory类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ShapeType &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 矩形</span><span class="hljs-comment">     */</span>    RECTANGLE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 圆形</span><span class="hljs-comment">     */</span>    CIRCLE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 正方形</span><span class="hljs-comment">     */</span>    SQUARE;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ColorType &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 红色</span><span class="hljs-comment">     */</span>    RED,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绿色</span><span class="hljs-comment">     */</span>    GREEN,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 蓝色</span><span class="hljs-comment">     */</span>    BLUE;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FactoryType &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 图形工厂</span><span class="hljs-comment">     */</span>    SHAPE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 颜色工厂</span><span class="hljs-comment">     */</span>    COLOR;&#125;</code></pre></div><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>为 Color 和 Shape 对象创建抽象类来获取工厂。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过指定类型获取图形</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shapeType 图形类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Shape 图形</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Shape <span class="hljs-title">getShape</span><span class="hljs-params">(ShapeType shapeType)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过指定类型获取颜色</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colorType 颜色类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Color 颜色</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Color <span class="hljs-title">getColor</span><span class="hljs-params">(ColorType colorType)</span></span>;&#125;</code></pre></div><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShapeFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">getShape</span><span class="hljs-params">(ShapeType shapeType)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (shapeType) &#123;            <span class="hljs-keyword">case</span> CIRCLE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circle();            <span class="hljs-keyword">case</span> SQUARE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Square();            <span class="hljs-keyword">case</span> RECTANGLE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">getColor</span><span class="hljs-params">(ColorType colorType)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">getShape</span><span class="hljs-params">(ShapeType shapeType)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">getColor</span><span class="hljs-params">(ColorType colorType)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (colorType) &#123;            <span class="hljs-keyword">case</span> RED:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Red();            <span class="hljs-keyword">case</span> GREEN:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Green();            <span class="hljs-keyword">case</span> BLUE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Blue();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h3><p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryProducer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据指定工厂类型获取工厂</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> factoryType 工厂类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Factory</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractFactory <span class="hljs-title">getFactory</span><span class="hljs-params">(FactoryType factoryType)</span></span>&#123;        <span class="hljs-keyword">switch</span> (factoryType) &#123;            <span class="hljs-keyword">case</span> COLOR:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorFactory();            <span class="hljs-keyword">case</span> SHAPE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ShapeFactory();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h3><p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactoryTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 获取图形工厂</span>        AbstractFactory shapeFactory = FactoryProducer.getFactory(FactoryType.SHAPE);        <span class="hljs-keyword">assert</span> shapeFactory != <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 获取形状为 Rectangle 的对象</span>        Shape shape_r = shapeFactory.getShape(ShapeType.RECTANGLE);        shape_r.draw();        <span class="hljs-comment">// 获取形状为 Circle 的对象</span>        Shape shape_c = shapeFactory.getShape(ShapeType.CIRCLE);        shape_c.draw();        <span class="hljs-comment">// 获取形状为 Square 的对象</span>        Shape shape_s = shapeFactory.getShape(ShapeType.SQUARE);        shape_s.draw();        <span class="hljs-comment">// 获取颜色工厂</span>        AbstractFactory colorFactory = FactoryProducer.getFactory(FactoryType.COLOR);        <span class="hljs-keyword">assert</span> colorFactory != <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 获取颜色为 Red 的对象</span>        Color color_r = colorFactory.getColor(ColorType.RED);        color_r.fill();        <span class="hljs-comment">// 获取颜色为 Green 的对象</span>        Color color_g = colorFactory.getColor(ColorType.GREEN);        color_g.fill();        <span class="hljs-comment">// 获取颜色为 Blue 的对象</span>        Color color_b = colorFactory.getColor(ColorType.BLUE);        color_b.fill();    &#125;&#125;</code></pre></div><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤 9"></a>步骤 9</h3><p>执行程序，输出结果：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200805114114.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p><p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p><strong>关键代码：</strong>创建过程在其子类执行。</p><p><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory</em>。</p><p>演示类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递所需对象的类型。从而获取所需对象</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt=""></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个接口:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绘图方法，由实现类来实现此方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制矩形......"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制圆形......"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制正方形......"</span>);        &#125;&#125;</code></pre></div><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建一个枚举类，可供选择Shape类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ShapeType &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 矩形</span><span class="hljs-comment">     */</span>    RECTANGLE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 圆形</span><span class="hljs-comment">     */</span>    CIRCLE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 正方形</span><span class="hljs-comment">     */</span>    SQUARE;&#125;</code></pre></div><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>创建一个工厂，生成基于给定信息的实体类的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShapeFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ShapeFactory</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title">createShape</span><span class="hljs-params">(ShapeType shapeType)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (shapeType) &#123;            <span class="hljs-keyword">case</span> CIRCLE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circle();            <span class="hljs-keyword">case</span> SQUARE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Square();            <span class="hljs-keyword">case</span> RECTANGLE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h3><p>使用该工厂，通过传递类型信息来获取实体类的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        Objects.requireNonNull(ShapeFactory.createShape(ShapeType.CIRCLE)).draw();        Objects.requireNonNull(ShapeFactory.createShape(ShapeType.RECTANGLE)).draw();        Objects.requireNonNull(ShapeFactory.createShape(ShapeType.SQUARE)).draw();    &#125;&#125;</code></pre></div><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>执行程序，输出结果：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200805101451.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="/2020/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong>构造函数是私有的。</p><p><strong>应用实例：</strong></p><ul><li>1、一个班级只有一个班主任。</li><li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ul><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong></p><ul><li>1、要求生产唯一序列号。</li><li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li></ul><p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>SingletonHungryMan</em> 类。 <em>SingletonHungryMan</em> 类有它的私有构造函数和本身的一个静态实例。</p><p> <em>SingletonHungryMan</em> 类提供了一个静态方法，供外界获取它的静态实例。演示类使用  <em>SingletonHungryMan</em> 类来获取  <em>SingletonHungryMan</em>对象。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-20200804191751504.png" srcset="/img/loading.gif" alt=""></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个 <em>SingleObject</em> 类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleObject</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建 SingleObject 的一个对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingleObject instance = <span class="hljs-keyword">new</span> SingleObject();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 让构造函数为 private，这样该类就不会被实例化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleObject</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取唯一可用的对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> instance</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Hello World!"</span>);    &#125;&#125;</code></pre></div><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>从  <em>SingleObject</em> 类获取唯一的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleObjectTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 不合法的构造函数，编译时错误：构造函数 SingleObject() 是不可见的</span>        <span class="hljs-comment">// SingleObject object = new SingleObject();</span>        <span class="hljs-comment">//获取唯一可用的对象</span>        SingleObject object = SingleObject.getInstance();        <span class="hljs-comment">//显示消息</span>        object.showMessage();    &#125;&#125;</code></pre></div><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>执行程序，输出结果：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-20200804211223102.png" srcset="/img/loading.gif" alt=""></p><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><p>单例模式的实现有多种方式，如下所示：</p><h3 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>否</p><p><strong>实现难度：</strong>易</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的懒汉式（线程不安全）</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 起到了 Lazy Loading 的效果，但是只能在单线程下使用。</span><span class="hljs-comment"> *          2) 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</span><span class="hljs-comment"> *             所以在多线程环境下不可使用这种方式</span><span class="hljs-comment"> *          3) 结论：在实际开发中，不要使用这种方式.</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonThreadUnSafeLazyMan</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造函数私有化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonThreadUnSafeLazyMan</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 本类内部创建实例</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonThreadUnSafeLazyMan INSTANCE;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 懒汉式（线程不安全）</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonThreadUnSafeLazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == INSTANCE) &#123;            INSTANCE = <span class="hljs-keyword">new</span> SingletonThreadUnSafeLazyMan();        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><p><strong>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</strong></p><h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的懒汉式（线程安全）</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 解决了线程安全问题</span><span class="hljs-comment"> *          2) 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，</span><span class="hljs-comment"> *             后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低</span><span class="hljs-comment"> *          3) 结论：在实际开发中，不推荐使用这种方式</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonThreadSafeLazyMan</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造函数私有化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonThreadSafeLazyMan</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 本类内部创建实例</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonThreadSafeLazyMan INSTANCE;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 懒汉式（线程安全）</span><span class="hljs-comment">     * 提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonThreadSafeLazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == INSTANCE) &#123;            INSTANCE = <span class="hljs-keyword">new</span> SingletonThreadSafeLazyMan();<span class="hljs-comment">//            /**</span><span class="hljs-comment">//             * 同步代码块</span><span class="hljs-comment">//             */</span><span class="hljs-comment">//            synchronized (LazyManThreadSafeSingleton.class) &#123;</span><span class="hljs-comment">//                INSTANCE = new LazyManThreadSafeSingleton()；</span><span class="hljs-comment">//            &#125;</span>        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的饿汉式：</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</span><span class="hljs-comment"> *          2) 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</span><span class="hljs-comment"> *          3) 这种方式基于 ClassLoader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，</span><span class="hljs-comment"> *             但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果</span><span class="hljs-comment"> *          4) 结论：这种单例模式可用，可能造成内存浪费</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHungryMan</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 让构造函数为 private，这样该类在外部就无法就不会被实例化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonHungryMan</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 1、本类内部直接创建 SingletonHungryMan 的一个对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonHungryMan INSTANCE = <span class="hljs-keyword">new</span> SingletonHungryMan();<span class="hljs-comment">//    /**</span><span class="hljs-comment">//     * 2、在静态代码块中，创建单例对象</span><span class="hljs-comment">//     */</span><span class="hljs-comment">//    static &#123;</span><span class="hljs-comment">//        INSTANCE = new SingletonHungryMan();</span><span class="hljs-comment">//    &#125;</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取唯一可用的对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonHungryMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的双重检查式（线程安全）</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (null == INSTANCE) 检查，这样就可以保证线程安全了。</span><span class="hljs-comment"> *          2) 这样，实例化代码只用执行一次，后面再次访问时，判断 if (null == INSTANCE)，直接 return 实例化对象，也避免的反复进行方法同步。</span><span class="hljs-comment"> *          3) 线程安全；延迟加载；效率较高</span><span class="hljs-comment"> *          4) 结论：在实际开发中，推荐使用这种单例设计模式</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDoubleCheck</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDoubleCheck</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 内部实例化对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDoubleCheck INSTANCE;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span><span class="hljs-comment">     * 同时保证了效率, 推荐使用</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDoubleCheck <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == INSTANCE) &#123;            <span class="hljs-keyword">synchronized</span> (SingletonDoubleCheck<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == INSTANCE) &#123;                    INSTANCE = <span class="hljs-keyword">new</span> SingletonDoubleCheck();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><h3 id="5、登记式-静态内部类"><a href="#5、登记式-静态内部类" class="headerlink" title="5、登记式/静态内部类"></a>5、登记式/静态内部类</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>一般</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的静态内部类式</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</span><span class="hljs-comment"> *          2) 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，</span><span class="hljs-comment"> *             从而完成 Singleton 的实例化。</span><span class="hljs-comment"> *          3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</span><span class="hljs-comment"> *          4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</span><span class="hljs-comment"> *          5) 结论：推荐使用.</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonStaticInnerClass</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonStaticInnerClass</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 写一个静态内部类,该类中有一个静态属性 SingletonStaticInnerClass</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonStaticInnerClass INSTANCE = <span class="hljs-keyword">new</span> SingletonStaticInnerClass();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提供一个静态的公有方法，直接返回 Singleton.INSTANCE</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Singleton.INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonStaticInnerClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Singleton.INSTANCE;    &#125;&#125;</code></pre></div><h3 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h3><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的枚举式</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</span><span class="hljs-comment"> *          2) 这种方式是 Effective Java 作者 Josh Bloch  提倡的方式</span><span class="hljs-comment"> *          3) 结论：推荐使用</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  SingletonEnum &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 使用枚举，可以实现单例, 推荐</span><span class="hljs-comment">     */</span>    INSTANCE;&#125;</code></pre></div><p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java - 静态代理和动态代理</title>
    <link href="/2020/07/13/Java%20-%20%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2020/07/13/Java%20-%20%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>由于后面要写的文章需要用到代理的知识，所以先写这篇文章为后面的知识做铺垫。</p><blockquote><p>代理就是定义一个行为和某类的对象相似，而又潜在地表示了所有继承自该类的对象的东西。</p></blockquote><p><img src="https://i.loli.net/2020/07/13/GdQDHc7TpaF2Bqv.png" srcset="/img/loading.gif" alt="image.png"></p><p>在说动态代理之前，必须先聊聊什么是静态代理。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设现在有这么一个需求：在某个类的方法前后打印日志。</p><p>那么要如何做到在<strong>不修改源代码前提下</strong>，来实现这个功能呢？</p><p>首先想到的就是静态代理，具体做法是：</p><ol><li><p>为这个类编写一个对应的代理类，并让它实现与目标类相同的接口。<br><img src="https://i.loli.net/2020/07/13/a9Ynr3pGFRkeHd1.png" srcset="/img/loading.gif" alt="image.png"></p></li><li><p>在创建代理对象是，通过构造函数传入一个实现了该接口的目标对象，然后在代理对象内部调用目标对象的同名方法，并在调用之前后打印日志。也就是说，<strong>代理对象 = 目标对象 + 增强代码</strong>。而有了代理对象后，就不需要原对象了。<br><img src="https://i.loli.net/2020/07/13/eT2AvUkB3EuMR15.png" srcset="/img/loading.gif" alt="image.png"></p></li></ol><h3 id="编写代码进行测试"><a href="#编写代码进行测试" class="headerlink" title="编写代码进行测试"></a>编写代码进行测试</h3><ol><li>首先先新建一个接口<strong>A</strong><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div></li></ol><p>2.创建一个对应的实现类 <strong>AImpl</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;    &#125;&#125;</code></pre></div><ol start="3"><li>接下来建立一个目标对象的代理类 <strong>AProxy</strong><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AProxy</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> A target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AProxy</span><span class="hljs-params">(A target)</span> </span>&#123;        <span class="hljs-keyword">this</span>.target = target;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"方法执行之前..."</span>);        System.out.println(target.add());        System.out.println(<span class="hljs-string">"方法执行之后..."</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div></li><li>运行 代理类中的 <strong>add</strong> 方法进行测试<br><img src="https://i.loli.net/2020/07/13/IWo8VOueqfNcSnm.png" srcset="/img/loading.gif" alt="image.png"></li></ol><p>结果在我们意料之中，这样就实现了一个简单的静态代理。</p><h3 id="静态代理的缺陷"><a href="#静态代理的缺陷" class="headerlink" title="静态代理的缺陷"></a>静态代理的缺陷</h3><p>当在类少的时候还好，但是当你的项目中有成千上万个类时，你需要为每个类都写一个对应的代理类，这工作量太大了。</p><p>我们能不能少写或者不写代理类，却能完成代理功能呢？接下来我们来介绍动态代理。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java的动态代理可以动态的创建代理并动态的处理对所代理方法的调用。动态代理有两种实现方法，一种是使用JDK自带的，一种是使用Cglib实现。在这里就先聊聊JDK的动态代理是怎么实现的。</p><p>JDK中提供了 <strong>invocationHandler</strong> 接口和 <strong>Proxy</strong> 类，借助这两个工具可以达到我们想要的效果。</p><h3 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h3><p><strong>InvocationHandler</strong> 接口是 <strong>proxy</strong> 代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。</p><h3 id="Proxy-类"><a href="#Proxy-类" class="headerlink" title="Proxy 类"></a>Proxy 类</h3><p><strong>Proxy</strong> 类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是<strong>newProxyInstance</strong> 方法。</p><p>下面我们先来看看代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ClassLoader classLoader = ProxyTest<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>;        Class&lt;?&gt;[] interfaces = &#123;A<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;</span>;        A aImpl = <span class="hljs-keyword">new</span> AImpl();        A aProxy = (A) Proxy.newProxyInstance(classLoader, interfaces, <span class="hljs-keyword">new</span> InvocationHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                Object result = <span class="hljs-keyword">null</span>;                System.out.println(<span class="hljs-string">"方法执行之前"</span>);                result = method.invoke(aImpl, args);                System.out.println(result);                System.out.println(<span class="hljs-string">"方法执行之后"</span>);                <span class="hljs-keyword">return</span> result;            &#125;        &#125;);        aProxy.add();    &#125;&#125;</code></pre></div><p>上面这段代码是什么意思呢？</p><ol><li><p>首先我们可以调用 <strong>Proxy</strong> 类的 <strong>newProxyInstance</strong> 方法获取代理对象。查看源码可以看到该方法需要接收三个参数<br><img src="https://i.loli.net/2020/07/13/owTRJa1cFGzv48i.png" srcset="/img/loading.gif" alt="image.png"></p><ul><li>ClassLoader loader，类加载器， 随便找个类的加载器就可以</li><li>Class&lt;?&gt;[] interfaces，目标对象实现的接口</li><li>InvocationHandler h，传入一个实现了该接口的实现类</li></ul></li><li><p>获取 <strong>Proxy.newProxyInstance(…)</strong> 创建的代理对象，调用其方法</p></li></ol><p>来看结果：</p><p><img src="https://i.loli.net/2020/07/13/jUCO2fWtHz69J4Z.png" srcset="/img/loading.gif" alt="image.png"></p><p>完美！</p><p>我们来分析一下整个流程：</p><ol><li>通过 <strong>Proxy.newProxyInstance(…)</strong> 获得代理对象</li><li>代理对象调用 <strong>add</strong> 方法</li><li>JVM通过将方法导向致 <strong>invoke</strong> 方法</li><li>执行<strong>invoke</strong>方法，若有返回值则返回</li></ol><p><img src="https://i.loli.net/2020/07/13/XzclsrGQuFyEwZA.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>静态代理实现较简单，代理类在编译期生成，效率高。缺点是会生成大量的代理类。</li><li>JDK动态代理不要求代理类和委托类实现同一个接口，但是委托类需要实现接口，代理类需要实现InvocationHandler接口。</li><li>动态代理要求代理类InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理</tag>
      
      <tag>Proxy</tag>
      
      <tag>静态代理</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring - 组件注册（二）</title>
    <link href="/2020/07/03/Spring%20-%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/07/03/Spring%20-%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="Conditional-按照条件注册"><a href="#Conditional-按照条件注册" class="headerlink" title="@Conditional - 按照条件注册"></a>@Conditional - 按照条件注册</h3><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Conditional &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * All &#123;<span class="hljs-doctag">@link</span> Condition Conditions&#125; that must &#123;<span class="hljs-doctag">@linkplain</span> Condition#matches match&#125;</span><span class="hljs-comment"> * in order for the component to be registered.</span><span class="hljs-comment"> */</span>Class&lt;? extends Condition&gt;[] value();&#125;</code></pre></div><p>我们需要传入一个 <strong>Class&lt;? extends Condition&gt;</strong> 数组，且每个自定义的 <strong>condition</strong> 都需要实现 <strong>Condition</strong> 接口。<br>我们在这里先创建两个Condition，分别判断是Windows系统还是Linux系统</p><h4 id="WindowsCondition"><a href="#WindowsCondition" class="headerlink" title="WindowsCondition"></a><strong>WindowsCondition</strong></h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;<span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Condition;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ConditionContext;<span class="hljs-keyword">import</span> org.springframework.core.env.Environment;<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/2 17:21</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> * 判断是否是Windows系统</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowsCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 判断条件能使用的上下文（环境</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metadata 注释信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true or false</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;        <span class="hljs-comment">// 获取到IOC使用的beanfactory</span>        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();        <span class="hljs-comment">// 获取类加载器</span>        ClassLoader classLoader = context.getClassLoader();        <span class="hljs-comment">// 获取当前环境信息</span>        Environment environment = context.getEnvironment();        <span class="hljs-comment">// 获取到bean定义的注册类</span>        BeanDefinitionRegistry registry = context.getRegistry();        String property = environment.getProperty(<span class="hljs-string">"os.name"</span>);        <span class="hljs-keyword">assert</span> property != <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> property.contains(<span class="hljs-string">"Windows"</span>);    &#125;&#125;</code></pre></div><h4 id="LinuxCondition"><a href="#LinuxCondition" class="headerlink" title="LinuxCondition"></a>LinuxCondition</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Condition;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ConditionContext;<span class="hljs-keyword">import</span> org.springframework.core.env.Environment;<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/2 17:20</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> * 判断是否是Linux系统</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinuxCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;        Environment environment = context.getEnvironment();        <span class="hljs-comment">// 获取到bean定义的注册类</span>        BeanDefinitionRegistry registry = context.getRegistry();        String property = environment.getProperty(<span class="hljs-string">"os.name"</span>);        <span class="hljs-keyword">assert</span> property != <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> property.contains(<span class="hljs-string">"Linux"</span>);    &#125;&#125;</code></pre></div><h4 id="在注册的bean上面加入-Condition注解"><a href="#在注册的bean上面加入-Condition注解" class="headerlink" title="在注册的bean上面加入@Condition注解"></a>在注册的bean上面加入@Condition注解</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.lwjppz.config;<span class="hljs-keyword">import</span> cn.lwjppz.condition.LinuxCondition;<span class="hljs-keyword">import</span> cn.lwjppz.condition.WindowsCondition;<span class="hljs-keyword">import</span> cn.lwjppz.entites.User;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Conditional;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/2 17:31</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig3</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Conditional</span>(&#123;Condition&#125;) 按照一定的条件进行判断，满足条件给容器中注册bean</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 如果是 Windows 系统 则给容器注册 bill</span><span class="hljs-comment">     * 如果是 Linux 系统，则注册 jack</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bill"</span>)    <span class="hljs-meta">@Conditional</span>(WindowsCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">user01</span> () </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>, <span class="hljs-string">"Bill"</span>, <span class="hljs-number">62</span>);    &#125;    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"jack"</span>)    <span class="hljs-meta">@Conditional</span>(LinuxCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">user02</span> () </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>, <span class="hljs-string">"jack"</span>, <span class="hljs-number">22</span>);    &#125;&#125;</code></pre></div><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://i.loli.net/2020/07/02/K4wAfZRiLVjbXv3.png" srcset="/img/loading.gif" alt="image.png"></p><p>由于系统是Windows的，所以只给容器中加入了bill。</p><h3 id="Import-给容器中导入组件"><a href="#Import-给容器中导入组件" class="headerlink" title="@Import - 给容器中导入组件"></a>@Import - 给容器中导入组件</h3><h4 id="新建一个Color类"><a href="#新建一个Color类" class="headerlink" title="新建一个Color类"></a>新建一个Color类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> </span>&#123;&#125;</code></pre></div><h4 id="加入-Import注解"><a href="#加入-Import注解" class="headerlink" title="加入@Import注解"></a>加入@Import注解</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.condition.LinuxCondition;<span class="hljs-keyword">import</span> cn.lwjppz.condition.WindowsCondition;<span class="hljs-keyword">import</span> cn.lwjppz.entites.Color;<span class="hljs-keyword">import</span> cn.lwjppz.entites.User;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Conditional;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Import;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/2 17:31</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-comment">// @Import 导入组件，id默认为组件的全类名</span><span class="hljs-meta">@Import</span>(Color<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">MainConfig3</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Conditional</span>(&#123;Condition&#125;) 按照一定的条件进行判断，满足条件给容器中注册bean</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 如果是 Windows 系统 则给容器注册 bill</span><span class="hljs-comment">     * 如果是 Linux 系统，则注册 jack</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bill"</span>)    <span class="hljs-meta">@Conditional</span>(WindowsCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">user01</span> () </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>, <span class="hljs-string">"Bill"</span>, <span class="hljs-number">62</span>);    &#125;    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"jack"</span>)    <span class="hljs-meta">@Conditional</span>(LinuxCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">user02</span> () </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>, <span class="hljs-string">"jack"</span>, <span class="hljs-number">22</span>);    &#125;&#125;</code></pre></div><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="https://ae01.alicdn.com/kf/H8ddb4400887d493fabfab45e8ee5a0962.jpg" srcset="/img/loading.gif" alt=""></p><p>可见Color已被加入容器中</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring - 组件注册（一）</title>
    <link href="/2020/07/01/Spring%20-%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/07/01/Spring%20-%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="Configuration-和-Bean"><a href="#Configuration-和-Bean" class="headerlink" title="@Configuration 和 @Bean"></a><strong>@Configuration</strong> 和 <strong>@Bean</strong></h3><ul><li>在 <strong>Spring</strong> 中配置类就相当于配置文件</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.entites.User;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/1 9:40</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 配置类 == 配置文件</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">// 告诉 Spring 这是一个配置类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 给容器注册一个 Bean ，类型为返回值类型，id默认使用方法名作为id</span><span class="hljs-comment">     * 也可给<span class="hljs-doctag">@Bean</span>中传入value参数自定义id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user实例</span><span class="hljs-comment">     */</span><span class="hljs-comment">//    @Bean("user01")</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">"lwjppz"</span>, <span class="hljs-number">20</span>);    &#125;&#125;</code></pre></div><ul><li><p>测试类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.config.MainConfig;<span class="hljs-keyword">import</span> cn.lwjppz.entites.User;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 10:08</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        User user = context.getBean(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        System.out.println(user);        String[] names = context.getBeanNamesForType(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">for</span> (String name : names) &#123;            System.out.println(name);        &#125;    &#125;&#125;</code></pre></div></li><li><p>测试结果<br><img src="https://i.loli.net/2020/07/01/hix75SsOybTElNJ.png" srcset="/img/loading.gif" alt="image.png"></p></li></ul><h3 id="ComponentScan-自动扫描组件-amp-指定扫描规则"><a href="#ComponentScan-自动扫描组件-amp-指定扫描规则" class="headerlink" title="@ComponentScan - 自动扫描组件&amp;指定扫描规则"></a>@ComponentScan - 自动扫描组件&amp;指定扫描规则</h3><ul><li><p>新建UserController、UserDao、UserService，分别加上@Controller，@Repository，@Service注解<br><img src="https://i.loli.net/2020/07/01/SaBREzuIJVcvFpP.png" srcset="/img/loading.gif" alt="image.png"></p></li><li><p>测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    String[] names = context.getBeanDefinitionNames();    <span class="hljs-keyword">for</span> (String name : names) &#123;        System.out.println(name);    &#125;&#125;</code></pre></div></li></ul><p><img src="https://i.loli.net/2020/07/01/HfCQVFSDP7lgmbB.png" srcset="/img/loading.gif" alt="image.png"></p><h4 id="指定包扫描规则"><a href="#指定包扫描规则" class="headerlink" title="指定包扫描规则"></a>指定包扫描规则</h4><h5 id="1-指定排除规则"><a href="#1-指定排除规则" class="headerlink" title="1. 指定排除规则"></a>1. 指定排除规则</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// excludeFilters Filter[] 扫描的时候按照指定的规则排除指定的组件</span><span class="hljs-comment">// 排除加了 @Controller 和 @Service 注解的组件</span><span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.lwjppz"</span>, excludeFilters = &#123;<span class="hljs-meta">@Filter</span>(type = FilterType.ANNOTATION, classes = &#123;Controller<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Service</span>.<span class="hljs-title">class</span>&#125;)&#125;)</span></code></pre></div><p>效果：</p><p><img src="https://i.loli.net/2020/07/01/2koKjwPXUAhe4qN.png" srcset="/img/loading.gif" alt="image.png"></p><p>很明显和之前相比少了 <strong>userController</strong> 和 <strong>userService</strong>。</p><h5 id="2-指定包含规则"><a href="#2-指定包含规则" class="headerlink" title="2. 指定包含规则"></a>2. 指定包含规则</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// includeFilters Filter[] 扫描的时候只需要包含哪些组件</span><span class="hljs-comment">// 只扫描加了 @Controller 组件的组件</span><span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.lwjppz"</span>, includeFilters = &#123;<span class="hljs-meta">@Filter</span>(type = FilterType.ANNOTATION, classes = Controller<span class="hljs-class">.<span class="hljs-keyword">class</span>)&#125;, <span class="hljs-title">useDefaultFilters</span> </span>= <span class="hljs-keyword">false</span>)</code></pre></div><p>注意：使用 <strong>includeFilters</strong> 时要排除 <strong>Spring</strong> 默认的 Filters，需在 <strong>@ComponentScan</strong> 中加入 <strong>useDefaultFilters = false</strong></p><p>效果：</p><p><img src="https://i.loli.net/2020/07/01/atcug3hLy4AYBZp.png" srcset="/img/loading.gif" alt="image.png"></p><p>现在就只有加了 <strong>@Controller</strong> 的组件被包含进来了</p><h5 id="3-也可使用-ComponentScans-来指定多个扫描规则"><a href="#3-也可使用-ComponentScans-来指定多个扫描规则" class="headerlink" title="3. 也可使用 @ComponentScans 来指定多个扫描规则"></a>3. 也可使用 <strong>@ComponentScans</strong> 来指定多个扫描规则</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScans</span>(&#123;        <span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.lwjppz"</span>, includeFilters = &#123;<span class="hljs-meta">@Filter</span>(type = FilterType.ANNOTATION, classes = Controller<span class="hljs-class">.<span class="hljs-keyword">class</span>)&#125;, <span class="hljs-title">useDefaultFilters</span> </span>= <span class="hljs-keyword">false</span>)&#125;)</code></pre></div><p>效果是和之前的一样的。</p><h5 id="4-自定义规则"><a href="#4-自定义规则" class="headerlink" title="4. 自定义规则"></a>4. 自定义规则</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  FilterType.ANNOTATION           按照注解</span><span class="hljs-comment"> *  FilterType.ASSIGNABLE_TYPE      按照给定的类型</span><span class="hljs-comment"> *  FilterType.ASPECTJ              使用 ASPECTJ 表达式</span><span class="hljs-comment"> *  FilterType.REGEX                使用正则表达式</span><span class="hljs-comment"> *  FilterType.CUSTOM               使用自定义规则</span><span class="hljs-comment"> */</span></code></pre></div><p><img src="https://i.loli.net/2020/07/01/8XJRmwf2v7KWIgC.png" srcset="/img/loading.gif" alt="image.png"></p><p>注意：自定义 <strong>Filter</strong> 需实现 <strong>TypeFilter</strong> 接口</p><h3 id="Scope-设置组件作用域"><a href="#Scope-设置组件作用域" class="headerlink" title="@Scope - 设置组件作用域"></a>@Scope - 设置组件作用域</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/1 11:33</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig2</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认是单实例的</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> ConfigurableBeanFactory#SCOPE_PROTOTYPE  singleton</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> ConfigurableBeanFactory#SCOPE_SINGLETON  prototype</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST request</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_SESSION session</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     *</span><span class="hljs-comment">     * singleton    单实例（默认值）    IOC容器启动后会去调用方法创建对象，放入容器中</span><span class="hljs-comment">     *              以后每次获取都是从容器中拿（map.get())</span><span class="hljs-comment">     * prototype    多实例             IOC容器启动后并不会去调用方法创建对象放入容器中</span><span class="hljs-comment">     *              每次获取的时候才会调用方法创建对象，所以每次获取的对象都不相同</span><span class="hljs-comment">     * request      同一次请求创建一个实例</span><span class="hljs-comment">     * session      同一次 session 创建一个实例</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Scope</span>(<span class="hljs-string">"singleton"</span>)    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">"lisi"</span>, <span class="hljs-number">20</span>);    &#125;&#125;</code></pre></div><p>测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig2<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    User bean1 = context.getBean(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    User bean2 = context.getBean(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(bean1 == bean2);&#125;</code></pre></div><p><img src="https://i.loli.net/2020/07/01/gPvzRnT1qFH87UJ.png" srcset="/img/loading.gif" alt="image.png"></p><p>换成 <strong>prototype</strong> 之后</p><p><img src="https://i.loli.net/2020/07/01/1RUx534fcPwpGSk.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="Lazy-Bean懒加载"><a href="#Lazy-Bean懒加载" class="headerlink" title="@Lazy - Bean懒加载"></a>@Lazy - Bean懒加载</h3><p>单实例bean，默认在容器启动的时候创建对象。<br>懒加载，容器启动时不创建对象，在第一次使用（获取）bean的时候创建，并初始化。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式七大原则</title>
    <link href="/2020/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2020/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><p>设计模式体现了代码的耦合性， 内聚性以及可维护性，可扩展性，重用性，灵活性。</p><ol><li>代码重用性（即：相同功能的代码，不用多次编写）</li><li>可读性（即：编程规范性，便于其他程序员的阅读和理解）</li><li>可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）</li><li>可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</li><li>使程序呈现高内聚，低耦合的特性</li></ol><p><em>Scott Mayers在其巨著《Effective C++》说过: C++老手和C++新手的区别就是前者手背上有很多伤疤。</em></p><ul><li>同样是面向对象，当然也可指 Java</li></ul><h2 id="一、单一职责原则（Single-responsibility）"><a href="#一、单一职责原则（Single-responsibility）" class="headerlink" title="一、单一职责原则（Single responsibility）"></a>一、单一职责原则（Single responsibility）</h2><p>单一职责原则注意事项和细节：</p><ol><li>降低类的复杂度，一个类只负责一项职责；</li><li>提高类的可读性，可维护性；</li><li>降低变更引起的风险;</li><li>通常情况下，应当遵守单一职责原则， 只有逻辑足够简单，才可以在方法级违反单一职责原则。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:42</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 只有类中方法数量足够少，可以在方法级别保持单一职责原则</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleResponsibility</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Vehicle vehicle = <span class="hljs-keyword">new</span> Vehicle();        vehicle.run(<span class="hljs-string">"柯尼塞格"</span>);        vehicle.fly(<span class="hljs-string">"波音747"</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 逻辑简单，方法级别实现单一职责</span><span class="hljs-comment"> * 逻辑复杂，分类实现单一职责</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String string)</span> </span>&#123;        System.out.println(string + <span class="hljs-string">"：是陆地交通工具"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(String string)</span> </span>&#123;        System.out.println(string + <span class="hljs-string">"：是空中交通工具"</span>);    &#125;&#125;</code></pre></div><h2 id="二、接口隔离原则（Interface-Segregation）"><a href="#二、接口隔离原则（Interface-Segregation）" class="headerlink" title="二、接口隔离原则（Interface Segregation）"></a>二、接口隔离原则（Interface Segregation）</h2><ol><li>类A通过接口 Interface1、2 依赖类B，类C通过接口 Interface1、3 依赖类D，如果接口 Interface 对于 类A 和 类C 来说不是最小接口，那么 类B 和 类D 必须去实现他们不需要的方法。</li><li>将接口 Interface 拆分为独立的几个接口，类A 和 类C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</li><li>接口 Interface 中出现的方法，根据实际情祝拆分为三个接口。<br><img src="https://i.loli.net/2020/06/30/8rCg7WDYnPzoc19.png" srcset="/img/loading.gif" alt="image.png"></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:49</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceSegregation</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        a.depend1(<span class="hljs-keyword">new</span> B());        a.depend2(<span class="hljs-keyword">new</span> B());        a.depend3(<span class="hljs-keyword">new</span> B());        C c = <span class="hljs-keyword">new</span> C();        c.depend1(<span class="hljs-keyword">new</span> D());        c.depend4(<span class="hljs-keyword">new</span> D());        c.depend5(<span class="hljs-keyword">new</span> D());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interface1</span>, <span class="hljs-title">interface2</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation1"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation2"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation3"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interface1</span>, <span class="hljs-title">interface3</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation1"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation4"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation5"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(interface1 i)</span> </span>&#123;        i.Operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(interface2 i)</span> </span>&#123;        i.Operation2();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(interface2 i)</span> </span>&#123;        i.Operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(interface1 i)</span> </span>&#123;        i.Operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(interface3 i)</span> </span>&#123;        i.Operation4();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(interface3 i)</span> </span>&#123;        i.Operation5();    &#125;&#125;</code></pre></div><h2 id="三、依赖倒转原则（Dependence-Inversion）"><a href="#三、依赖倒转原则（Dependence-Inversion）" class="headerlink" title="三、依赖倒转原则（Dependence Inversion）"></a>三、依赖倒转原则（Dependence Inversion）</h2><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象（缓冲层）；</li><li>抽象不应该依赖细节，细节应该依赖抽象；</li><li>依赖倒转(倒置)的中心思想是面向接口编程;</li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中， 抽象指的是接口或抽象类，细节就是具体的实现类；</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li></ol><p><strong>依赖关系三种传递方式：</strong></p><ul><li>接口传递（依赖）</li><li>构造方法传递（依赖）</li><li>setter方式传递（聚合）</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:51</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependenceInversion</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person person = <span class="hljs-keyword">new</span> Person();        person.receive(<span class="hljs-keyword">new</span> Email());        person.receive(<span class="hljs-keyword">new</span> WeChat());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Info</span></span>&#123;    <span class="hljs-function">String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Info</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Receive Email"</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeChat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Info</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Receive WeChat"</span>;    &#125;&#125;<span class="hljs-comment">//person 接受信息</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Info info)</span> </span>&#123;        System.out.println(info.getInfo());    &#125;&#125;</code></pre></div><h2 id="四、里氏替换原则（Liskov-Substitution）"><a href="#四、里氏替换原则（Liskov-Substitution）" class="headerlink" title="四、里氏替换原则（Liskov Substitution）"></a>四、里氏替换原则（Liskov Substitution）</h2><ol><li>里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院一位姓里的女士提出；</li><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象；</li><li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法；</li><li>继承实际上让两个类耦合性增强了，给程序带来侵入性。在适当的情况下，可以通过聚合，组合，依赖来解决问题；</li><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:56</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiskovSubstitution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        System.out.println(<span class="hljs-string">"2 - 1 = "</span> + a.func1(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));        B b = <span class="hljs-keyword">new</span> B();        System.out.println(<span class="hljs-string">"2 + 1 = "</span> + b.func1(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));        System.out.println(<span class="hljs-string">"2 + 1 + 9 = "</span> + b.func2(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));        System.out.println(<span class="hljs-string">"B类使用A类方法：2 - 1 = "</span> + b.func3(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">//把基础方法和成员抽取成基类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">return</span> num1 - num2;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<span class="hljs-comment">//    public int func1(int num1, int num2) &#123;</span><span class="hljs-comment">//        return num1 - num2;</span><span class="hljs-comment">//    &#125;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">// TODO 类 B `无意` 重写了父类 A 方法，造成原有方法发生改变。</span><span class="hljs-comment">//    @Override</span><span class="hljs-comment">//    public int func1(int num1, int num2) &#123;</span><span class="hljs-comment">//        return num1 + num2;</span><span class="hljs-comment">//    &#125;</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">return</span> num1 + num2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">return</span> func1(num1, num2) + <span class="hljs-number">9</span>;    &#125;    <span class="hljs-keyword">private</span> A a = <span class="hljs-keyword">new</span> A();<span class="hljs-comment">//组合</span>    <span class="hljs-comment">//使用 A 方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a.func1(num1, num2);    &#125;&#125;</code></pre></div><h2 id="五、开闭原则-OCP（Open-Closed）"><a href="#五、开闭原则-OCP（Open-Closed）" class="headerlink" title="五、开闭原则 OCP（Open Closed）"></a>五、开闭原则 OCP（Open Closed）</h2><ol><li>开闭原则(Open Closed Principle) 是编程中最基础、最重要的设计原则；</li><li>一个软件实体，比如类，模块和函数应该对提供方扩展开放，对使用方修改关闭。用抽象构建框架，用实现扩展细节；</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化；</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:49</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceSegregation</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        a.depend1(<span class="hljs-keyword">new</span> B());        a.depend2(<span class="hljs-keyword">new</span> B());        a.depend3(<span class="hljs-keyword">new</span> B());        C c = <span class="hljs-keyword">new</span> C();        c.depend1(<span class="hljs-keyword">new</span> D());        c.depend4(<span class="hljs-keyword">new</span> D());        c.depend5(<span class="hljs-keyword">new</span> D());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interface1</span>, <span class="hljs-title">interface2</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation1"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation2"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation3"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interface1</span>, <span class="hljs-title">interface3</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation1"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation4"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation5"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(interface1 i)</span> </span>&#123;        i.Operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(interface2 i)</span> </span>&#123;        i.Operation2();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(interface2 i)</span> </span>&#123;        i.Operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(interface1 i)</span> </span>&#123;        i.Operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(interface3 i)</span> </span>&#123;        i.Operation4();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(interface3 i)</span> </span>&#123;        i.Operation5();    &#125;&#125;</code></pre></div><h2 id="六、迪米特法则（Demeter）"><a href="#六、迪米特法则（Demeter）" class="headerlink" title="六、迪米特法则（Demeter）"></a>六、迪米特法则（Demeter）</h2><p>1.一个对象应该对其他对象保持最少的了解（最少知道原则 LKP）。<br>2. 类与类关系越密切，耦合度越大。要求降低类之间耦合，而不是完全解耦。<br>3. 迪米特法则(Demeter Principle)，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。<br>4. 迪米特法则更简单的定义：只与直接的朋友通信。<br>5. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/28 19:58</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());    &#125;&#125;<span class="hljs-comment">//学院员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-comment">//管理学院员工的管理类:</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;    <span class="hljs-comment">//返回学院的所有员工 //TODO CollegeEmployee 直接朋友</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <span class="hljs-comment">//这里我们增加了10 个员工到list ，</span>            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();            emp.setId(<span class="hljs-string">"学院员工id "</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printCollegeEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list1 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">"---学院员工----"</span>);        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;<span class="hljs-comment">//学校总部员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-comment">//学校管理类</span><span class="hljs-comment">//TODO 直接朋友 Employee CollegeManager</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;    <span class="hljs-comment">//返回学校总部的员工</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SchoolEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;SchoolEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;SchoolEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123; <span class="hljs-comment">//这里我们增加了5个员工到list</span>            SchoolEmployee emp = <span class="hljs-keyword">new</span> SchoolEmployee();            emp.setId(<span class="hljs-string">"学校总部员工id= "</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">//该方法完成输出学校总部和学院员工信息(id)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;        <span class="hljs-comment">//获取到学院员工</span>        <span class="hljs-comment">//TODO 非直接朋友 CollegeEmployee  应该提取到  CollegeManager</span><span class="hljs-comment">//        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><span class="hljs-comment">//        System.out.println("---学院员工----");</span><span class="hljs-comment">//        for (CollegeEmployee e : list1) &#123;</span><span class="hljs-comment">//            System.out.println(e.getId());</span><span class="hljs-comment">//        &#125;</span>        sub.printCollegeEmployee();<span class="hljs-comment">//只提供方法，不把具体实现放在其他类里面。</span>        <span class="hljs-comment">//获取到学校总部员工</span>        List&lt;SchoolEmployee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">"------学校总部员工------"</span>);        <span class="hljs-keyword">for</span> (SchoolEmployee e : list2) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;</code></pre></div><h2 id="七、合成复用原则（Composite-Reuse）"><a href="#七、合成复用原则（Composite-Reuse）" class="headerlink" title="七、合成复用原则（Composite Reuse）"></a>七、合成复用原则（Composite Reuse）</h2><p>合成复用原则 尽量使用组合/聚合的方式，而不是使用继承。</p><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/28 21:00</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeReuse</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">"------依赖------"</span>);        B b = <span class="hljs-keyword">new</span> B();        b.Operation1(<span class="hljs-keyword">new</span> A());        System.out.println(<span class="hljs-string">"------聚合------"</span>);        b.setA(<span class="hljs-keyword">new</span> A());        b.Operation2();        System.out.println(<span class="hljs-string">"------组合------"</span>);        b.Operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"A Operation1"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"A Operation2"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"A Operation3"</span>);    &#125;&#125;<span class="hljs-comment">//如果只是需要用到 A类的方法，尽量不要使用继承。而是使用，依赖，聚合，组合的方式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">(A a)</span> </span>&#123;<span class="hljs-comment">//TODO 依赖</span>        a.Operation1();        a.Operation2();        a.Operation3();    &#125;    <span class="hljs-comment">//==============================================================</span>    A a;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A a)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a = a;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//TODO 聚合</span>        a.Operation1();        a.Operation2();        a.Operation3();    &#125;    <span class="hljs-comment">//==============================================================</span>    A a1 = <span class="hljs-keyword">new</span> A();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//TODO 组合</span>        a1.Operation1();        a1.Operation2();        a1.Operation3();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis使用 - 基于XML和注解</title>
    <link href="/2020/06/29/MyBatis%E4%BD%BF%E7%94%A8%20-%20%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <url>/2020/06/29/MyBatis%E4%BD%BF%E7%94%A8%20-%20%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h3><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="使用MyBatis"><a href="#使用MyBatis" class="headerlink" title="使用MyBatis"></a>使用MyBatis</h2><h3 id="1-准备数据库"><a href="#1-准备数据库" class="headerlink" title="1.准备数据库"></a>1.准备数据库</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> score(    sno           <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">''</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>        primary <span class="hljs-keyword">key</span>,    <span class="hljs-keyword">name</span>          <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">''</span> <span class="hljs-literal">null</span>,    <span class="hljs-keyword">Java</span>          <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    C             <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    Algorithm     <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    LinearAlgebra <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    English       <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    PE            <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>);</code></pre></div><p>在表里添加几条数据</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861200'</span>, <span class="hljs-string">'张三'</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, <span class="hljs-number">61</span>, <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861249'</span>, <span class="hljs-string">'王五'</span>, <span class="hljs-number">43</span>, <span class="hljs-number">65</span>, <span class="hljs-number">76</span>, <span class="hljs-number">33</span>, <span class="hljs-number">64</span>, <span class="hljs-number">76</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861255'</span>, <span class="hljs-string">'李四'</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">60</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">100</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861258'</span>, <span class="hljs-string">'john'</span>, <span class="hljs-number">23</span>, <span class="hljs-number">54</span>, <span class="hljs-number">21</span>, <span class="hljs-number">35</span>, <span class="hljs-number">87</span>, <span class="hljs-number">57</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861259'</span>, <span class="hljs-string">'jack'</span>, <span class="hljs-number">41</span>, <span class="hljs-number">43</span>, <span class="hljs-number">54</span>, <span class="hljs-number">75</span>, <span class="hljs-number">43</span>, <span class="hljs-number">13</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861260'</span>, <span class="hljs-string">'hellen'</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">76</span>, <span class="hljs-number">99</span>, <span class="hljs-number">57</span>, <span class="hljs-number">97</span>);</code></pre></div><h3 id="2-新建一个-Maven-项目"><a href="#2-新建一个-Maven-项目" class="headerlink" title="2. 新建一个 Maven 项目"></a>2. 新建一个 Maven 项目</h3><p>将下面的依赖代码置于 pom.xml 文件中：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="3-新建一个-Mybatis-config-xml配置文件"><a href="#3-新建一个-Mybatis-config-xml配置文件" class="headerlink" title="3. 新建一个 Mybatis-config.xml配置文件"></a>3. 新建一个 Mybatis-config.xml配置文件</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta"><span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta"><span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/userinfo?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8<span class="hljs-symbol">&amp;amp;</span>useSSL=true<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"LWJLWJ20000829"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"mapper/ScoreMapper.xml"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p>还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。</p><h3 id="4-获取SqlSessionFactory"><a href="#4-获取SqlSessionFactory" class="headerlink" title="4. 获取SqlSessionFactory"></a>4. 获取SqlSessionFactory</h3><p>每个基于 MyBatis 的应用都是以一个 <strong>SqlSessionFactory</strong> 的实例为核心的。<strong>SqlSessionFactory</strong>的实例可以通过 <strong>SqlSessionFactoryBuilder</strong> 获得。而 <strong>SqlSessionFactoryBuilder</strong> 则可以从 XML 配置文件来构建出 SqlSessionFactory 实例。</p><p>从 XML 文件中构建 <strong>SqlSessionFactory</strong> 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例。MyBatis 中有一个 <strong>Resources</strong> 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。但是在这里我是用自定义工具类来获取。</p><ul><li>在utils包下新建MyBatisUtils工具类<br><img src="https://www.lwjppz.cn/upload/2020/6/image-a66e9bbd27a3483dbea4b71515616c65.png" srcset="/img/loading.gif" alt="image.png"></li><li>加入以下代码<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>      : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/29 14:05</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;    <span class="hljs-keyword">static</span> &#123;        InputStream inputStream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 使用MyBatis 从 XML 文件中构建 SqlSessionFactory 的实例</span>            String resource = <span class="hljs-string">"mybatis-config.xml"</span>;            inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 有了 SqlSessionFactory，可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SqlSession对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();    &#125;&#125;</code></pre></div></li></ul><h3 id="从-SqlSessionFactory-中获取-SqlSession，执行-SQl-语句"><a href="#从-SqlSessionFactory-中获取-SqlSession，执行-SQl-语句" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession，执行 SQl 语句"></a>从 SqlSessionFactory 中获取 SqlSession，执行 SQl 语句</h3><p>既然有了 <strong>SqlSessionFactory</strong>，顾名思义，我们可以从中获得 <strong>SqlSession</strong>的实例。<strong>SqlSession</strong> 提供了在数据库执行 SQL 命令所需的所有方法。可以通过 <strong>SqlSession</strong> 实例来直接执行已映射的 SQL 语句。</p><ol><li><p>准备实体类，MyBatis 应用了 <strong>ORM（对象关系映射）</strong> 思想，实体类字段应于数据库字段一一对应</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/29 14:15</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String sno;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer Java;    <span class="hljs-keyword">private</span> Integer C;    <span class="hljs-keyword">private</span> Integer Algorithm;    <span class="hljs-keyword">private</span> Integer LinearAlgebra;    <span class="hljs-keyword">private</span> Integer English;    <span class="hljs-keyword">private</span> Integer PE;&#125;</code></pre></div><p>其余方法请自行补充</p><ol start="2"><li>在 <strong>dao</strong> 包下新建 ScoreMapper，<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.entites.Score;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/29 14:21</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScoreMapper</span> </span>&#123;    <span class="hljs-function">List&lt;Score&gt; <span class="hljs-title">getAllScores</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div></li></ol></li><li><p>在 <strong>resources</strong> 下新建 <strong>mapper</strong> 文件夹，在此文件夹下新建 ScoreMapper.xml<br><img src="https://www.lwjppz.cn/upload/2020/6/image-177a6fa94929407887a659baa22b7997.png" srcset="/img/loading.gif" alt="image.png"></p></li></ol><p><strong>需要注意：</strong><br><img src="https://www.lwjppz.cn/upload/2020/6/image-76c77cbef5b44ab8bff90684916745f8.png" srcset="/img/loading.gif" alt="image.png"><br>     - namespace：对应刚刚写的那个映射语句类 - <strong>ScoreMapper</strong> （需写全类名）<br>     - id：对应 <strong>ScoreMapper</strong> 中的 <strong>getAllScores</strong> 方法<br>     - resultType：查询结果类型</p><ol start="4"><li>编写测试类测试：<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.dao.ScoreMapper;<span class="hljs-keyword">import</span> cn.lwjppz.entites.Score;<span class="hljs-keyword">import</span> cn.lwjppz.utils.MyBatisUtils;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/29 14:55</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        SqlSession sqlSession = MyBatisUtils.getSqlSession();        ScoreMapper scoreMapper = sqlSession.getMapper(ScoreMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        List&lt;Score&gt; scores = scoreMapper.getAllScores();        <span class="hljs-keyword">for</span> (Score score: scores) &#123;            System.out.println(score);        &#125;    &#125;&#125;</code></pre></div></li><li>测试结果<br><img src="https://www.lwjppz.cn/upload/2020/6/image-a495ae4bc00149f397ad8a26010923af.png" srcset="/img/loading.gif" alt="image.png"></li></ol><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>使用注解的方法很简单，只需在 <strong>ScoreMapper</strong> 中的 <strong>getAllScores</strong> 方法上加入 <strong>Select</strong> 注解<br><img src="https://www.lwjppz.cn/upload/2020/6/image-9e72e0b0cdb947a196c672cf4640471a.png" srcset="/img/loading.gif" alt="image.png"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScoreMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM score"</span>)    <span class="hljs-function">List&lt;Score&gt; <span class="hljs-title">getAllScores</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>删除 <strong>ScoreMapper.xml</strong> 中的 select 标签</p><p><img src="https://www.lwjppz.cn/upload/2020/6/image-76f46a04112b4a7f9ac15d88dbf2b50f.png" srcset="/img/loading.gif" alt="image.png"></p><p>测试通过</p><p><img src="https://www.lwjppz.cn/upload/2020/6/image-301227922c1e4b399c140c5dfe5e9532.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</p><p>选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eternal</title>
    <link href="/2020/06/21/Eternal/"/>
    <url>/2020/06/21/Eternal/</url>
    
    <content type="html"><![CDATA[<h1 align="center"><a href="https://github.com/halo-dev" target="_blank">Eternal</a></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Eternal</strong> <code>[ɪˈtɜːrnl]</code>，意为永恒。</p><p>一个清新简约的博客系统，可适配多主题</p><blockquote><p><a href="http://39.106.117.247/" target="_blank" rel="noopener">预览地址</a></p></blockquote><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><blockquote><p>本项目只是为了个人使用而开发，<br>项目起初是很简陋的，后来由于学校课程各种设计，所以博客的功能越来越多，也越来越完善，有兴趣的童鞋可以看看</p></blockquote><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><ul><li>项目采用Vue + SpringBoot开发，对于练习SpringBoot和Vue是个不错的练手项目</li><li>后台管理使用Vue + ant-design-vue搭建，后台是通用模板，当然如果不喜欢的话可以独立开发，对于其他功能并不影响</li><li>前台使用thymeleaf模板引擎渲染，可通过api进行主题适配</li><li>…………..</li></ul><h2 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/sJYBuHCA8DX6mjr.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/4MGgua3qVcK9Q8f.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/4lb6KwjnveS9REk.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/njVu791hOPgxedt.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/Cnva7NUES5w4lsu.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/g5MN1kl4K9pz6da.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/GjImg7lX6preMW8.png" srcset="/img/loading.gif" alt=""></h2><p><img src="https://i.loli.net/2020/06/28/JPf6GazQmbyOD89.png" srcset="/img/loading.gif" alt=""></p><hr>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eternal</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASP.NET MVC 学习笔记</title>
    <link href="/2020/06/21/ASP.NET%20MVC%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/21/ASP.NET%20MVC%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ASP-NET-MVC"><a href="#ASP-NET-MVC" class="headerlink" title="ASP.NET MVC"></a>ASP.NET MVC</h1><h3 id="1-数据的验证"><a href="#1-数据的验证" class="headerlink" title="1. 数据的验证"></a>1. 数据的验证</h3><ol><li>在Models文件夹下，为需要验证的model类中加入 </li></ol><p><strong>using System.ComponentModel.DataAnnotations;</strong> 命名空间的引入</p><ol start="2"><li><p>添加注解：</p><ul><li><p>显示自定义名称</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">Display(Name = <span class="hljs-meta-string">"标题"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Title &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div></li><li><p>使用正则表达式验证输入的字符串是否符合格式要求。</p><div class="hljs"><pre><code class="hljs C#">[RegularExpression(@&quot;^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$&quot;, ErrorMessage &#x3D; &quot;邮箱不正确&quot;)]public string Email &#123; get; set; &#125;</code></pre></div></li><li><p>Required特性，则此项为必填项。用于不为空校验。默认为不允许为空。允许为空则添加AllowEmptyStrings = true</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">Required(ErrorMessage = <span class="hljs-meta-string">"密码不能为空"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Password &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div></li><li><p>限定字符串长度。</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">StringLength(20,ErrorMessage = <span class="hljs-meta-string">"密码不能超过20个字符"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Password &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div></li><li><p>用来判断两个属性是否拥有相同的值。例如，确保两次输入的密码相同。比较两个值是否一致，一般用于二次输入。<strong>Password</strong>是需要比较的值</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">Compare(<span class="hljs-meta-string">"Password"</span>,ErrorMessage = <span class="hljs-meta-string">"两次输入不一致"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> PasswordConfirm &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div><p>以上验证将对PasswordConfirm和Password进行是否一致的比较。</p></li><li><p><strong>Remote</strong>利用服务器端的回调函数执行客户端的逻辑验证。这个在登录的时候用的非常多。比如你的用户名ID是否已经被注册</p><p>需要添加 <strong>using System.Web.Mvc;</strong></p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">Remote(<span class="hljs-meta-string">"CheckUserName"</span>,<span class="hljs-meta-string">"Home"</span>,ErrorMessage = <span class="hljs-meta-string">"用户名已被注册"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> UserName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div><p>然后在<strong>Home</strong>这个Controller里面添加<strong>CheckUserName</strong>方法，判断用户名是否存在需要从数据库读取判断，此处只是demo</p><div class="hljs"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ActionResult CheckUserName()&#123;    string LastName = Request[<span class="hljs-string">"LastName"</span>];    <span class="hljs-keyword">if</span> (<span class="hljs-string">"admin"</span>.Equals(LastName))        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">Json</span><span class="hljs-params">(<span class="hljs-keyword">false</span>, JsonRequestBehavior.AllowGet)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">Json</span><span class="hljs-params">(<span class="hljs-keyword">true</span>, JsonRequestBehavior.AllowGet)</span></span>;&#125;</code></pre></div></li></ul></li><li><p>添加视图，在视图页面确保已添加 <strong>Jquery库、Jquery.Validate、Jquery.Validate.unobtrusive这三个文件。</strong></p><h5 id="小贴士：在创建视图时选择-Create-模板，自带上面这三个，亲测有用哦。"><a href="#小贴士：在创建视图时选择-Create-模板，自带上面这三个，亲测有用哦。" class="headerlink" title="小贴士：在创建视图时选择 Create 模板，自带上面这三个，亲测有用哦。"></a>小贴士：在创建视图时选择 <strong><em>Create</em></strong> 模板，自带上面这三个，亲测有用哦。</h5><p><img src="https://i.loli.net/2020/06/21/fQ569yNbk3dTSDJ.png" srcset="/img/loading.gif" alt="QQ截图20200621091244.png"></p></li></ol><h3 id="2-Action过滤器"><a href="#2-Action过滤器" class="headerlink" title="2. Action过滤器"></a>2. Action过滤器</h3><h5 id="自定义Actioon过滤器"><a href="#自定义Actioon过滤器" class="headerlink" title="自定义Actioon过滤器"></a>自定义Actioon过滤器</h5><ol><li>首先新建Filters文件夹，在Filters下新建如下图所示</li></ol><p><img src="https://i.loli.net/2020/06/21/4OYxz9wnPNgbQVv.png" srcset="/img/loading.gif" alt="filter.png"></p><div class="hljs"><pre><code class="hljs cs"><span class="hljs-keyword">using</span> System;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> System.Linq;<span class="hljs-keyword">using</span> System.Web;<span class="hljs-keyword">using</span> System.Web.Mvc;<span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo.Filters</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyActionFilterAttribute</span> : <span class="hljs-title">ActionFilterAttribute</span>    &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnActionExecuting</span>(<span class="hljs-params">ActionExecutingContext filterContext</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">base</span>.OnActionExecuting(filterContext);            filterContext.HttpContext.Response.Write(<span class="hljs-string">"Action执行之前"</span> + Message + <span class="hljs-string">"&lt;br /&gt;"</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnActionExecuted</span>(<span class="hljs-params">ActionExecutedContext filterContext</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">base</span>.OnActionExecuted(filterContext);            filterContext.HttpContext.Response.Write(<span class="hljs-string">"Action执行之后"</span> + Message + <span class="hljs-string">"&lt;br /&gt;"</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnResultExecuting</span>(<span class="hljs-params">ResultExecutingContext filterContext</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">base</span>.OnResultExecuting(filterContext);            filterContext.HttpContext.Response.Write(<span class="hljs-string">"返回Result之前"</span> + Message + <span class="hljs-string">"&lt;br /&gt;"</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnResultExecuted</span>(<span class="hljs-params">ResultExecutedContext filterContext</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">base</span>.OnResultExecuted(filterContext);            filterContext.HttpContext.Response.Write(<span class="hljs-string">"返回Result之后"</span> + Message + <span class="hljs-string">"&lt;br /&gt;"</span>);        &#125;    &#125;&#125;</code></pre></div><ol start="2"><li><p>在需要的控制器下添加方法</p><div class="hljs"><pre><code class="hljs aspectj">[MyActionFilter] <span class="hljs-comment">//也可以加参数 [MyActionFilter(Message="lwjppz")]</span><span class="hljs-keyword">public</span> ActionResult ActionFilterDemo()&#123;    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">View</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div></li></ol><p>添加视图后，运行结果：</p><p><img src="https://i.loli.net/2020/06/21/9ftKIJz8onX3OFm.png" srcset="/img/loading.gif" alt="filter.png"></p><h3 id="3-Authorization过滤器"><a href="#3-Authorization过滤器" class="headerlink" title="3. Authorization过滤器"></a>3. Authorization过滤器</h3><p>在MVC中使用AuthorizeAttribute实现登陆和权限控制。</p><p>在执行需要登录和权限的Action前先判断用户是否登陆，若没登陆就跳转到登陆页，然后再判断用户是否有权限访问该Action对应的视图页面，若没有则跳转到特定提示页。</p><h4 id="范例："><a href="#范例：" class="headerlink" title="范例："></a>范例：</h4><p>先添加一个控制器AccountController：</p><div class="hljs"><pre><code class="hljs c#">public class AccountController : Controller&#123;    public ActionResult Index()    &#123;      return View();    &#125;&#125;</code></pre></div><p>然后再web.config文件中的&lt;system.web&gt;节中添加：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">authentication</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"Forms"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">forms</span> <span class="hljs-attr">loginUrl</span>=<span class="hljs-string">"~/Account/Index"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2880"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">authentication</span>&gt;</span></code></pre></div><p>用来启用登录和权限验证，当用户未登录时将跳转到loginUrl指定的页面。</p><p>Forms 身份验证将身份验证标记保留在 Cookie 或页的 URL 中。Forms 身份验证通过 FormsAuthenticationModule 类参与到 ASP.NET 页面的生命周期中。可以通过 FormsAuthentication 类访问 Forms 身份验证信息和功能。</p><p>然后，在filterConfig.cs文件中的RegisterGlobalFilters方法中添加：</p><div class="hljs"><pre><code class="hljs c#">public static void RegisterGlobalFilters(GlobalFilterCollection filters)&#123;    filters.Add(new HandleErrorAttribute());    filters.Add(new AuthorizeAttribute());&#125;</code></pre></div><p>运行程序，当访问Home控制器下的Index页面时会跳转到Account控制器的Index页面，显示如下页面：</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/85eb06c7b5d28967a657a407f9c4c8bb.png" srcset="/img/loading.gif" alt="img"><br>某一些页面是需要未登录也能访问的，此时我们可以在相应的Action上添加匿名登录标记[<strong>AllowAnonymous</strong>]，例如上面的Home控制器中的Index页面和Account控制器中的Index页面都需要匿名访问权限：</p><div class="hljs"><pre><code class="hljs c#">[AllowAnonymous]public ActionResult Index()&#123;    return View();&#125;</code></pre></div><p>此时再访问Home控制器中的Index页面就能正常显示了。</p><p>需要注意的是，如果在能够匿名访问的页面中嵌套了需要登录和权限的子页面，则匿名访问的页面不能正常显示。例如：</p><p>在Home控制器中的Index视图页面中嵌套了@{Html.RenderAction(“ChildActionOnly”);}语句，即内嵌了ChildActionOnly页面，而该页面是需要登录才能访问的，则Index页面也不能正常显示。</p><p>此时再运行程序，访问需要登录的页面时会跳转到登录页面：</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/815dad3c682f9cb2b3bfb25b1f0f282c.png" srcset="/img/loading.gif" alt="img">注意，如果Account控制器的Index登录页面没有匿名访问标记则会提示错误：</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/85eb06c7b5d28967a657a407f9c4c8bb.png" srcset="/img/loading.gif" alt="img"></p><h4 id="登录系统"><a href="#登录系统" class="headerlink" title="登录系统"></a>登录系统</h4><p>登录的控制器中在用户名和密码验证成功之后，应添加代码</p><p><strong>FormsAuthentication.SetAuthCookie(username, false);</strong></p><p>可用User.Identity.Name来获取当前的登录名，如：</p><p><strong>string userid = HttpContext.User.Identity.Name;</strong></p><h5 id="范例：-1"><a href="#范例：-1" class="headerlink" title="范例："></a>范例：</h5><p>修改Account控制器中的Index方法：</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">AllowAnonymous</span>]<span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">string</span> returnURL = Request[<span class="hljs-string">"ReturnUrl"</span>];    ViewBag.returnURL = returnURL;    <span class="hljs-keyword">return</span> View();&#125;</code></pre></div><p>在Account控制器中添加一个Action，用于校验用户输入的用户名和密码是否正确：      </p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-literal">[A<span class="hljs-identifier">llowAnonymous</span>]</span>public ActionResult <span class="hljs-constructor">Login(<span class="hljs-params">string</span> <span class="hljs-params">username</span>,<span class="hljs-params">string</span> <span class="hljs-params">password</span>,<span class="hljs-params">string</span> <span class="hljs-params">returnURL</span>)</span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-string">"admin"</span>.<span class="hljs-constructor">Equals(<span class="hljs-params">username</span>)</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-string">"123456"</span>.<span class="hljs-constructor">Equals(<span class="hljs-params">password</span>)</span>)    &#123;        FormsAuthentication.<span class="hljs-constructor">SetAuthCookie(<span class="hljs-params">username</span>, <span class="hljs-params">false</span>)</span>;<span class="hljs-comment">//设置用户登录成功（设置cookie），false表示cookie不要持久保存**</span>        <span class="hljs-keyword">if</span> (Url.<span class="hljs-constructor">IsLocalUrl(<span class="hljs-params">returnURL</span>)</span>)        &#123;            return <span class="hljs-constructor">Redirect(<span class="hljs-params">returnURL</span>)</span>;        &#125;        return <span class="hljs-constructor">RedirectToAction(<span class="hljs-string">"Index"</span>,<span class="hljs-string">"Home"</span>)</span>;    &#125;    return <span class="hljs-constructor">View()</span>;&#125;</code></pre></div><p>此时再访问需要登录才能访问的页面会跳转到登录页面，在登录页面输入正确的用户名和密码后就可以访问所有需要登录才能访问的页面了。</p><h5 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h5><p>使用如下的语句来退出登录：</p><p>FormsAuthentication.SignOut();//通过Forms验证来删除Cookie</p><h5 id="权限的验证"><a href="#权限的验证" class="headerlink" title="权限的验证"></a>权限的验证</h5><p>可以指定某个Controller或某个Action只能由指定的用户或角色访问。</p><h5 id="指定特定用户访问"><a href="#指定特定用户访问" class="headerlink" title="指定特定用户访问"></a>指定特定用户访问</h5><p>可以使用[Authorize(Users=”登录的用户名”)]的方式来限定。</p><p>如果可以由多个用户访问，在不同用户间用逗号分隔。</p><h5 id="范例：-2"><a href="#范例：-2" class="headerlink" title="范例："></a>范例：</h5><p>在Home控制器中修改Action：</p><p>在一个Action前面加上：</p><p><strong>[Authorize(Users=”admin”)]</strong></p><p>表示该Action只能由用户admin访问。</p><p>在另一个Action前面加上：</p><p><strong>[Authorize(Users=”sysadmin”)]</strong></p><p>表示该Action只能由用户sysadmin访问。</p><h5 id="指定特定角色访问"><a href="#指定特定角色访问" class="headerlink" title="指定特定角色访问"></a>指定特定角色访问</h5><p>可以使用[Authorize(Roles=”登录的用户名所属的角色”)]的方式来限定。</p><p>如果可以由多个角色访问，在不同角色间用逗号分隔。</p><h5 id="范例：-3"><a href="#范例：-3" class="headerlink" title="范例："></a>范例：</h5><p>在Home控制器中修改Action：</p><p>在一个Action前面加上：</p><p><strong>[Authorize(Roles=”admin”)]</strong></p><p>表示该Action只能由角色admin访问。</p><p>在另一个Action前面加上：</p><p><strong>[Authorize(Roles=”sysadmin”)]</strong></p><p>表示该Action只能由角色sysadmin访问。</p><p>需要注意的是：</p><p>1、我们必须实现自己的RoleProvider，主要是从RoleProvider这个抽象类派生出自己的子类，并重写其中的GetRolesForUser方法：</p><div class="hljs"><pre><code class="hljs c#">public class CustomRoleProvider:RoleProvider&#123;    public override string[] GetRolesForUser(string username)    &#123;        var cookie &#x3D; HttpContext.Current.Request.Cookies[FormsAuthentication.FormsCookieName];        var ticket &#x3D; FormsAuthentication.Decrypt(cookie.Value);        string role &#x3D; ticket.UserData;        return role.Split(&#39;,&#39;);    &#125;    public override void AddUsersToRoles(string[] usernames, string[] roleNames)    &#123;        throw new NotImplementedException();    &#125;    public override string ApplicationName    &#123;        get &#123;            throw new NotImplementedException();        &#125;        set &#123;            throw new NotImplementedException();        &#125;    &#125;    public override void CreateRole(string roleName)    &#123;        throw new NotImplementedException();    &#125;    public override bool DeleteRole(string roleName, bool throwOnPopulatedRole)    &#123;        throw new NotImplementedException();    &#125;    public override string[] FindUsersInRole(string roleName, string usernameToMatch)    &#123;        throw new NotImplementedException();    &#125;    public override string[] GetAllRoles()    &#123;        throw new NotImplementedException();    &#125;    public override string[] GetUsersInRole(string roleName)    &#123;        throw new NotImplementedException();    &#125;        public override bool IsUserInRole(string username, string roleName)    &#123;        throw new NotImplementedException();    &#125;    public override void RemoveUsersFromRoles(string[] usernames, string[] roleNames)    &#123;        throw new NotImplementedException();    &#125;    public override bool RoleExists(string roleName)    &#123;        throw new NotImplementedException();    &#125;&#125;</code></pre></div><p>2、必须修改web.config文件中的设置：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">roleManager</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">defaultProvider</span>=<span class="hljs-string">"CustomRoleProvider"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">providers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">clear</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CustomRoleProvider"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"FilterDemo.Filters.CustomRoleProvider"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">providers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">roleManager</span>&gt;</span></code></pre></div><p>注意：这里type必须改成自己的命名空间.文件夹.类名。name的值可以与类名不同。但必须保证defaultProvider的值必须是下面add中某个name的值。</p><p>3、在登录验证的Action中自己定义cookie来存放用户名和角色信息：</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">AllowAnonymous</span>]<span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Logon</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> username, <span class="hljs-keyword">string</span> password, <span class="hljs-keyword">string</span> returnUrl</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-string">"admin"</span>.Equals(username) &amp;&amp; <span class="hljs-string">"123456"</span>.Equals(password))    &#123;        <span class="hljs-keyword">string</span> role = <span class="hljs-string">"admin,sysadmin"</span>;        <span class="hljs-keyword">var</span> authTicket = <span class="hljs-keyword">new</span> FormsAuthenticationTicket(            <span class="hljs-number">1</span>,               <span class="hljs-comment">// 版本</span>            username,           <span class="hljs-comment">// 用户名称</span>            DateTime.Now,         <span class="hljs-comment">// 创建日期</span>            DateTime.Now.AddMinutes(<span class="hljs-number">20</span>),  <span class="hljs-comment">// 过期时间</span>            <span class="hljs-literal">false</span>,             <span class="hljs-comment">// 是否记住</span>            role              <span class="hljs-comment">// 用户角色</span>        );        <span class="hljs-keyword">string</span> encryptedTicket = FormsAuthentication.Encrypt(authTicket);        <span class="hljs-keyword">var</span> authCookie = <span class="hljs-keyword">new</span> HttpCookie(FormsAuthentication.FormsCookieName, encryptedTicket);        authCookie.HttpOnly = <span class="hljs-literal">true</span>;<span class="hljs-comment">//客户端脚本不能访问</span>        authCookie.Secure = FormsAuthentication.RequireSSL;<span class="hljs-comment">//是否仅用https传递cookie</span>        authCookie.Domain = FormsAuthentication.CookieDomain;<span class="hljs-comment">//与cookie关联的域</span>        authCookie.Path = FormsAuthentication.FormsCookiePath;<span class="hljs-comment">//cookie关联的虚拟路径</span>        Response.Cookies.Add(authCookie);        <span class="hljs-keyword">if</span> (Url.IsLocalUrl(returnUrl))        &#123;            <span class="hljs-keyword">return</span> Redirect(returnUrl);        &#125;        <span class="hljs-keyword">return</span> RedirectToAction(<span class="hljs-string">"Index"</span>, <span class="hljs-string">"Account"</span>);    &#125;    <span class="hljs-keyword">return</span> RedirectToAction(<span class="hljs-string">"Index"</span>, <span class="hljs-string">"Account"</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ASP.NET MVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ASP.NET MVC</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用css实现的一个loading效果</title>
    <link href="/2020/05/05/%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AAloading%E6%95%88%E6%9E%9C/"/>
    <url>/2020/05/05/%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AAloading%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>最终的效果是这样的<br><img src="D:%5Cblog%5CHexo%5Cmy-hexo-blog%5Cimgs%5Clove-loading-9c168462618d4863a1f74be7b0f4f6ab.gif" srcset="/img/loading.gif" alt="loveloading.gif"></p><p>Html代码：</p><div class="hljs"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Love_Loading<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/style.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>css代码：</p><div class="hljs"><pre><code class="hljs CSS">* &#123;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">ol</span> &#123;  <span class="hljs-attribute">list-style</span>: none;&#125;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">justify-content</span>: center;  <span class="hljs-attribute">align-items</span>: center;&#125;<span class="hljs-selector-tag">ul</span> &#123;  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">background-color</span>: red;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(1)</span> &#123;  <span class="hljs-attribute">background-color</span>: red;  <span class="hljs-attribute">animation</span>: love1 <span class="hljs-number">3s</span> <span class="hljs-number">0s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(2)</span> &#123;  <span class="hljs-attribute">background-color</span>: darkturquoise;  <span class="hljs-attribute">animation</span>: love2 <span class="hljs-number">3s</span> <span class="hljs-number">0.1s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(3)</span> &#123;  <span class="hljs-attribute">background-color</span>: darksalmon;  <span class="hljs-attribute">animation</span>: love3 <span class="hljs-number">3s</span> <span class="hljs-number">0.2s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(4)</span> &#123;  <span class="hljs-attribute">background-color</span>: deeppink;  <span class="hljs-attribute">animation</span>: love4 <span class="hljs-number">3s</span> <span class="hljs-number">0.3s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(5)</span> &#123;  <span class="hljs-attribute">background-color</span>: yellow;  <span class="hljs-attribute">animation</span>: love5 <span class="hljs-number">3s</span> <span class="hljs-number">0.4s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(6)</span> &#123;  <span class="hljs-attribute">background-color</span>: deeppink;  <span class="hljs-attribute">animation</span>: love4 <span class="hljs-number">3s</span> <span class="hljs-number">0.5s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(7)</span> &#123;  <span class="hljs-attribute">background-color</span>: darksalmon;  <span class="hljs-attribute">animation</span>: love3 <span class="hljs-number">3s</span> <span class="hljs-number">0.6s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(8)</span> &#123;  <span class="hljs-attribute">background-color</span>: darkturquoise;  <span class="hljs-attribute">animation</span>: love2 <span class="hljs-number">3s</span> <span class="hljs-number">0.7s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(9)</span> &#123;  <span class="hljs-attribute">background-color</span>: red;  <span class="hljs-attribute">animation</span>: love1 <span class="hljs-number">3s</span> <span class="hljs-number">0.8s</span> infinite;&#125;<span class="hljs-keyword">@keyframes</span> love1 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">30px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;<span class="hljs-keyword">@keyframes</span> love2 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">125px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">60px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;<span class="hljs-keyword">@keyframes</span> love3 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">160px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">75px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;<span class="hljs-keyword">@keyframes</span> love4 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">180px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">30px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;<span class="hljs-keyword">@keyframes</span> love5 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">45px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>博客美化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot集成JWT实现token验证</title>
    <link href="/2020/04/18/SpringBoot%E9%9B%86%E6%88%90JWT%E5%AE%9E%E7%8E%B0token%E9%AA%8C%E8%AF%81/"/>
    <url>/2020/04/18/SpringBoot%E9%9B%86%E6%88%90JWT%E5%AE%9E%E7%8E%B0token%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<p>由于最近有个微信小程序的项目需要用到这个东西, 正好写这篇文章记录一下</p><h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h3><p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>我们要先知道token的认证和传统的session认证的区别。</p><h4 id="一般传统的session认证流程"><a href="#一般传统的session认证流程" class="headerlink" title="一般传统的session认证流程"></a>一般传统的session认证流程</h4><ol><li>用户向服务器发送用户名和密码。</li><li>服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li><li>服务器向用户返回一个 session_id，写入用户的 Cookie。</li><li>用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li><li>服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li></ol><p>这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.</p><h4 id="基于session认证所显露的问题"><a href="#基于session认证所显露的问题" class="headerlink" title="基于session认证所显露的问题"></a>基于session认证所显露的问题</h4><p><strong>Session:</strong> 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p><p><strong>扩展性:</strong> 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p><p><strong>CSRF:</strong> 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p><h3 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h3><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><p>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值</li><li>服务端验证token值，并返回数据</li></ul><p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，我的另一篇文章有讲SpringBoot怎么实现CORS, 附上链接： <a href="https://www.lwjppz.cn/archives/springboot-cors" target="_blank" rel="noopener">SpringBoot解决跨域问题</a></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快</li><li>自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库</li><li>因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。</li><li>不需要在服务端保存会话信息，特别适用于分布式微服务。</li></ul><h3 id="JWT请求流程"><a href="#JWT请求流程" class="headerlink" title="JWT请求流程"></a>JWT请求流程</h3><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/jwt-1664598efc5e4112bfbb8da972e0f55b.png" srcset="/img/loading.gif" alt=""></p><h3 id="SpringBoot与JWT集成"><a href="#SpringBoot与JWT集成" class="headerlink" title="SpringBoot与JWT集成"></a>SpringBoot与JWT集成</h3><h5 id="先引入JWT的依赖"><a href="#先引入JWT的依赖" class="headerlink" title="先引入JWT的依赖"></a>先引入JWT的依赖</h5><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- jwt --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.auth0<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>java-jwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h5 id="自定义两个注解"><a href="#自定义两个注解" class="headerlink" title="自定义两个注解"></a>自定义两个注解</h5><h6 id="用来跳过验证的PassToken"><a href="#用来跳过验证的PassToken" class="headerlink" title="用来跳过验证的PassToken"></a>用来跳过验证的<em>PassToken</em></h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> PassToken &#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;&#125;</code></pre></div><h6 id="需要登录才能进行操作的Authorize"><a href="#需要登录才能进行操作的Authorize" class="headerlink" title="需要登录才能进行操作的Authorize"></a>需要登录才能进行操作的<em>Authorize</em></h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Authorize &#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">true</span></span>;&#125;</code></pre></div><p>这些注解的意思就不解释了φ(&gt;ω&lt;*) </p><h5 id="自定义一个Admin实体类，这里用了lombok插件简化了实体类的编写"><a href="#自定义一个Admin实体类，这里用了lombok插件简化了实体类的编写" class="headerlink" title="自定义一个Admin实体类，这里用了lombok插件简化了实体类的编写"></a>自定义一个Admin实体类，这里用了<strong>lombok</strong>插件简化了实体类的编写</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> : 2020/4/18 17:53</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> String Id;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> String password;&#125;</code></pre></div><h6 id="简要介绍一下这几个注解"><a href="#简要介绍一下这几个注解" class="headerlink" title="简要介绍一下这几个注解"></a>简要介绍一下这几个注解</h6><p><strong>@Data：</strong> 会为所有属性加入get和set方法，toString 方法，hashCode方法，equals方法<br><strong>@AllArgsConstructor：</strong> 为实体类加上含有所有属性的构造方法<br><strong>@NoArgsConstructor：</strong> 为实体类加上一个无参的构造方法</p><h5 id="写一个生成token的方法"><a href="#写一个生成token的方法" class="headerlink" title="写一个生成token的方法"></a>写一个生成token的方法</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span>  : 2020/4/15 17:46</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenUtil</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getToken</span> <span class="hljs-params">(User user)</span> </span>&#123;        String token = <span class="hljs-string">""</span>;        token = JWT.create().withAudience(user.getId())                .sign(Algorithm.HMAC256(user.getPassword()));        <span class="hljs-keyword">return</span> token;    &#125;&#125;</code></pre></div><p><strong>Algorithm.HMAC256：</strong> 使用HS256生成token,密钥则是用户的密码，唯一密钥的话可以保存在服务端。<br><strong>withAudience:</strong> 存入需要保存在token的信息，这里我把用户ID存入token中</p><h4 id="接下来需要写一个拦截器去获取token并验证token"><a href="#接下来需要写一个拦截器去获取token并验证token" class="headerlink" title="接下来需要写一个拦截器去获取token并验证token"></a>接下来需要写一个拦截器去获取<em>token<em>并验证</em>token</em></h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span>  : 2020/4/15 18:01</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> : Reprint please indicate the source</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 获取token并验证token</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthenticationInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    UserService userService;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String token = httpServletRequest.getHeader(<span class="hljs-string">"token"</span>);<span class="hljs-comment">// 从 http 请求头中取出 token</span>        <span class="hljs-comment">// 如果不是映射到方法直接通过</span>        <span class="hljs-keyword">if</span>(!(object <span class="hljs-keyword">instanceof</span> HandlerMethod))&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        HandlerMethod handlerMethod=(HandlerMethod)object;        Method method=handlerMethod.getMethod();        <span class="hljs-comment">//检查是否有passtoken注释，有则跳过认证</span>        <span class="hljs-keyword">if</span> (method.isAnnotationPresent(PassToken<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;            PassToken passToken = method.getAnnotation(PassToken<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            <span class="hljs-keyword">if</span> (passToken.required()) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-comment">//检查有没有需要用户权限的注解</span>        <span class="hljs-keyword">if</span> (method.isAnnotationPresent(UserLoginToken<span class="hljs-class">.<span class="hljs-keyword">class</span>)) </span>&#123;            UserLoginToken userLoginToken = method.getAnnotation(UserLoginToken<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            <span class="hljs-keyword">if</span> (userLoginToken.required()) &#123;                <span class="hljs-comment">// 执行认证</span>                <span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"无token，请重新登录"</span>);                &#125;                <span class="hljs-comment">// 获取 token 中的 user id</span>                String userId;                <span class="hljs-keyword">try</span> &#123;                    userId = JWT.decode(token).getAudience().get(<span class="hljs-number">0</span>);                &#125; <span class="hljs-keyword">catch</span> (JWTDecodeException j) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"401"</span>);                &#125;                User user = userService.findUserById(userId);                <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"用户不存在，请重新登录"</span>);                &#125;                <span class="hljs-comment">// 验证 token</span>                JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(user.getPassword())).build();                <span class="hljs-keyword">try</span> &#123;                    jwtVerifier.verify(token);                &#125; <span class="hljs-keyword">catch</span> (JWTVerificationException e) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"401"</span>);                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, </span></span><span class="hljs-function"><span class="hljs-params">                                  HttpServletResponse httpServletResponse, </span></span><span class="hljs-function"><span class="hljs-params">                            Object o, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest httpServletRequest, </span></span><span class="hljs-function"><span class="hljs-params">                                          HttpServletResponse httpServletResponse, </span></span><span class="hljs-function"><span class="hljs-params">                                          Object o, Exception e)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    &#125;</code></pre></div><h4 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程:"></a>主要流程:</h4><ol><li>从 http 请求头中取出 token，</li><li>判断是否映射到方法</li><li>检查是否有passtoken注释，有则跳过认证</li><li>检查有没有需要用户登录的注解，有则需要取出并验证</li><li>认证通过则可以访问，不通过会报相关错误信息<h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span>  : 2020/4/15 20:00</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterceptorConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(authenticationInterceptor())                .addPathPatterns(<span class="hljs-string">"/**"</span>);    <span class="hljs-comment">// 拦截所有请求，通过判断是否有 @Authorize 注解 决定是否需要登录</span>    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AuthorizationInterceptor <span class="hljs-title">authenticationInterceptor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AuthorizationInterceptor();    &#125;&#125;</code></pre></div><h4 id="在相应的Controller里面加入登录验证注解"><a href="#在相应的Controller里面加入登录验证注解" class="headerlink" title="在相应的Controller里面加入登录验证注解"></a>在相应的Controller里面加入登录验证注解</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span>  : 2020/4/15 13:31</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/api"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@Authorize</span>    <span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/getMessage"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"你已通过验证"</span>;    &#125;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">login</span> <span class="hljs-params">(@RequestBody User user)</span> </span>&#123;        JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject();        User userForBase = userService.findByUsername(user);        <span class="hljs-keyword">if</span> (userForBase == <span class="hljs-keyword">null</span>) &#123;            jsonObject.put(<span class="hljs-string">"message"</span>, <span class="hljs-string">"登录失败,用户不存在"</span>);            <span class="hljs-keyword">return</span> jsonObject;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (! userForBase.getPassword().equals(user.getPassword())) &#123;                jsonObject.put(<span class="hljs-string">"message"</span>, <span class="hljs-string">"登录失败,密码错误"</span>);                <span class="hljs-keyword">return</span> jsonObject;            &#125; <span class="hljs-keyword">else</span> &#123;                String token = tokenService.getToken(userForBase);                jsonObject.put(<span class="hljs-string">"token"</span>, token);                jsonObject.put(<span class="hljs-string">"user"</span>, userForBase);                <span class="hljs-keyword">return</span> jsonObject;            &#125;        &#125;    &#125;&#125;</code></pre></div><p>不加注解的话默认不验证，登录接口一般是不验证的。在getMessage()中我加上了登录注解，说明该接口必须登录获取token后，在请求头中加上token并通过验证才可以访问</p><h5 id="下面进行测试，启动项目，使用postman测试接口"><a href="#下面进行测试，启动项目，使用postman测试接口" class="headerlink" title="下面进行测试，启动项目，使用postman测试接口"></a>下面进行测试，启动项目，使用postman测试接口</h5><h6 id="在没token的情况下访问api-getMessage接口"><a href="#在没token的情况下访问api-getMessage接口" class="headerlink" title="在没token的情况下访问api/getMessage接口"></a>在没token的情况下访问<strong>api/getMessage</strong>接口</h6><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/4630295-7d3360188b09055e-054105f739a84d11b4eb81f4481e0b9e.png" srcset="/img/loading.gif" alt=""></p><h6 id="下面进行登录，从而获取token"><a href="#下面进行登录，从而获取token" class="headerlink" title="下面进行登录，从而获取token"></a>下面进行登录，从而获取token</h6><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/4630295-64ee2d44d11a68c4-2e96c4ee88594579b7a8795a5ae9e0cc.png" srcset="/img/loading.gif" alt=""></p><h6 id="把token加在请求头中，再次访问api-getMessage接口"><a href="#把token加在请求头中，再次访问api-getMessage接口" class="headerlink" title="把token加在请求头中，再次访问api/getMessage接口"></a>把token加在请求头中，再次访问<strong>api/getMessage</strong>接口</h6><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/4630295-963e2d5356fc5664-d829a4f11f70451c97b0335d39bb479a.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给博客添加一个音乐播放器</title>
    <link href="/2020/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2020/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/Inked20200222210629_LI-43e4ff17d85b4cb9a83616b527d4c36d.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/Inked20200222210656_LI-62c5ca392aa543d2b33fa7800f4798bd.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在你想要添加的地方加入以下代码即可</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"aplayer"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"aplayer"</span>  <span class="hljs-attr">data-id</span>=<span class="hljs-string">"4877773231"</span> <span class="hljs-attr">data-server</span>=<span class="hljs-string">"netease"</span> <span class="hljs-attr">data-type</span>=<span class="hljs-string">"playlist"</span> <span class="hljs-attr">data-fixed</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">data-listfolded</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">data-order</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">data-theme</span>=<span class="hljs-string">"#F58EA8"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 100%"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/meting@1.2/dist/Meting.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>保存之后就可以在相应的地方看到音乐播放器了, 看博客的时候来点音乐助助兴d(´ω｀*)</p><h3 id="歌单获取"><a href="#歌单获取" class="headerlink" title="歌单获取"></a>歌单获取</h3><p>只需将data-id换成你想要的id即可<br>以网易云音乐为例<br>选择一个自己喜欢的歌单，可以看到有生成外链播放器</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/Inked20200222211959_LI-d38c43b0074d48ec848ac0826d1f5532.jpg" srcset="/img/loading.gif" alt=""></p><p>点进去之后就可以看到歌单的id了，用这个id修改data-id就可以了<br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/Inked20200222212058_LI-34263f1411a9424a9c0202bb20ff37c8.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>博客美化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客美化</tag>
      
      <tag>看板娘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给博客添加一个萌萌哒的看板娘φ(&gt;ω&lt;*)</title>
    <link href="/2020/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%90%8C%E8%90%8C%E5%93%92%E7%9A%84%E7%9C%8B%E6%9D%BF%E5%A8%98%CF%86(%CF%89)/"/>
    <url>/2020/02/23/%E7%BB%99%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%90%8C%E8%90%8C%E5%93%92%E7%9A%84%E7%9C%8B%E6%9D%BF%E5%A8%98%CF%86(%CF%89)/</url>
    
    <content type="html"><![CDATA[<p>继上一篇给博客添加音乐播放器之后，觉得还不够的话，还可以再往你的博客里加入一个看板娘哦ヽ(￣▽￣)ﾉ</p><h4 id="效果是这样滴"><a href="#效果是这样滴" class="headerlink" title="效果是这样滴"></a>效果是这样滴</h4><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/Inked20200223132017_LI-b0b372d6ef584a3b8cc4ed8b03b50795.jpg" srcset="/img/loading.gif" alt=""></p><p>这个插件需要<strong>Font Awesome</strong>支持，所以先确保你的页面已加载此样式表，<br>例如在<strong>head</strong>标签内加入</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"</span>&gt;</span></code></pre></div><p>不加入这个的话，无法正常显示。如果已经加载了<strong>Font Awesome</strong>，就不要重复加载了</p><p>将下面这一行代码加入<strong>head</strong>或<strong>body</strong>，你就可以看到一个么么哒的看板娘了</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>博客美化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客美化</tag>
      
      <tag>看板娘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初次体验ASP.NET</title>
    <link href="/2020/02/18/%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8CASP.NET/"/>
    <url>/2020/02/18/%E5%88%9D%E6%AC%A1%E4%BD%93%E9%AA%8CASP.NET/</url>
    
    <content type="html"><![CDATA[<p>开学了，虽然不能回学校，但是还是逃不掉要上课的命运，这学期培养方案里面有要求<strong>ASP.NET</strong>，既然课程培养方案里面有<strong>ASP.NET</strong>，那也没办法了，只好硬着头皮学了(Ｔ▽Ｔ)。</p><p>昨天刚接触<strong>ASP.NET</strong>，感觉这东西，哎，不是那么喜欢它的语法。</p><p>而且学了那么久的SSM框架和SpringBoot都用不上了，伤心(╥╯^╰╥)，后来为了简化开发，又去学了Vue，前几天刚差不多看完。<br>想着既然SSM和SpringBoot用不上了，那Vue总用的上吧，毕竟<strong>ASP.NET</strong>是后端的嘛，一个前端框架总不能不能用吧。PS(其实是不太想用jQury操作dom元素）(｡&gt;∀&lt;｡)</p><p>查了一些关于怎么在<strong>ASP.NET</strong>中使用Vue的资料，例子等等。通过一些文档教程，自己也写了一个demo，模拟登录功能</p><h3 id="1-先安装Vue和axios"><a href="#1-先安装Vue和axios" class="headerlink" title="1.先安装Vue和axios"></a>1.先安装Vue和axios</h3><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200218204920-04ede06b5fc64237986629057b84203e.png" srcset="/img/loading.gif" alt=""><br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200218205108-d958356e9ca54d89ae6e356c7f9166d4.png" srcset="/img/loading.gif" alt=""><br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200218205617-6fcf8c4612074e2db507f2a76464a216.png" srcset="/img/loading.gif" alt=""><br>安装即可</p><h3 id="2-在Models文件夹下新建User类和returnJson类"><a href="#2-在Models文件夹下新建User类和returnJson类" class="headerlink" title="2.在Models文件夹下新建User类和returnJson类"></a>2.在Models文件夹下新建User类和returnJson类</h3><h3 id="User用于模拟数据库表User映射对象"><a href="#User用于模拟数据库表User映射对象" class="headerlink" title="User用于模拟数据库表User映射对象"></a>User用于模拟数据库表User映射对象</h3><div class="hljs"><pre><code class="hljs C#">using System;using System.Collections.Generic;using System.Linq;using System.Web;namespace WebApplication1.Models&#123;    public class User    &#123;        public string username &#123; get; set; &#125;        public string password &#123; get; set; &#125;    &#125;&#125;</code></pre></div><h3 id="returnJson用于返回封装JSON数据的对象"><a href="#returnJson用于返回封装JSON数据的对象" class="headerlink" title="returnJson用于返回封装JSON数据的对象"></a>returnJson用于返回封装JSON数据的对象</h3><div class="hljs"><pre><code class="hljs C#">using System;using System.Collections.Generic;using System.Linq;using System.Web;namespace WebApplication1.Models&#123;    public class returnJson    &#123;        public Object data &#123; get; set; &#125;        public int status &#123; get; set; &#125;    &#125;&#125;</code></pre></div><h3 id="3-在Controller文件夹下新建一个控制器LoginController"><a href="#3-在Controller文件夹下新建一个控制器LoginController" class="headerlink" title="3.在Controller文件夹下新建一个控制器LoginController"></a>3.在Controller文件夹下新建一个控制器LoginController</h3><div class="hljs"><pre><code class="hljs C#">using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.Mvc;using WebApplication1.Models;namespace WebApplication1.Controllers&#123;    public class LoginController : Controller    &#123;        &#x2F;&#x2F; GET: Login        public ActionResult Login()        &#123;            return View();        &#125;        [HttpGet]        public JsonResult checkLogin(User user)        &#123;            returnJson json &#x3D; new returnJson();            &#x2F;&#x2F;模拟账号密码            if (&quot;admin&quot;.Equals(user.username) &amp;&amp; &quot;123456&quot;.Equals(user.password))            &#123;                User u &#x3D; new User();                u.username &#x3D; &quot;admin&quot;;                u.password &#x3D; &quot;123456&quot;;                json.data &#x3D; u;                json.status &#x3D; 200;                return Json(json, JsonRequestBehavior.AllowGet);            &#125;             else            &#123;                json.data &#x3D; null;                json.status &#x3D; 400;                return Json(json, JsonRequestBehavior.AllowGet);            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="4-在Login-cshtml中加入以下代码"><a href="#4-在Login-cshtml中加入以下代码" class="headerlink" title="4.在Login.cshtml中加入以下代码"></a>4.在Login.cshtml中加入以下代码</h3><p>我这用的是element-ui，没有用自带的bootstrap，样式就不贴出来了</p><div class="hljs"><pre><code class="hljs html">@&#123;    ViewBag.Title = "登录";    //清除模板页    Layout = null;&#125;<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"Content-Type"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"text/html; charset=utf-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>@ViewBag.Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    @Styles.Render("~/Content/style.css")    @Styles.Render("~/Content/ElementUI/element-ui.css")    @Scripts.Render("~/Scripts/axios.js")    @Scripts.Render("~/Scripts/vue.min.js")    @Scripts.Render("~/Scripts/ElementUI/element-ui.js")    @Scripts.Render("~/bundles/modernizr")<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"login-form"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"login-icon"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://www.lwjppz.cn/avatar"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">el-form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"login-input"</span> <span class="hljs-attr">:model</span>=<span class="hljs-string">"loginForm"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"loginForm.username"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"用户名"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"el-icon-user"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">el-form-item</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">el-input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"loginForm.password"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"密码"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"prefix"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"el-icon-lock"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">el-form-item</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">el-row</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"login-btn"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"primary"</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"login"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">el-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"info"</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">el-button</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">el-row</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">el-form</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">    <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">    el: <span class="hljs-string">'#app'</span>,</span>    data: &#123;        loginForm: &#123;<span class="actionscript">            username: <span class="hljs-string">'admin'</span>,</span><span class="actionscript">            password: <span class="hljs-string">'123456'</span></span>        &#125;    &#125;,    methods: &#123;        login() &#123;<span class="actionscript">            axios.get(<span class="hljs-string">'Login/checkLogin'</span>, &#123;</span>                params: &#123;<span class="actionscript">                    username: <span class="hljs-keyword">this</span>.loginForm.username,</span><span class="actionscript">                    password: <span class="hljs-keyword">this</span>.loginForm.password</span>                &#125;<span class="javascript">            &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span>                if (res.data.status === 200) &#123;<span class="actionscript">                    <span class="hljs-keyword">this</span>.$message.success(<span class="hljs-string">'登录成功！'</span>)</span><span class="actionscript">                &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="actionscript">                    <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'登录失败！'</span>)</span>                &#125;<span class="javascript">            &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;</span><span class="actionscript">               <span class="hljs-keyword">this</span>.$message.error(<span class="hljs-string">'登录失败！'</span>)</span><span class="javascript">               <span class="hljs-built_in">console</span>.log(err)</span>            &#125;)        &#125;    &#125;&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h3 id="5-修改RouteConfig默认配置"><a href="#5-修改RouteConfig默认配置" class="headerlink" title="5.修改RouteConfig默认配置"></a>5.修改RouteConfig默认配置</h3><div class="hljs"><pre><code class="hljs C#">using System;using System.Collections.Generic;using System.Linq;using System.Web;using System.Web.Mvc;using System.Web.Routing;namespace WebApplication1&#123;    public class RouteConfig    &#123;        public static void RegisterRoutes(RouteCollection routes)        &#123;            routes.IgnoreRoute(&quot;&#123;resource&#125;.axd&#x2F;&#123;*pathInfo&#125;&quot;);            routes.MapRoute(                name: &quot;Default&quot;,                url: &quot;&#123;controller&#125;&#x2F;&#123;action&#125;&#x2F;&#123;id&#125;&quot;,&#x2F;&#x2F;改为跳转到登录页面                defaults: new &#123; controller &#x3D; &quot;Login&quot;, action &#x3D; &quot;Login&quot;, id &#x3D; UrlParameter.Optional &#125;            );        &#125;    &#125;&#125;</code></pre></div><h4 id="按ctrl-F5启动"><a href="#按ctrl-F5启动" class="headerlink" title="按ctrl+F5启动"></a>按ctrl+F5启动</h4><h6 id="最终结果如下"><a href="#最终结果如下" class="headerlink" title="最终结果如下"></a>最终结果如下</h6><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200218205803-cd6b98aaf0c74df380825475fc2ba2f1.png" srcset="/img/loading.gif" alt=""></p><h5 id="登录成功"><a href="#登录成功" class="headerlink" title="登录成功"></a>登录成功</h5><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200218210241-220062f636b442dfaea383148b9141da.png" srcset="/img/loading.gif" alt=""></p><h5 id="登录失败"><a href="#登录失败" class="headerlink" title="登录失败"></a>登录失败</h5><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200218210257-08346114c7be492e9fbf12e59d07a996.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>ASP.NET</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>ASP.NET</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot解决跨域问题</title>
    <link href="/2020/02/16/SpringBoot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2020/02/16/SpringBoot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>我们在进行前后端分离开发中，必不可少的会遇到跨域问题，然而什么是跨域呢？跨域是怎么产生的呢？要怎么解决？</p><h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h3><p>跨域是指从一个域名去请求另一个域名的资源，严格来说，只要域名，协议，端口任何一个不同，就视为跨域。</p><table><thead><tr><th>当前页面url</th><th>被请求页面url</th><th>是否跨域</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a></td><td><a href="http://www.xxx.com/xxxx.html" target="_blank" rel="noopener">http://www.xxx.com/xxxx.html</a></td><td>否</td><td>同源（协议、域名、端口号相同）</td></tr><tr><td><a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a></td><td><a href="https://www.xxx.com" target="_blank" rel="noopener">https://www.xxx.com</a></td><td>是</td><td>协议不同（http/https）</td></tr><tr><td><a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a></td><td><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></td><td>是</td><td>主域名不同（xxx/baidu）</td></tr><tr><td><a href="http://www.xxx.com" target="_blank" rel="noopener">http://www.xxx.com</a></td><td><a href="http://blog.xxx.com" target="_blank" rel="noopener">http://blog.xxx.com</a></td><td>是</td><td>子域名不同（www/blog）</td></tr><tr><td><a href="http://www.xxx.com:8181" target="_blank" rel="noopener">http://www.xxx.com:8181</a></td><td><a href="http://www.xxx.com:8080" target="_blank" rel="noopener">http://www.xxx.com:8080</a></td><td>是</td><td>端口号不同（8080/8181）</td></tr></tbody></table><h3 id="为什么会出现跨域？"><a href="#为什么会出现跨域？" class="headerlink" title="为什么会出现跨域？"></a>为什么会出现跨域？</h3><p>出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）</p><h3 id="怎么解决？"><a href="#怎么解决？" class="headerlink" title="怎么解决？"></a>怎么解决？</h3><p>当前运行后端spring boot应用，请求测试数据正常</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.demo.demo.controller;<span class="hljs-keyword">import</span> cn.demo.demo.entities.Score;<span class="hljs-keyword">import</span> cn.demo.demo.service.ScoreService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/2/16 16:00</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/score"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demoController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ScoreService scoreService;    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/findAll"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Score&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> scoreService.findAll();    &#125;&#125;</code></pre></div><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/202002161-d4534db14831472780f113993e0f46a5.PNG" srcset="/img/loading.gif" alt=""></p><p>而运行前端Vue应用跨域发送请求后端的数据时，浏览器会报错</p><div class="hljs"><pre><code class="hljs html">request(&#123;  url: 'http://localhost:8181/score/findAll',  method: 'get'&#125;).then(res =&gt; &#123;  console.log(res);&#125;).catch(err =&gt; &#123;  console.log(err);&#125;)</code></pre></div><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/202002162-9cd03fb02e714e57be90683a32ba7dff.PNG" srcset="/img/loading.gif" alt=""></p><p>由于端口号不一致，导致跨域的产生</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li><p>加上 <strong>@CrossOrigin</strong> 注解</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.demo.demo.entities.Score;<span class="hljs-keyword">import</span> cn.demo.demo.service.ScoreService;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/2/16 16:00</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Controller</span><span class="hljs-meta">@CrossOrigin</span><span class="hljs-meta">@RequestMapping</span>(path = <span class="hljs-string">"/score"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demoController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ScoreService scoreService;    <span class="hljs-meta">@GetMapping</span>(value = <span class="hljs-string">"/findAll"</span>)    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Score&gt; <span class="hljs-title">findAll</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> scoreService.findAll();    &#125;&#125;</code></pre></div><p>这时就可以正常请求到后端的数据了<br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/202002163-98a424d30f0d4923a66e263fa1828dcd.PNG" srcset="/img/loading.gif" alt=""></p></li><li><p>新建一个配置类</p></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.demo.demo.config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/2/16 16:30</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfiguration</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title">corsConfigurer</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebMvcConfigurer() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;                registry.addMapping(<span class="hljs-string">"/**"</span>)                        .allowCredentials(<span class="hljs-keyword">false</span>)                        .allowedMethods(<span class="hljs-string">"GET"</span>, <span class="hljs-string">"POST"</span>, <span class="hljs-string">"PUT"</span>, <span class="hljs-string">"DELETE"</span>, <span class="hljs-string">"OPTIONS"</span>)                        .allowedOrigins(<span class="hljs-string">"*"</span>);            &#125;        &#125;;    &#125;&#125;</code></pre></div><p>以上两种方法都可以解决跨域问题</p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合Vue</title>
    <link href="/2020/02/09/SpringBoot%E6%95%B4%E5%90%88Vue/"/>
    <url>/2020/02/09/SpringBoot%E6%95%B4%E5%90%88Vue/</url>
    
    <content type="html"><![CDATA[<h3 id="前端源代码"><a href="#前端源代码" class="headerlink" title="前端源代码"></a>前端源代码</h3><ol><li>新建一个vue项目（百度很多，自行搜索下），项目目录结构如下：</li></ol><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190714130749988.PNG" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>其中，默认生成的index.html和main.js不做改变，即如下：<h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width,initial-scale=1.0"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>myvue<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span>    <span class="hljs-comment">&lt;!-- &lt;script type="/dist/" --&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><div class="hljs"><pre><code class="hljs JavaScript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span>Vue.config.productionTip=<span class="hljs-literal">false</span><span class="hljs-keyword">new</span> Vue(&#123;  el:<span class="hljs-string">"#app"</span>,  router,  components:&#123; App &#125;,  template:<span class="hljs-string">'&lt;App/&gt;'</span>&#125;)</code></pre></div><h5 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h5><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./assets/logo.png"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">import</span> HelloWorld <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/HelloWorld'</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="actionscript">  name: <span class="hljs-string">'App'</span></span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-id">#app</span> &#123;</span>  font-family: 'Avenir', Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;<span class="css">  <span class="hljs-selector-tag">color</span>: <span class="hljs-selector-id">#2c3e50</span>;</span>  margin-top: 60px;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div></li><li>修改index.js，引入各路由组件；<div class="hljs"><pre><code class="hljs html">import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld'import aaa from '@/components/aaa'import loginUI from '@/components/loginUI'import success from '@/components/success'import axios from 'axios'Vue.prototype.$http = axiosVue.use(Router) export default new Router(&#123;  routes: [    &#123;      path: '/',      name: 'HelloWorld',      component: HelloWorld    &#125;,    &#123;    path: '/abc',      name: 'aaa',      component: aaa    &#125;,    &#123;    path: '/loginUI',      name: 'loginUI',      component: loginUI    &#125;,    &#123;    path: '/success',      name: 'success',      component: success    &#125;  ]&#125;)</code></pre></div></li><li>在components添加四个vue文件，如下<br><img src="D:%5Cblog%5CHexo%5Cmy-hexo-blog%5Cimgs%5C20190714130801167.PNG" srcset="/img/loading.gif" alt=""></li></ol><p>HelloWorld.vue，主要是主页面，其中“点我跳转”是自己用来尝试，vue路由组件的跳转过程的，“点我登录”跳转至登录页面；</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"hello"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"go"</span>&gt;</span>点我跳转<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"loginUI"</span>&gt;</span>点我登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><span class="actionscript">  name: <span class="hljs-string">'HelloWorld'</span>,</span>  data () &#123;<span class="actionscript">    <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">      msg: <span class="hljs-string">'哈哈'</span></span>    &#125;  &#125;,  methods:&#123;  go()&#123;<span class="javascript">      <span class="hljs-built_in">console</span>.log(<span class="hljs-number">66</span>)</span><span class="actionscript">      <span class="hljs-keyword">this</span>.$router.push(&#123;</span><span class="actionscript">        path:<span class="hljs-string">'/abc'</span></span>      &#125;)    &#125;,    loginUI()&#123;<span class="actionscript">      <span class="hljs-keyword">this</span>.$router.push(&#123;</span><span class="actionscript">        path:<span class="hljs-string">'/loginUI'</span></span>      &#125;)    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h5 id="aaa-vue"><a href="#aaa-vue" class="headerlink" title="aaa.vue"></a>aaa.vue</h5><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>我是aaa<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"back"</span>&gt;</span>点我返回<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  methods:&#123;  back()&#123;<span class="actionscript">  <span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">'/'</span>)</span>  &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><h5 id="login-vue（登录页面，点击登录通过axios请求后台接口）"><a href="#login-vue（登录页面，点击登录通过axios请求后台接口）" class="headerlink" title="login.vue（登录页面，点击登录通过axios请求后台接口）"></a>login.vue（登录页面，点击登录通过axios请求后台接口）</h5><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loginUI"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"username"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"login"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-keyword">import</span> qs <span class="hljs-keyword">from</span> <span class="hljs-string">'qs'</span></span><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span>  data()&#123;<span class="actionscript">    <span class="hljs-keyword">return</span> &#123;</span><span class="actionscript">      username:<span class="hljs-string">""</span>,</span><span class="actionscript">      password:<span class="hljs-string">""</span></span>    &#125;  &#125;,  methods:&#123;    login()&#123;<span class="actionscript">      <span class="hljs-keyword">var</span> that=<span class="hljs-keyword">this</span>;</span><span class="javascript">      <span class="hljs-built_in">console</span>.log(that.username+<span class="hljs-string">":"</span>+that.password)  </span><span class="actionscript">      <span class="hljs-keyword">var</span> user=&#123;</span>        username:that.username,        password:that.password      &#125; <span class="actionscript">      <span class="hljs-keyword">this</span>.$http.post(<span class="hljs-string">'http://localhost:8080/user/login'</span>,qs.stringify(user))</span><span class="actionscript">      .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(params)</span> </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(params)</span>        if(params.data.status===200)&#123;          that.$router.push(&#123;<span class="actionscript">          path:<span class="hljs-string">'/success'</span></span>        &#125;)        &#125;      &#125;)<span class="actionscript">      .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(reason)</span> </span>&#123;</span><span class="javascript">        <span class="hljs-built_in">console</span>.log(reason)</span>      &#125;)    &#125;  &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-id">#loginUI</span> &#123;</span><span class="css">  <span class="hljs-selector-tag">margin</span><span class="hljs-selector-pseudo">:0</span> <span class="hljs-selector-tag">auto</span>;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre></div><h5 id="success-vue，登录成功页面"><a href="#success-vue，登录成功页面" class="headerlink" title="success.vue，登录成功页面"></a>success.vue，登录成功页面</h5><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    成功！    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"/"</span>&gt;</span>返回<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div><p>okay，前端源代码部分完成；<br>前端代码调用过程如下:<br><img src="https://img-blog.csdnimg.cn/20190714151550292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hwc3ljaGU=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""></p><h3 id="后台源代码"><a href="#后台源代码" class="headerlink" title="后台源代码"></a>后台源代码</h3><p>后台用SpringBoot完成，</p><h5 id="UserController"><a href="#UserController" class="headerlink" title="UserController"></a>UserController</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/login"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ReturnMsgVo <span class="hljs-title">login</span><span class="hljs-params">(User user)</span></span>&#123;        System.out.println(user);        <span class="hljs-keyword">return</span> ReturnMsgVo.success(<span class="hljs-keyword">null</span>);    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello"</span>;    &#125;&#125;</code></pre></div><h4 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h4><p>先启动后台（端口8080），再启动前端：npm run dev（其发现8080被占用后，自动启用8081端口）。</p><p><img src="https://img-blog.csdnimg.cn/20190714130812517.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hwc3ljaGU=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""></p><p>首页如下，点击登录<br><img src="https://img-blog.csdnimg.cn/20190714130820793.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hwc3ljaGU=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt=""></p><p>提交后报错403，</p><div class="hljs"><pre><code class="hljs java">Response to preflight request doesn<span class="hljs-string">'t pass access control check: No '</span>Access-Control-Allow-Origin<span class="hljs-string">' header is present on the requested resource. Origin '</span>http:<span class="hljs-comment">//localhost:8080' is therefore not allowed access. The response had HTTP status code 403</span></code></pre></div><p>搜索了以下，从这篇博客找到答案<a href="https://blog.csdn.net/Brave_Coder/article/details/77103899#" target="_blank" rel="noopener">https://blog.csdn.net/Brave_Coder/article/details/77103899#</a></p><p>常规的GET，POST，PUT，DELETE请求是简单请求（相对于OPTIONS请求），但是OPTIONS有点儿特别，它要先发送请求问问服务器，你要不要我请求呀，要我就要发送数据过来咯（这完全是根据自己的理解写的，如果有误，敬请谅解，请参考阮一峰大神原文。）<br>在Vue的项目里，Http服务采用Axios，而它正是采用OPTIONS请求。<br>如果仅仅在header里面加入： ‘Access-Control-Allow-Origin’：*，是并不能解决问题的，错误就是如文章开头所示。<br>就需要我们在后台对OPTIONS请求额外处理</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>故我添加了一个拦截器</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProcessInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        httpServletResponse.setHeader(<span class="hljs-string">"Access-Control-Allow-Origin"</span>, <span class="hljs-string">"*"</span>);        httpServletResponse.setHeader(<span class="hljs-string">"Access-Control-Allow-Headers"</span>, <span class="hljs-string">"Content-Type,Content-Length, Authorization, Accept,X-Requested-With"</span>);        httpServletResponse.setHeader(<span class="hljs-string">"Access-Control-Allow-Methods"</span>,<span class="hljs-string">"PUT,POST,GET,DELETE,OPTIONS"</span>);        httpServletResponse.setHeader(<span class="hljs-string">"X-Powered-By"</span>,<span class="hljs-string">"Jetty"</span>);        String method= httpServletRequest.getMethod();        <span class="hljs-keyword">if</span> (method.equals(<span class="hljs-string">"OPTIONS"</span>))&#123;            httpServletResponse.setStatus(<span class="hljs-number">200</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    &#125;&#125;</code></pre></div><p>同时在Spring中声明</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        registry.addInterceptor(<span class="hljs-keyword">new</span> ProcessInterceptor()).addPathPatterns(<span class="hljs-string">"/**"</span>);    &#125;&#125;</code></pre></div><p>再次访问，成功！<br><img src="https://img-blog.csdnimg.cn/20190714130828575.PNG" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floyd-傻子也能看懂的弗洛伊德算法</title>
    <link href="/2020/02/07/Floyd-%E5%82%BB%E5%AD%90%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95/"/>
    <url>/2020/02/07/Floyd-%E5%82%BB%E5%AD%90%E4%B9%9F%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/1033450-20180623095231726-676002076-24a0040ebebb48298cfb8219fcbdb43d-thumbnail_1581216235927.png" srcset="/img/loading.gif" alt=""></p><p>暑假，小哼准备去一些城市旅游。有些城市之间有公路，有些城市之间则没有，如下图。为了节省经费以及方便计划旅程，小哼希望在出发之前知道任意两个城市之前的最短路程。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/1033450-20180623095244077-353646184-77b204a41e834c43abbaa3b471757a37-thumbnail_1581216236036.png" srcset="/img/loading.gif" alt=""></p><p>上图中有4个城市8条公路，公路上的数字表示这条公路的长短。请注意这些公路是单向的。我们现在需要求任意两个城市之间的最短路程，也就是求任意两个点之间的最短路径。这个问题这也被称为“多源最短路径”问题。</p><p>   现在需要一个数据结构来存储图的信息，我们仍然可以用一个4*4的矩阵（二维数组e）来存储。比如1号城市到2号城市的路程为2，则设e[1][2]的值为2。2号城市无法到达4号城市，则设置e[2][4]的值为∞。另外此处约定一个城市自己是到自己的也是0，例如e[1][1]为0，具体如下。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/1033450-20180623095252434-1650383278-c027f8242ea24e11ba00b93eda9b754b-thumbnail_1581216236052.png" srcset="/img/loading.gif" alt=""></p><p>现在回到问题：如何求任意两点之间最短路径呢？通过之前的学习我们知道通过深度或广度优先搜索可以求出两点之间的最短路径。所以进行n2遍深度或广度优先搜索，即对每两个点都进行一次深度或广度优先搜索，便可以求得任意两点之间的最短路径。可是还有没有别的方法呢？</p><p>我们来想一想，根据我们以往的经验，如果要让任意两点（例如从顶点a点到顶点b）之间的路程变短，只能引入第三个点（顶点k），并通过这个顶点k中转即a-&gt;k-&gt;b，才可能缩短原来从顶点a点到顶点b的路程。那么这个中转的顶点k是1~n中的哪个点呢？甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即a-&gt;k1-&gt;k2b-&gt;或者a-&gt;k1-&gt;k2…-&gt;k-&gt;i…-&gt;b。比如上图中从4号城市到3号城市（4-&gt;3）的路程e[4][3]原本是12。如果只通过1号城市中转（4-&gt;1-&gt;3），路程将缩短为11（e[4][1]+e[1][3]=5+6=11）。其实1号城市到3号城市也可以通过2号城市中转，使得1号到3号城市的路程缩短为5（e[1][2]+e[2][3]=2+3=5）。所以如果同时经过1号和2号两个城市中转的话，从4号城市到3号城市的路程会进一步缩短为10。通过这个的例子，我们发现每个顶点都有可能使得另外两个顶点之间的路程变短。好，下面我们将这个问题一般化。</p><p>当任意两点之间不允许经过第三个点时，这些城市之间最短路程就是初始路程，如下。<br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/1033450-20180623095252434-1650383278-c027f8242ea24e11ba00b93eda9b754b-thumbnail_1581216236052.png" srcset="/img/loading.gif" alt=""></p><p>假如现在只允许经过1号顶点，求任意两点之间的最短路程，应该如何求呢？只需判断e[i][1]+e[1][j]是否比e[i][j]要小即可。e[i][j]表示的是从i号顶点到j号顶点之间的路程。e[i][1]+e[1][j]表示的是从i号顶点先到1号顶点，再从1号顶点到j号顶点的路程之和。其中i是1 ~ n循环，j也是1 ~ n循环，代码实现如下。</p><div class="hljs"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;        e[i][j] = <span class="hljs-built_in">min</span>(e[i][j], e[i][<span class="hljs-number">1</span>] + e[<span class="hljs-number">1</span>][j]);    &#125;&#125;</code></pre></div><p>在只允许经过1号顶点的情况下，任意两点之间的最短路程更新为：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-7743b0b537274a0c85c959f71beb0ce0-thumbnail_1581216243224.png" srcset="/img/loading.gif" alt=""></p><p>通过上图我们发现：在只通过1号顶点中转的情况下，3号顶点到2号顶点（e[3][2]）、4号顶点到2号顶点（e[4][2]）以及4号顶点到3号顶点（e[4][3]）的路程都变短了。</p><p>接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短路程。如何做呢？我们需要在只允许经过1号顶点时任意两点的最短路程的结果下，再判断如果经过2号顶点是否可以使得i号顶点到j号顶点之间的路程变得更短。即判断e[i][2]+e[2][j]是否比e[i][j]要小，代码实现为如下。</p><div class="hljs"><pre><code class="hljs C"><span class="hljs-comment">//经过1号顶点</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;        e[i][j] = <span class="hljs-built_in">min</span>(e[i][j], e[i][<span class="hljs-number">1</span>] + e[<span class="hljs-number">1</span>][j]);    &#125;&#125;<span class="hljs-comment">//经过2号顶点</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;        e[i][j] = <span class="hljs-built_in">min</span>(e[i][j], e[i][<span class="hljs-number">2</span>] + e[<span class="hljs-number">2</span>][j]);    &#125;&#125;</code></pre></div><p>在只允许经过1和2号顶点的情况下，任意两点之间的最短路程更新为：<br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-55081bb844ae401bbbb479aa8e907dfe-thumbnail_1581216245536.png" srcset="/img/loading.gif" alt=""></p><p>通过上图得知，在相比只允许通过1号顶点进行中转的情况下，这里允许通过1和2号顶点进行中转，使得e[1][3]和e[4][3]的路程变得更短了。</p><p>同理，继续在只允许经过1、2和3号顶点进行中转的情况下，求任意两点之间的最短路程。任意两点之间的最短路程更新为：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-d9ebfe8345044e298e976c67bf78814a-thumbnail_1581216247880.png" srcset="/img/loading.gif" alt=""></p><p> 最后允许通过所有顶点作为中转，任意两点之间最终的最短路程为：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-2a694df3fbc74f989a45ca27f9d4df1a-thumbnail_1581216243192.png" srcset="/img/loading.gif" alt=""></p><p> 整个算法过程虽然说起来很麻烦，但是代码实现却非常简单，核心代码只有七行：</p><div class="hljs"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;            e[i][j] = <span class="hljs-built_in">min</span>(e[i][j], e[i][k] + e[k][j]);        &#125;    &#125;&#125;</code></pre></div><p>这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。</p><p>另外需要注意的是：Floyd-Warshall算法不能解决带有“负权回路”（或者叫“负权环”）的图，因为带有“负权回路”的图没有最短路。例如下面这个图就不存在1号顶点到3号顶点的最短路径。因为1-&gt;2-&gt;3-&gt;1-&gt;2-&gt;3-&gt;…-&gt;1-&gt;2-&gt;3这样路径中，每绕一次1-&gt;-2&gt;3这样的环，最短路就会减少1，永远找不到最短路。其实如果一个图中带有“负权回路”那么这个图则没有最短路。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-8848b1f91d704622907dd83df0b9c409-thumbnail_1581216245520.png" srcset="/img/loading.gif" alt=""></p><p>转载自：<a href="https://www.cnblogs.com/wangyuliang/p/9216365.html" target="_blank" rel="noopener">Floyd-傻子也能看懂的弗洛伊德算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-第 173 场周赛</title>
    <link href="/2020/01/26/LeetCode-%E7%AC%AC-173-%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
    <url>/2020/01/26/LeetCode-%E7%AC%AC-173-%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-删除回文子序列"><a href="#1-删除回文子序列" class="headerlink" title="1.删除回文子序列"></a>1.删除回文子序列</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个字符串 s，它仅由字母 ‘a’ 和 ‘b’ 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。</p><p>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</p><p>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</p><p>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。</p><h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5><div class="hljs"><pre><code class="hljs text">输入：s &#x3D; &quot;ababa&quot;输出：1解释：字符串本身就是回文序列，只需要删除一次。</code></pre></div><h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5><div class="hljs"><pre><code class="hljs text">输入：s &#x3D; &quot;abb&quot;输出：2解释：&quot;abb&quot; -&gt; &quot;bb&quot; -&gt; &quot;&quot;. 先删除回文子序列 &quot;a&quot;，然后再删除 &quot;bb&quot;。</code></pre></div><h5 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h5><div class="hljs"><pre><code class="hljs text">输入：s &#x3D; &quot;baabb&quot;输出：2解释：&quot;baabb&quot; -&gt; &quot;b&quot; -&gt; &quot;&quot;. 先删除回文子序列 &quot;baab&quot;，然后再删除 &quot;b&quot;。</code></pre></div><h5 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h5><div class="hljs"><pre><code class="hljs text">输入：s &#x3D; &quot;&quot;输出：0</code></pre></div><p>提示：</p><blockquote><p>0 &lt;= s.length &lt;= 1000<br>s 仅包含字母 ‘a’  和 ‘b’</p></blockquote><h3 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h3><p>如果是回文串，则一次即可删除，如果不是回文串，那么把所有a或者所有b删除后，剩下的一定是回文的，即再删除一次即可。<br>所以，答案区间[0-2]。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">removePalindromeSub</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;            <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(s.length() - i - <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;&#125;</code></pre></div><p>题目链接：<a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-palindromic-subsequences/</a></p><hr><h2 id="2-餐厅过滤器"><a href="#2-餐厅过滤器" class="headerlink" title="2.餐厅过滤器"></a>2.餐厅过滤器</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个餐馆信息数组 restaurants，其中  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]。你必须使用以下三个过滤器来过滤这些餐馆信息。</p><p>其中素食者友好过滤器 veganFriendly 的值可以为 true 或者 false，如果为 true 就意味着你应该只包括 veganFriendlyi 为 true 的餐馆，为 false 则意味着可以包括任何餐馆。此外，我们还有最大价格 maxPrice 和最大距离 maxDistance 两个过滤器，它们分别考虑餐厅的价格因素和距离因素的最大值。</p><p>过滤后返回餐馆的 <strong>id</strong>，按照 <strong>rating</strong> 从高到低排序。如果 <strong>rating</strong>相同，那么按 <strong>id</strong>从高到低排序。简单起见， <strong>veganFriendlyi</strong> 和 <strong>veganFriendly</strong>为 true 时取值为 1，为 false 时，取值为 0 。</p><h5 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h5><div class="hljs"><pre><code class="hljs text">输入：restaurants &#x3D; [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly &#x3D; 1, maxPrice &#x3D; 50, maxDistance &#x3D; 10输出：[3,1,5] 解释： 这些餐馆为：餐馆 1 [id&#x3D;1, rating&#x3D;4, veganFriendly&#x3D;1, price&#x3D;40, distance&#x3D;10]餐馆 2 [id&#x3D;2, rating&#x3D;8, veganFriendly&#x3D;0, price&#x3D;50, distance&#x3D;5]餐馆 3 [id&#x3D;3, rating&#x3D;8, veganFriendly&#x3D;1, price&#x3D;30, distance&#x3D;4]餐馆 4 [id&#x3D;4, rating&#x3D;10, veganFriendly&#x3D;0, price&#x3D;10, distance&#x3D;3]餐馆 5 [id&#x3D;5, rating&#x3D;1, veganFriendly&#x3D;1, price&#x3D;15, distance&#x3D;1] 在按照 veganFriendly &#x3D; 1, maxPrice &#x3D; 50 和 maxDistance &#x3D; 10 进行过滤后，我们得到了餐馆 3, 餐馆 1 和 餐馆 5（按评分从高到低排序）。</code></pre></div><h5 id="示例-2：-1"><a href="#示例-2：-1" class="headerlink" title="示例 2："></a>示例 2：</h5><div class="hljs"><pre><code class="hljs text">输入：restaurants &#x3D; [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly &#x3D; 0, maxPrice &#x3D; 50, maxDistance &#x3D; 10输出：[4,3,2,1,5]解释：餐馆与示例 1 相同，但在 veganFriendly &#x3D; 0 的过滤条件下，应该考虑所有餐馆。</code></pre></div><h5 id="示例-3：-1"><a href="#示例-3：-1" class="headerlink" title="示例 3："></a>示例 3：</h5><div class="hljs"><pre><code class="hljs text">输入：restaurants &#x3D; [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly &#x3D; 0, maxPrice &#x3D; 30, maxDistance &#x3D; 3输出：[4,5]</code></pre></div><p>提示：</p><blockquote><ul><li>1 &lt;= restaurants.length &lt;= 10^4</li><li>restaurants[i].length == 5</li><li>1 &lt;= idi, ratingi, pricei, distancei &lt;= 10^5</li><li>1 &lt;= maxPrice, maxDistance &lt;= 10^5</li><li>veganFriendlyi 和 veganFriendly 的值为 0 或 1 。</li><li>所有 id 各不相同。</li></ul></blockquote><h3 id="个人思路-1"><a href="#个人思路-1" class="headerlink" title="个人思路"></a>个人思路</h3><p>这题不难,就是写起来有点麻烦</p><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Item</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Item</span>&gt; </span>&#123;        <span class="hljs-keyword">int</span> id;        <span class="hljs-keyword">int</span> rating;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Item</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> rating)</span> </span>&#123;            <span class="hljs-keyword">this</span>.id = id;            <span class="hljs-keyword">this</span>.rating = rating;        &#125;                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Item a)</span> </span>&#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.rating != a.rating) <span class="hljs-keyword">return</span> a.rating - <span class="hljs-keyword">this</span>.rating;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.id - <span class="hljs-keyword">this</span>.id;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">filterRestaurants</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] restaurants, <span class="hljs-keyword">int</span> veganFriendly, <span class="hljs-keyword">int</span> maxPrice, <span class="hljs-keyword">int</span> maxDistance)</span> </span>&#123;        <span class="hljs-keyword">int</span> row = restaurants.length;        <span class="hljs-keyword">int</span> col = restaurants[<span class="hljs-number">0</span>].length;        List&lt;Item&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Item&gt;();        List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;            <span class="hljs-keyword">if</span> (veganFriendly == <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">if</span> (restaurants[i][<span class="hljs-number">2</span>] == <span class="hljs-number">1</span> &amp;&amp; restaurants[i][<span class="hljs-number">3</span>] &lt;= maxPrice &amp;&amp; restaurants[i][<span class="hljs-number">4</span>] &lt;= maxDistance) &#123;                    list.add(<span class="hljs-keyword">new</span> Item(restaurants[i][<span class="hljs-number">0</span>], restaurants[i][<span class="hljs-number">1</span>]));                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (restaurants[i][<span class="hljs-number">3</span>] &lt;= maxPrice &amp;&amp; restaurants[i][<span class="hljs-number">4</span>] &lt;= maxDistance) &#123;                    list.add(<span class="hljs-keyword">new</span> Item(restaurants[i][<span class="hljs-number">0</span>], restaurants[i][<span class="hljs-number">1</span>]));                &#125;            &#125;        &#125;        Collections.sort(list);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;            ans.add(list.get(i).id);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><p>题目链接：<a href="https://leetcode-cn.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/</a></p><hr><h2 id="3-阈值距离内邻居最少的城市"><a href="#3-阈值距离内邻居最少的城市" class="headerlink" title="3.阈值距离内邻居最少的城市"></a>3.阈值距离内邻居最少的城市</h2><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。</p><p>返回能通过某些路径到达其他城市数目最少 且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。</p><p>注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。</p><h5 id="示例-1：-2"><a href="#示例-1：-2" class="headerlink" title="示例 1："></a>示例 1：</h5><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-1dcfc71d09454e0697a9f8d1fab72202-thumbnail_1581216240802-94200f6c06024e689eb9c4073e322335.png" srcset="/img/loading.gif" alt=""></p><div class="hljs"><pre><code class="hljs text">输入：n &#x3D; 4, edges &#x3D; [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold &#x3D; 4输出：3解释：城市分布图如上。每个城市阈值距离 distanceThreshold &#x3D; 4 内的邻居城市分别是：城市 0 -&gt; [城市 1, 城市 2] 城市 1 -&gt; [城市 0, 城市 2, 城市 3] 城市 2 -&gt; [城市 0, 城市 1, 城市 3] 城市 3 -&gt; [城市 1, 城市 2] 城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。</code></pre></div><h5 id="示例-2：-2"><a href="#示例-2：-2" class="headerlink" title="示例 2："></a>示例 2：</h5><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-4a2fccac359b43aa932204ae5e50b248-thumbnail_1581216243192-84dadcc4f721442fa5b8851301d4aef3.png" srcset="/img/loading.gif" alt=""></p><div class="hljs"><pre><code class="hljs text">输入：n &#x3D; 5, edges &#x3D; [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold &#x3D; 2输出：0解释：城市分布图如上。 每个城市阈值距离 distanceThreshold &#x3D; 2 内的邻居城市分别是：城市 0 -&gt; [城市 1] 城市 1 -&gt; [城市 0, 城市 4] 城市 2 -&gt; [城市 3, 城市 4] 城市 3 -&gt; [城市 2, 城市 4]城市 4 -&gt; [城市 1, 城市 2, 城市 3] 城市 0 在阈值距离 4 以内只有 1 个邻居城市。</code></pre></div><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><blockquote><ul><li>2 &lt;= n &lt;= 100</li><li>1 &lt;= edges.length &lt;= n * (n - 1) / 2</li><li>edges[i].length == 3</li><li>0 &lt;= fromi &lt; toi &lt; n</li><li>1 &lt;= weighti, distanceThreshold &lt;= 10^4</li><li>所有 (fromi, toi) 都是不同的。</li></ul></blockquote><h3 id="个人思路-2"><a href="#个人思路-2" class="headerlink" title="个人思路"></a>个人思路</h3><p>刚开始是想直接从一个点开始搜索,看在距离阙值之类能到的点的数量,可是不知道为什么不对,有几个测试用例死活过不去<br>后来才想到可以用dijkstra算法,求出到各个点的最短路径,找出能在距离阈值范围之内的点最少的那个, floyd也行,不过不会</p><h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> []vis;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans, min = Integer.MAX_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTheCity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges, <span class="hljs-keyword">int</span> distanceThreshold)</span> </span>&#123;        map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                map[i][j] = Integer.MAX_VALUE;            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : edges) &#123;            <span class="hljs-keyword">int</span> v = edge[<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> e = edge[<span class="hljs-number">1</span>];            <span class="hljs-keyword">int</span> w = edge[<span class="hljs-number">2</span>];            map[v][e] = w;            map[e][v] = w;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            dijkstra(i, n, distanceThreshold);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v0, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> distanceThreshold)</span> </span>&#123;        <span class="hljs-keyword">boolean</span>[] s = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];        <span class="hljs-keyword">int</span> []dist = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            s[i] = <span class="hljs-keyword">false</span>;            dist[i] = map[v0][i];        &#125;        dist[v0] = <span class="hljs-number">0</span>;        s[v0] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>; w &lt; n; w++) &#123;                <span class="hljs-keyword">if</span> (!s[w] &amp;&amp; dist[w] &lt; min) &#123;                    v = w;                    min = dist[w];                &#125;            &#125;            s[v] = <span class="hljs-keyword">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (!s[j] &amp;&amp; (min + map[v][j] &lt; dist[j]) &amp;&amp; map[v][j] != Integer.MAX_VALUE) &#123;                    dist[j] = min + map[v][j];                &#125;            &#125;        &#125;        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dist.length; i++) &#123;            <span class="hljs-keyword">if</span> (dist[i] != <span class="hljs-number">0</span> &amp;&amp; dist[i] &lt;= distanceThreshold) &#123;                cnt++;            &#125;        &#125;        <span class="hljs-keyword">if</span> (min &gt;= cnt) &#123;            min = cnt;            ans = v0;        &#125;    &#125;&#125;</code></pre></div><p>有几个测试用例过不去</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;        <span class="hljs-keyword">int</span> v, e, w;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> w)</span> </span>&#123;            <span class="hljs-keyword">this</span>.v = v;            <span class="hljs-keyword">this</span>.e = e;            <span class="hljs-keyword">this</span>.w = w;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> []vis;    <span class="hljs-keyword">private</span> List&lt;Edge&gt;[]adj;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] at;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findTheCity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] edges, <span class="hljs-keyword">int</span> distanceThreshold)</span> </span>&#123;        vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n + <span class="hljs-number">1</span>];        adj = <span class="hljs-keyword">new</span> ArrayList[n + <span class="hljs-number">1</span>];        at = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n + <span class="hljs-number">1</span>];        Arrays.fill(at, <span class="hljs-number">0</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            adj[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Edge&gt;();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; edges.length; i++) &#123;            <span class="hljs-keyword">int</span> v = edges[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> e = edges[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">int</span> w = edges[i][<span class="hljs-number">2</span>];            adj[v].add(<span class="hljs-keyword">new</span> Edge(v, e, w));            adj[e].add(<span class="hljs-keyword">new</span> Edge(e, v, w));        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            Arrays.fill(vis, <span class="hljs-number">0</span>);            dfs(distanceThreshold, i, <span class="hljs-number">0</span>, i);        &#125;        <span class="hljs-keyword">int</span> min = <span class="hljs-number">999</span>;        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            System.out.println(at[i]);            <span class="hljs-keyword">if</span> (at[i] &lt;= min) &#123;                min = at[i];                ans = i;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> distanceThreshold, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> p)</span> </span>&#123;        vis[cur] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; adj[cur].size(); i++) &#123;            sum += adj[cur].get(i).w;            <span class="hljs-keyword">if</span> (vis[adj[cur].get(i).e] == <span class="hljs-number">0</span> &amp;&amp; sum &lt;= distanceThreshold) &#123;                at[p] += <span class="hljs-number">1</span>;                dfs(distanceThreshold, adj[cur].get(i).e, sum, p);            &#125;            sum -= adj[cur].get(i).w;        &#125;    &#125;&#125;</code></pre></div><p>题目链接：<a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/</a></p><hr><h2 id="4-工作计划的最低难度"><a href="#4-工作计划的最低难度" class="headerlink" title="4.工作计划的最低难度"></a>4.工作计划的最低难度</h2><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>你需要制定一份 d 天的工作计划表。工作之间存在依赖，要想执行第 i 项工作，你必须完成全部 j 项工作（ 0 &lt;= j &lt; i）。</p><p>你每天 至少 需要完成一项任务。工作计划的总难度是这 d 天每一天的难度之和，而一天的工作难度是当天应该完成工作的最大难度。</p><p>给你一个整数数组 jobDifficulty 和一个整数 d，分别代表工作难度和需要计划的天数。第 i 项工作的难度是 jobDifficulty[i]。</p><p>返回整个工作计划的 最小难度 。如果无法制定工作计划，则返回 -1 。</p><h5 id="示例-1：-3"><a href="#示例-1：-3" class="headerlink" title="示例 1："></a>示例 1：</h5><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-d6b3825594bb4740bf31569ad6467ad3-thumbnail_1581216245536-5fdd76d1dea44d6da340bce18c5e18ef.png" srcset="/img/loading.gif" alt=""></p><div class="hljs"><pre><code class="hljs text">输入：jobDifficulty &#x3D; [6,5,4,3,2,1], d &#x3D; 2输出：7解释：第一天，您可以完成前 5 项工作，总难度 &#x3D; 6.第二天，您可以完成最后一项工作，总难度 &#x3D; 1.计划表的难度 &#x3D; 6 + 1 &#x3D; 7</code></pre></div><h5 id="示例-2：-3"><a href="#示例-2：-3" class="headerlink" title="示例 2："></a>示例 2：</h5><div class="hljs"><pre><code class="hljs text">输入：jobDifficulty &#x3D; [9,9,9], d &#x3D; 4输出：-1解释：就算你每天完成一项工作，仍然有一天是空闲的，你无法制定一份能够满足既定工作时间的计划表。</code></pre></div><h5 id="示例-3：-2"><a href="#示例-3：-2" class="headerlink" title="示例 3："></a>示例 3：</h5><div class="hljs"><pre><code class="hljs text">输入：jobDifficulty &#x3D; [1,1,1], d &#x3D; 3输出：3解释：工作计划为每天一项工作，总难度为 3 。</code></pre></div><h5 id="示例-4：-1"><a href="#示例-4：-1" class="headerlink" title="示例 4："></a>示例 4：</h5><div class="hljs"><pre><code class="hljs text">输入：jobDifficulty &#x3D; [7,1,7,1,7,1], d &#x3D; 3输出：15</code></pre></div><h5 id="示例-5："><a href="#示例-5：" class="headerlink" title="示例 5："></a>示例 5：</h5><div class="hljs"><pre><code class="hljs text">输入：jobDifficulty &#x3D; [11,111,22,222,33,333,44,444], d &#x3D; 6输出：843</code></pre></div><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><blockquote><ul><li>1 &lt;= jobDifficulty.length &lt;= 300</li><li>0 &lt;= jobDifficulty[i] &lt;= 1000</li><li>1 &lt;= d &lt;= 10</li></ul></blockquote><h3 id="个人思路-3"><a href="#个人思路-3" class="headerlink" title="个人思路"></a>个人思路</h3><p>没有思路，没做出来</p><p>题目链接：<a href="https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-difficulty-of-a-job-schedule/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-第 18 场双周赛</title>
    <link href="/2020/01/26/LeetCode-%E7%AC%AC-18-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    <url>/2020/01/26/LeetCode-%E7%AC%AC-18-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数组序号转换"><a href="#1-数组序号转换" class="headerlink" title="1.数组序号转换"></a>1.数组序号转换</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。</p><p>序号代表了一个元素有多大。序号编号的规则如下：</p><p>序号从 1 开始编号。<br>一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。<br>每个数字的序号都应该尽可能地小。</p><p>示例 1：</p><div class="hljs"><pre><code class="hljs text">输入：arr &#x3D; [40,10,20,30]输出：[4,1,2,3]解释：40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。</code></pre></div><p>示例 2：</p><div class="hljs"><pre><code class="hljs text">输入：arr &#x3D; [100,100,100]输出：[1,1,1]解释：所有元素有相同的序号。</code></pre></div><p>示例 3：</p><div class="hljs"><pre><code class="hljs text">输入：arr &#x3D; [37,12,28,9,100,56,80,5,12]输出：[5,3,4,2,8,6,7,1,3]</code></pre></div><p>提示：</p><blockquote><p>0 &lt;= arr.length &lt;= 105<br>-109 &lt;= arr[i] &lt;= 109</p></blockquote><h3 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h3><ul><li>先开个一维数组ar复制一遍arr的元素</li><li>排序原数组</li><li>用<strong>map</strong>记录排序后各元素的位置（用map能保证元素不重复且序号是唯一的）</li><li>再遍历一遍ar数组，依次取出map中与ar[i]对应的value值</li></ul><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] arrayRankTransform(<span class="hljs-keyword">int</span>[] arr) &#123;        <span class="hljs-keyword">int</span> []ar = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [arr.length];        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            ar[i] = arr[i];        &#125;        Arrays.sort(arr);        <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            <span class="hljs-keyword">if</span> (map.get(arr[i]) == <span class="hljs-keyword">null</span>) &#123;                map.put(arr[i], index++);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ar.length; i++) &#123;            ar[i] = map.get(ar[i]);        &#125;        <span class="hljs-keyword">return</span> ar;    &#125;&#125;</code></pre></div><p>题目链接：<a href="https://leetcode-cn.com/problems/rank-transform-of-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rank-transform-of-an-array</a></p><hr><h2 id="2-破坏回文串"><a href="#2-破坏回文串" class="headerlink" title="2.破坏回文串"></a>2.破坏回文串</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个回文字符串 palindrome ，请你将其中 一个 字符用任意小写英文字母替换，使得结果字符串的字典序最小，且 不是 回文串。</p><p>请你返回结果字符串。如果无法做到，则返回一个空串。</p><p>示例 1：</p><div class="hljs"><pre><code class="hljs text">输入：palindrome &#x3D; &quot;abccba&quot;输出：&quot;aaccba&quot;</code></pre></div><p>示例 2：</p><div class="hljs"><pre><code class="hljs text">输入：palindrome &#x3D; &quot;a&quot;输出：&quot;&quot;</code></pre></div><p>提示：</p><blockquote><ul><li>1 &lt;= palindrome.length &lt;= 1000</li><li>palindrome 只包含小写英文字母。</li></ul></blockquote><h3 id="个人思路-1"><a href="#个人思路-1" class="headerlink" title="个人思路"></a>个人思路</h3><p>暴力枚举，由于回文串长度只有1000，那么将每个位置的字符依次替换成26个小写字母，判断替换后是否还是回文串，不是的话，加入集合，最后对集合进行排序，取出第一个就是字典序最小的</p><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">breakPalindrome</span><span class="hljs-params">(String palindrome)</span> </span>&#123;        <span class="hljs-keyword">if</span> (palindrome == <span class="hljs-keyword">null</span> || palindrome == <span class="hljs-string">""</span> || palindrome.length() == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;        &#125;        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; palindrome.length(); i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">26</span>; j++) &#123;                <span class="hljs-keyword">char</span> ch = (<span class="hljs-keyword">char</span>)(<span class="hljs-number">96</span> + j);                String s = sb.append(palindrome.substring(<span class="hljs-number">0</span>, i)).append(ch).append(palindrome.substring(i + <span class="hljs-number">1</span>, palindrome.length())).toString();                <span class="hljs-keyword">if</span> (!isPalindrome(s)) &#123;                    list.add(s);                &#125;                sb.setLength(<span class="hljs-number">0</span>);            &#125;        &#125;        Collections.sort(list);        <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">return</span> sb.append(s).reverse().toString().equals(s);    &#125;&#125;</code></pre></div><p>题目链接：<a href="https://leetcode-cn.com/problems/break-a-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/break-a-palindrome/</a></p><hr><h2 id="3-将矩阵按对角线排序"><a href="#3-将矩阵按对角线排序" class="headerlink" title="3.将矩阵按对角线排序"></a>3.将矩阵按对角线排序</h2><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个 m * n 的整数矩阵 mat ，请你将同一条对角线上的元素（从左上到右下）按升序排序后，返回排好序的矩阵。</p><h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5><p><img src="https://www.lwjppz.cn/upload/2020/1/image-00d5bc3ed9a24c6c9f4d6c5d24ea66bd.png" srcset="/img/loading.gif" alt=""></p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><div class="hljs"><pre><code class="hljs text">输入：mat &#x3D; [[3,3,1,1],[2,2,1,2],[1,1,1,2]]输出：[[1,1,1,1],[1,2,2,2],[1,2,3,3]]</code></pre></div><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><blockquote><ul><li>m == mat.length</li><li>n == mat[i].length</li><li>1 &lt;= m, n &lt;= 100</li><li>1 &lt;= mat[i][j] &lt;= 100</li></ul></blockquote><h3 id="个人思路-2"><a href="#个人思路-2" class="headerlink" title="个人思路"></a>个人思路</h3><ul><li>从右上角出发，标记两个点A(aR, aC)，B(bR, bC)</li><li>A点的行动轨迹是：向左走，直到A点的列(aC)为零，再向下走，结束位置再左下角</li><li>B点的行东轨迹是：向下走，直到B点的行(bR == 矩阵的行数)，再向左走，结束位置也在左下角</li><li>A，B两点每次走一步</li><li>取出左上方A点到右下方B点这条对角线的所有元素，排序后沿对角线赋值<h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] diagonalSort(<span class="hljs-keyword">int</span>[][] mat) &#123;        <span class="hljs-keyword">int</span> aR = <span class="hljs-number">0</span>, aC = mat[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>, bR = <span class="hljs-number">0</span>, bC = mat[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> endR = mat.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> endC = mat[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (aR != endR + <span class="hljs-number">1</span>) &#123;            function(mat, aR, aC, bR, bC);            aR = (aC == <span class="hljs-number">0</span>) ? aR + <span class="hljs-number">1</span> : aR;            aC = (aC == <span class="hljs-number">0</span>) ? aC : aC - <span class="hljs-number">1</span>;            bR = (bR == endR) ? bR : bR + <span class="hljs-number">1</span>;            bC = (bR == endR) ? bC - <span class="hljs-number">1</span> : bC;        &#125;        <span class="hljs-keyword">return</span> mat;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [][]mat, <span class="hljs-keyword">int</span> aR, <span class="hljs-keyword">int</span> aC, <span class="hljs-keyword">int</span> bR, <span class="hljs-keyword">int</span> bC)</span> </span>&#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        <span class="hljs-keyword">int</span> a = aR, b = aC, c = bR, d = bC;        <span class="hljs-keyword">while</span> (a != c + <span class="hljs-number">1</span>) &#123;            list.add(mat[a++][b++]);        &#125;        Collections.sort(list);        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (aR != bR + <span class="hljs-number">1</span>) &#123;            mat[aR++][aC++] = list.get(index++);        &#125;    &#125;&#125;</code></pre></div></li></ul><p>题目链接：<a href="https://leetcode-cn.com/problems/sort-the-matrix-diagonally/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-the-matrix-diagonally/</a></p><hr><h2 id="4-翻转子数组得到最大的数组值"><a href="#4-翻转子数组得到最大的数组值" class="headerlink" title="4.翻转子数组得到最大的数组值"></a>4.翻转子数组得到最大的数组值</h2><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一个整数数组 <strong>nums</strong> 。「 数组值」定义为所有满足 <strong>0 &lt;= i &lt; nums.length-1</strong> 的 <strong>|nums[i]-nums[i+1]|</strong> 的和。</p><p>你可以选择给定数组的任意子数组，并将该子数组翻转。但你只能执行这个操作 一次 。</p><p>请你找到可行的最大 数组值 。</p><h4 id="示例-1：-1"><a href="#示例-1：-1" class="headerlink" title="示例 1："></a>示例 1：</h4><div class="hljs"><pre><code class="hljs text">输入：nums &#x3D; [2,3,1,5,4]输出：10解释：通过翻转子数组 [3,1,5] ，数组变成 [2,5,1,3,4] ，数组值为 10 。</code></pre></div><p>示例 2：</p><div class="hljs"><pre><code class="hljs text">输入：nums &#x3D; [2,4,9,24,2,1,10]输出：68</code></pre></div><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><blockquote><ul><li>1 &lt;= nums.length &lt;= 3*10^4</li><li>-10^5 &lt;= nums[i] &lt;= 10^5</li></ul></blockquote><h3 id="个人思路-3"><a href="#个人思路-3" class="headerlink" title="个人思路"></a>个人思路</h3><p>没有思路，没做出来</p><h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs java"></code></pre></div><p>题目链接：<a href="https://leetcode-cn.com/problems/reverse-subarray-to-maximize-array-value/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-subarray-to-maximize-array-value/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019个人总结</title>
    <link href="/2020/01/21/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/21/2019%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>19年过得好快啊,转眼就到了一年的最后一天,感觉今年过的似乎特别快<br>其实在28号那天就已经准备写这篇总结的了，不过因为后面几天要考试,并且发生了一些φ(&gt;ω&lt;*) 事<br>考完之后又因为种种原因，直到现在才想到，哦豁!好像去年的总结还没写，所以现在把这篇迟到已久的年度总结整上</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>以前对自己的生活都是过一天算一天，没有留下来什么东西，感觉挺遗憾的，不过还挺及时，在19年暑假的时候，那是由于学习技术的原因，无意间发现了别人的博客，所以那时自己就想自己也搭一个属于自己的个人博客。用于记录自己学习生活中发生的点点滴滴。</p><h2 id="前尘过往"><a href="#前尘过往" class="headerlink" title="前尘过往"></a>前尘过往</h2><h3 id="18年"><a href="#18年" class="headerlink" title="18年"></a>18年</h3><p>18年刚入学，怀揣着激动，紧张，对新知识无限向往的心情迈进大学，开始了以后作为一名程序猿的艰难生活。刚学编程的时候，入门语言是C语言，还记得当时敲一个Hello World时手忙脚乱的样子，怎么敲都敲不对，让我觉得可能编程不适合我(其实现在我也还是觉得编程不适合我o(╥﹏╥)o)。但历经千辛万苦最后运行成功那一刻的喜悦，也是无法表达的。<br>第一次接触Java是在18年12月，刚接触Java的时候第一时间就觉得这个比C语言方便太多了吧，好多工具类可以供你使用，不像C语言那样，全部要手写，你只要会调用API就基本能解决大部分问题了。当时就沉迷于Java学习无法自拔，大概用了三个月左右基本熟悉了基本语法，因为当时有考试等等原因，可能进度有点慢。</p><h3 id="19年"><a href="#19年" class="headerlink" title="19年"></a>19年</h3><p>2019年绝对算得上是我人生当中最令我难忘的一年之一。到了19年，这一年是自己学习技术最多的一年。在19年的寒假，当时觉得已经基本掌握了Java的基本语法后，就开始学习数据结构的相关知识了，现在还清楚的记得，那个寒假简直无比痛苦罒ω罒，觉得数据结构好抽象，看教程，看代码，代码有时候完全看不懂，记得学到栈与队列的时候，做迷宫类型问题时，我的天，花了我整整一个星期才完全搞明白，学到后面发现其实有更简洁的方式去解决这一类问题。<br>开学后，由于我们专业这一学期有教Java，所以这一学期老师讲的知识就当做对之前自己自学的补缺补漏了。在这一学期自己也接触了关于前端的一些知识，html、css、js等等，不过由于自己的问题，这些东西学的并不是很好，只懂一些皮毛，所以我也不再深入前端学习，花了一些时间了解了一些前端知识后，我就慢慢进入JavaWeb的开发了，这一部分学习周期是很长的，在学校自己只能通过一些零散的时间来学习相关知识。但还好，在暑假过了差不多三分之一左右，把JavaWeb相关知识大致过了一遍，在结束这部分学习之后,就开始自己动手写一些小东西，比如XX管理系统….。<br>在大概暑假又过了三分之一的时候，那时小东西也写的差不多了，就开始看框架了，看的是SSM框架(Spring、SpringMVC、MyBatis)，在看的过程中就和之前的做比较，看用框架是怎么简化开发的，如果只是会用框架的话，看完还是很快的，看完之后，也尝试用框架将之前写的小东西用框架从构一遍，不过在此过程中，发现了好多问题。也正是这些问题让我有了自己搭一个博客的想法。<br>当时是用Solo这个博客系统搭的，花了一点时间才搞定。我也正式拥有了第一个属于我的个人博客٩(๑&gt;◡&lt;๑)۶ 。</p><h2 id="现实当下"><a href="#现实当下" class="headerlink" title="现实当下"></a>现实当下</h2><h3 id="日常生活"><a href="#日常生活" class="headerlink" title="日常生活"></a>日常生活</h3><p>在学习方面，也就那样，反正做到不挂科，怎么样都行<br>每天生活其实也挺简单的，无非就是寝室、食堂、教室、还有马路、操场。不过有一只女朋友让我的生活不再单调，有了很多开心与不开心。(&gt;ω･* )ﾉ<br>在年底烫了人生中第一个发<br>解锁了早上七点半去图书馆学习的成就<br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/IMG_20191130_081532_1581217877675.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="玩耍"><a href="#玩耍" class="headerlink" title="玩耍"></a>玩耍</h3><p>暑假开始没几天，完成了一次晋江3日游(简直噩梦)<br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200809163536.png" srcset="/img/loading.gif" alt=""><br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/IMG_20190708_082629_1_1581218473161.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/IMG_1581218473052.jpg" srcset="/img/loading.gif" alt=""></p><p>12月8号，带领几个小伙伴去了沙县小吃节</p><p><img src="https://lwjppz.oss-cn-beijing.aliyuncs.com/images/IMG_20191207_124552_1581218565161.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://lwjppz.oss-cn-beijing.aliyuncs.com/images/IMG_20191207_143954_1581218512145.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://lwjppz.oss-cn-beijing.aliyuncs.com/images/IMG_20191207_115545_1581218503286.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://lwjppz.oss-cn-beijing.aliyuncs.com/images/IMG_20191207_144856_1581218637786.jpg" srcset="/img/loading.gif" alt=""><br>当然，电影也是不能少的，要和最爱的人一起看<br><img src="https://lwjppz.oss-cn-beijing.aliyuncs.com/images/IMG_20191231_215914_1581219004942.jpg" srcset="/img/loading.gif" alt=""><br><img src="https://lwjppz.oss-cn-beijing.aliyuncs.com/images/IMG20200110190802_1581219004770.jpg" srcset="/img/loading.gif" alt=""><br>。。。。。。。。。。。。。。。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>也没什么好说的，祝愿我的好朋友们，我爱的和爱我的人都能永远开心，永远快乐，希望来年的自己能做的越来越好。</p>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水题ing</title>
    <link href="/2020/01/20/%E6%B0%B4%E9%A2%98ing/"/>
    <url>/2020/01/20/%E6%B0%B4%E9%A2%98ing/</url>
    
    <content type="html"><![CDATA[<h2 id="结点选择"><a href="#结点选择" class="headerlink" title="结点选择"></a>结点选择</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>有一棵 n 个节点的树，树上每个节点都有一个正整数权值。如果一个点被选择了，那么在树上和它相邻的点都不能被选择。求选出的点的权值和最大是多少？</p><p>数据规模与约定</p><p>对于20%的数据， n &lt;= 20。</p><p>对于50%的数据， n &lt;= 1000。</p><p>对于100%的数据， n &lt;= 100000。</p><p>权值均为不超过1000的正整数。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>第一行包含一个整数 n 。</p><p>接下来的一行包含 n 个正整数，第 i 个正整数代表点 i 的权值。</p><p>接下来一共 n-1 行，每行描述树上的一条边。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>输出一个整数，代表选出的点的权值和的最大值</p><p>样例说明<br>选择3、4、5号点，权值和为 3+4+5 = 12 。</p><h4 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h4><div class="hljs"><pre><code class="hljs text">51 2 3 4 51 21 32 42 5</code></pre></div><p>样例输出</p><div class="hljs"><pre><code class="hljs text">12</code></pre></div><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这题乍一看是一道关于树的搜索的题目,但是看到数据后就放弃了(；´д｀)ゞ，然后想到动态规划，但是想不出来要怎么找状态。后面百度才知道这是一题树形DP，？？？。什么是树形DP，没有学过。<br>花了点时间学习了一下，差不多理解这题了。</p><div class="hljs"><pre><code class="hljs text">假设 dp[i][1] 表示选择了 i 节点后的权值，dp[i][0]表示不选 i 节点的权值，那么dp[i][1] +&#x3D; dp[j][0] --&gt; j 表示 i 节点的孩子dp[i][0] +&#x3D; max(dp[j][0], dp[j][1]) --&gt; j 表示 i 节点的孩子最后最大权值为 max(dp[1][0], dp[1][1])</code></pre></div><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>java写的不会过，C++写的过了，不知道为啥</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>&#123;        <span class="hljs-keyword">static</span> BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">static</span> StringTokenizer tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(<span class="hljs-string">""</span>);        <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">nextLine</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> reader.readLine();        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">while</span> (!tokenizer.hasMoreTokens()) &#123;                tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(reader.readLine());            &#125;            <span class="hljs-keyword">return</span> tokenizer.nextToken();        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextInt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Integer.parseInt(next());        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">nextDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Double.parseDouble(next());        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            reader.close();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> PrintStream(System.out));        <span class="hljs-keyword">int</span> n = Reader.nextInt();        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100005</span>][<span class="hljs-number">2</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            dp[i][<span class="hljs-number">1</span>] = Reader.nextInt();        &#125;        ArrayList&lt;Integer&gt;[] nodes = <span class="hljs-keyword">new</span> ArrayList[<span class="hljs-number">100005</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;            nodes[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">int</span> v = Reader.nextInt();            <span class="hljs-keyword">int</span> e = Reader.nextInt();            nodes[v].add(e);            nodes[e].add(v);        &#125;        dfs(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, nodes, dp);        out.println(Math.max(dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]));        out.flush();    &#125;    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> pre, List&lt;Integer&gt; []nodes, <span class="hljs-keyword">int</span>[][] dp)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodes[x].size(); i++) &#123;            <span class="hljs-keyword">int</span> e = nodes[x].get(i);            <span class="hljs-keyword">if</span> (e == pre) <span class="hljs-keyword">continue</span>;            dfs(e, x, nodes, dp);            dp[x][<span class="hljs-number">1</span>] += dp[e][<span class="hljs-number">0</span>];            dp[x][<span class="hljs-number">0</span>] += Math.max(dp[e][<span class="hljs-number">0</span>], dp[e][<span class="hljs-number">1</span>]);        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 100005</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nodes[MAXN];<span class="hljs-keyword">int</span> dp[MAXN][<span class="hljs-number">2</span>];<span class="hljs-keyword">int</span> n, v, e;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> pre)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodes[x].<span class="hljs-built_in">size</span>(); i++) &#123;        <span class="hljs-keyword">int</span> s = nodes[x][i];        <span class="hljs-keyword">if</span> (s == pre) <span class="hljs-keyword">continue</span>;        dfs(s, x);        dp[x][<span class="hljs-number">1</span>] += dp[s][<span class="hljs-number">0</span>];        dp[x][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[s][<span class="hljs-number">0</span>], dp[s][<span class="hljs-number">1</span>]);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-built_in">cin</span> &gt;&gt; dp[i][<span class="hljs-number">1</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-built_in">cin</span> &gt;&gt; v &gt;&gt; e;        nodes[v].push_back(e);        nodes[e].push_back(v);    &#125;    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><hr><h2 id="网络寻路"><a href="#网络寻路" class="headerlink" title="网络寻路"></a>网络寻路</h2><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>X 国的一个网络使用若干条线路连接若干个节点。节点间的通信是双向的。某重要数据包，为了安全起见，必须恰好被转发两次到达目的地。该包可能在任意一个节点产生，我们需要知道该网络中一共有多少种不同的转发路径。<br>源地址和目标地址可以相同，但中间节点必须不同。</p><p>如下图所示的网络。<br>1 -&gt; 2 -&gt; 3 -&gt; 1 是允许的<br>1 -&gt; 2 -&gt; 1 -&gt; 2 或者 1 -&gt; 2 -&gt; 3 -&gt; 2 都是非法的。</p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>输入数据的第一行为两个整数N M，分别表示节点个数和连接线路的条数(1&lt;=N&lt;=10000; 0&lt;=M&lt;=100000)。<br>接下去有M行，每行为两个整数 u 和 v，表示节点u 和 v 联通(1&lt;=u,v&lt;=N , u!=v)。<br>输入数据保证任意两点最多只有一条边连接，并且没有自己连自己的边，即不存在重边和自环。</p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>输出一个整数，表示满足要求的路径条数。</p><h4 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h4><div class="hljs"><pre><code class="hljs text">3 31 22 31 3</code></pre></div><p>样例输出</p><div class="hljs"><pre><code class="hljs text">6</code></pre></div><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题简单没啥好说的了</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.StringTokenizer; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>&#123;        <span class="hljs-keyword">static</span> BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">static</span> StringTokenizer tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(<span class="hljs-string">""</span>);         <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">nextLine</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> reader.readLine();        &#125;         <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">while</span> (!tokenizer.hasMoreTokens()) &#123;                tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(reader.readLine());            &#125;            <span class="hljs-keyword">return</span> tokenizer.nextToken();        &#125;         <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextInt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Integer.parseInt(next());        &#125;         <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">nextDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Double.parseDouble(next());        &#125;         <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            reader.close();        &#125;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> PrintStream(System.out));        <span class="hljs-keyword">int</span> n = Reader.nextInt();        <span class="hljs-keyword">int</span> m = Reader.nextInt();        Solution s = <span class="hljs-keyword">new</span> Solution(n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            s.addEdge(Reader.nextInt(), Reader.nextInt());        &#125;        out.println(s.dfs());        out.flush();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_L = <span class="hljs-number">10005</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n, ans;    <span class="hljs-keyword">private</span> List&lt;Integer&gt; []map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> []vis;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.n = n;        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> ArrayList[MAX_L];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            map[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        &#125;        <span class="hljs-keyword">this</span>.vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX_L];    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> e)</span> </span>&#123;        map[v].add(e);        map[e].add(v);    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            dfs(i, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> cnt, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">3</span>) &#123;            ans++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; map[cur].size(); i++) &#123;            <span class="hljs-keyword">int</span> e = map[cur].get(i);            <span class="hljs-keyword">if</span> (e != cnt) dfs(e, cur, sum + <span class="hljs-number">1</span>);        &#125;    &#125;&#125;</code></pre></div><hr><h2 id="数的划分"><a href="#数的划分" class="headerlink" title="数的划分"></a>数的划分</h2><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。<br>例如：n=7，k=3，下面三种分法被认为是相同的。<br>1，1，5;<br>1，5，1;<br>5，1，1;<br>问有多少种不同的分法。<br>输入：n，k ( 6 &lt; n ≤ 200，2 ≤ k ≤ 6 )<br>输出：一个整数，即不同的分法。</p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><blockquote><p>两个整数 n,k ( 6 &lt; n ≤ 200， 2 ≤ k ≤ 6 )</p></blockquote><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><blockquote><p>1个整数，即不同的分法。</p></blockquote><h4 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入"></a>样例输入</h4><div class="hljs"><pre><code class="hljs text">7 3</code></pre></div><p>样例输出</p><div class="hljs"><pre><code class="hljs text">4</code></pre></div><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.util.StringTokenizer;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/1/23 13:40</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>&#123;        <span class="hljs-keyword">static</span> BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">static</span> StringTokenizer tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(<span class="hljs-string">""</span>);        <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">nextLine</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> reader.readLine();        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">while</span> (!tokenizer.hasMoreTokens()) &#123;                tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(reader.readLine());            &#125;            <span class="hljs-keyword">return</span> tokenizer.nextToken();        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextInt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Integer.parseInt(next());        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">nextDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Double.parseDouble(next());        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            reader.close();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-keyword">int</span> n = Reader.nextInt();        <span class="hljs-keyword">int</span> k = Reader.nextInt();        Code_2 code_2 = <span class="hljs-keyword">new</span> Code_2(n, k);        code_2.dfs();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code_2</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ans, n, k;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Code_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.n = n;        <span class="hljs-keyword">this</span>.k = k;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        System.out.println(ans);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum, <span class="hljs-keyword">int</span> cnt, <span class="hljs-keyword">int</span> cur)</span> </span>&#123;        <span class="hljs-keyword">if</span>(sum == n &amp;&amp; cnt == k) &#123;            ans++;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(cnt &gt;= k) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = cur; i &lt;= n - cur; i++) &#123;            <span class="hljs-keyword">if</span>(sum + i &gt; n) <span class="hljs-keyword">return</span>;            dfs(sum + i, cnt + <span class="hljs-number">1</span>, i);        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">int</span> n, k, ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> ct, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(ct == n &amp;&amp; cnt == k) &#123;        ans++;    &#125;    <span class="hljs-keyword">if</span>(cnt &gt;= k) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span>(i = index; i &lt;= n - ct; i++) &#123;        <span class="hljs-keyword">if</span>(ct + i &gt; n) &#123;            <span class="hljs-keyword">continue</span>;        &#125;        dfs(i, i + ct, cnt + <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;n, &amp;k);    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><hr><h2 id="危险系数"><a href="#危险系数" class="headerlink" title="危险系数"></a>危险系数</h2><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>问题描述<br>抗日战争时期，冀中平原的地道战曾发挥重要作用。<br>地道的多个站点间有通道连接，形成了庞大的网络。但也有隐患，当敌人发现了某个站点后，其它站点间可能因此会失去联系。<br>我们来定义一个危险系数DF(x,y)：<br>对于两个站点x和y  (x  !=  y),  如果能找到一个站点z，当z被敌人破坏后，x和y不连通，那么我们称z为关于x,y的关键点。相应的，对于任意一对站点x和y，危险系数DF(x,y)就表示为这两点之间的关键点个数。<br>本题的任务是：已知网络结构，求两站点之间的危险系数。</p><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>输入数据第一行包含2个整数n(2  &lt; =  n  &lt; =  1000),  m(0  &lt; =  m  &lt; =  2000),分别代表站点数，通道数；<br>接下来m行，每行两个整数  u,v  (1  &lt; =  u,  v  &lt; =  n;  u  !=  v)代表一条通道；<br>最后1行，两个数u,v，代表询问两点之间的危险系数DF(u,  v)。 </p><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>一个整数，如果询问的两点不连通则输出-1.</p><h4 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入"></a>样例输入</h4><div class="hljs"><pre><code class="hljs text">7  6 1  3 2  3 3  4 3  5 4  5 5  6 1  6</code></pre></div><p>样例输出</p><div class="hljs"><pre><code class="hljs text">2</code></pre></div><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>主要思路就是去除某个顶点e(e != u &amp;&amp; e != v) 后,判断去除e点后,u和v是否还是连通的,如果不连通的话,计数器加一<br>至于怎么判断连通性,……直接深搜</p><h4 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>];<span class="hljs-keyword">int</span> mp[<span class="hljs-number">1005</span>];<span class="hljs-keyword">int</span> n, m, a, b, ans;<span class="hljs-keyword">bool</span> f = <span class="hljs-literal">false</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> p)</span> </span>&#123;    <span class="hljs-keyword">if</span> (cur == b) &#123;        f = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (f) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[cur][i] == <span class="hljs-number">1</span> &amp;&amp; i != p &amp;&amp; mp[i] == <span class="hljs-number">0</span>) &#123;            mp[i] = <span class="hljs-number">1</span>;            dfs(i, p);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;        <span class="hljs-built_in">map</span>[a][b] = <span class="hljs-number">1</span>;        <span class="hljs-built_in">map</span>[b][a] = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span> (i != a &amp;&amp; i != b) &#123;            <span class="hljs-built_in">memset</span>(mp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(mp));            f = <span class="hljs-literal">false</span>;            mp[a] = <span class="hljs-number">1</span>;            dfs(a, i);            <span class="hljs-keyword">if</span> (!f) &#123;                ans++;            &#125;        &#125;    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.StringTokenizer; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>&#123;        <span class="hljs-keyword">static</span> BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">static</span> StringTokenizer tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(<span class="hljs-string">""</span>);         <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">nextLine</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> reader.readLine();        &#125;         <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">while</span> (!tokenizer.hasMoreTokens()) &#123;                tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(reader.readLine());            &#125;            <span class="hljs-keyword">return</span> tokenizer.nextToken();        &#125;         <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextInt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Integer.parseInt(next());        &#125;         <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">nextDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Double.parseDouble(next());        &#125;         <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            reader.close();        &#125;    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> PrintStream(System.out));        <span class="hljs-keyword">int</span> n = Reader.nextInt();        <span class="hljs-keyword">int</span> m = Reader.nextInt();        Solution s = <span class="hljs-keyword">new</span> Solution(n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            s.addEdge(Reader.nextInt(), Reader.nextInt());        &#125;        out.println(s.dfs(Reader.nextInt(), Reader.nextInt()));        out.flush();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_L = <span class="hljs-number">1005</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> n, ans, flag;    <span class="hljs-keyword">private</span> List&lt;Integer&gt; []map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> []vis;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.n = n;        <span class="hljs-keyword">this</span>.flag = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> ArrayList[MAX_L];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            map[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        &#125;        <span class="hljs-keyword">this</span>.vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX_L];    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> e)</span> </span>&#123;        map[v].add(e);        map[e].add(v);    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-keyword">if</span> (i != u &amp;&amp; i != v) &#123;                vis[u] = <span class="hljs-number">1</span>;                dfs(u, v, i);                <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) ans++;                Arrays.fill(vis, <span class="hljs-number">0</span>);                flag = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;     <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">int</span> cnt)</span> </span>&#123;        <span class="hljs-keyword">if</span> (cur == end) &#123;            flag = <span class="hljs-number">1</span>;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; map[cur].size(); i++) &#123;                <span class="hljs-keyword">int</span> e = map[cur].get(i);                <span class="hljs-keyword">if</span> (e != cnt &amp;&amp; vis[e] == <span class="hljs-number">0</span>) &#123;                    vis[e] = <span class="hljs-number">1</span>;                    dfs(e, end, cnt);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></div><hr><h2 id="剪格子"><a href="#剪格子" class="headerlink" title="剪格子"></a>剪格子</h2><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>如下图所示，3 x 3 的格子中填写了一些整数。<br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/234123541325_1581216281802.png" srcset="/img/loading.gif" alt=""><br>我们沿着图中的星号线剪开，得到两个部分，每个部分的数字和都是60。<br>本题的要求就是请你编程判定：对给定的m x n 的格子中的整数，是否可以分割为两个部分，使得这两个区域的数字和相等。<br>如果存在多种解答，请输出包含左上角格子的那个区域包含的格子的最小数目。<br>如果无法分割，则输出 0。</p><h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>程序先读入两个整数  m  n  用空格分割  (m,n&lt; 10)。<br>表示表格的宽度和高度。<br>接下来是n行，每行m个正整数，用空格分开。每个整数不大于10000。 </p><h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>输出一个整数，表示在所有解中，包含左上角的分割区可能包含的最小的格子数目。 </p><h4 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入"></a>样例输入</h4><div class="hljs"><pre><code class="hljs text">3  3 10  1  52 20  30  1 1  2  3</code></pre></div><p>样例输出</p><div class="hljs"><pre><code class="hljs text">3</code></pre></div><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>首先先判断矩阵总和是奇数还是偶数,如果是奇数的话直接输出0</li><li>对矩阵每一个点都进行一次深搜,出口就是当sum(当前总和)等于矩阵一半的时候,且包含左上角格子</li><li>搜完一个点之后记得回溯,清楚标记</li></ol><h4 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-keyword">int</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> vis[<span class="hljs-number">15</span>][<span class="hljs-number">15</span>];<span class="hljs-keyword">int</span> m, n, sum, half, ans = <span class="hljs-number">250</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> ac, <span class="hljs-keyword">int</span> <span class="hljs-built_in">step</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span> (ac == half) &#123;        <span class="hljs-keyword">if</span>(vis[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span>(ans &gt; <span class="hljs-built_in">step</span>) ans = <span class="hljs-built_in">step</span>;            <span class="hljs-keyword">return</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ac &lt; half) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            <span class="hljs-keyword">int</span> nx = x + dir[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> ny = y + dir[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; <span class="hljs-number">0</span> &lt;= ny &amp;&amp; ny &lt; m &amp;&amp; vis[nx][ny] == <span class="hljs-number">0</span>) &#123;                vis[nx][ny] = <span class="hljs-number">1</span>;                dfs(nx, ny, ac + <span class="hljs-built_in">map</span>[nx][ny], <span class="hljs-built_in">step</span> + <span class="hljs-number">1</span>);                vis[nx][ny] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;            <span class="hljs-built_in">cin</span> &gt;&gt; <span class="hljs-built_in">map</span>[i][j];            sum += <span class="hljs-built_in">map</span>[i][j];        &#125;    &#125;    <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"0"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        half = sum / <span class="hljs-number">2</span>;        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;                vis[i][j] = <span class="hljs-number">1</span>;                dfs(i, j, <span class="hljs-built_in">map</span>[i][j], <span class="hljs-number">1</span>);                vis[i][j] = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(ans == <span class="hljs-number">250</span>) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"0"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><hr><h2 id="大臣的旅费"><a href="#大臣的旅费" class="headerlink" title="大臣的旅费"></a>大臣的旅费</h2><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>很久以前，T王国空前繁荣。为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。<br>为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。<br>J是T国重要大臣，他巡查于各大城市之间，体察民情。所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。他有一个钱袋，用于存放往来城市间的路费。<br>聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。<br>J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？</p><h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>输入的第一行包含一个整数n，表示包括首都在内的T王国的城市数<br>城市从1开始依次编号，1号城市为首都。<br>接下来n-1行，描述T国的高速路（T国的高速路一定是n-1条）<br>每行三个整数Pi,  Qi,  Di，表示城市Pi和城市Qi之间有一条高速路，长度为Di千米。 </p><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>输出一个整数，表示大臣J最多花费的路费是多少。 </p><h4 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入"></a>样例输入</h4><div class="hljs"><pre><code class="hljs text">5 1  2  21  3  12  4  52  5  4</code></pre></div><p>样例输出</p><div class="hljs"><pre><code class="hljs text">135</code></pre></div><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>首先从u dfs找到最远点v ，然后从v开始，dfs找到的最远点一定是树的直径</li></ol><p>证明：    </p><div class="hljs"><pre><code>如果u-&gt;v 和树的直径没有公共点，则可以从树的直径终点到u引一条边，树直径变长了，矛盾假设交点为k，那么k-&gt;v (或者就是v本身) 一定是树直径的一部分，（最优子结构）这样就证明了v一定在树的直径的端点处，（为什么是端点，因为u-&gt;v是最远的，一定是叶子节点）</code></pre></div><ol start="2"><li>其实可以直接把每个点都深搜一遍,也能找到最长的一条路径,不过这个方法可能会超时</li><li>还有一点需要注意,由于题目测试数据的原因,不能用邻接矩阵,只能用邻接表<h4 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>    <span class="hljs-keyword">int</span> v, e, w;&#125;;<span class="hljs-built_in">vector</span>&lt;Edge&gt; <span class="hljs-built_in">map</span>[<span class="hljs-number">10005</span>];<span class="hljs-keyword">int</span> vis[<span class="hljs-number">10005</span>];<span class="hljs-keyword">int</span> ans, imax = <span class="hljs-number">-999999</span>;<span class="hljs-keyword">int</span> n, p, q, d, <span class="hljs-built_in">point</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;    vis[start] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(sum &gt; imax) &#123;        imax = sum;        <span class="hljs-built_in">point</span> = start;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">map</span>[start].<span class="hljs-built_in">size</span>(); i++) &#123;        Edge e = <span class="hljs-built_in">map</span>[start][i];        <span class="hljs-keyword">if</span>(vis[e.e] == <span class="hljs-number">0</span>) &#123;            sum += e.w;            dfs(e.e, sum);            sum -= e.w;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cal</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= imax; i++) &#123;        ans += (i + <span class="hljs-number">10</span>);    &#125;    <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;        <span class="hljs-built_in">cin</span> &gt;&gt; p &gt;&gt; q &gt;&gt; d;        Edge e;        e.v = p; e.e = q; e.w = d;        <span class="hljs-built_in">map</span>[p].push_back(e);        e.v = q; e.e = p;        <span class="hljs-built_in">map</span>[q].push_back(e);    &#125;    dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vis));    dfs(<span class="hljs-built_in">point</span>, <span class="hljs-number">0</span>);    cal();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.StringTokenizer;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reader</span> </span>&#123;        <span class="hljs-keyword">static</span> BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">static</span> StringTokenizer tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(<span class="hljs-string">""</span>);        <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">nextLine</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> reader.readLine();        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">while</span> (!tokenizer.hasMoreTokens()) &#123;                tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(reader.readLine());            &#125;            <span class="hljs-keyword">return</span> tokenizer.nextToken();        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextInt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Integer.parseInt(next());        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">nextDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Double.parseDouble(next());        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            reader.close();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> PrintStream(System.out));        <span class="hljs-keyword">int</span> n = Reader.nextInt();        Solution s = <span class="hljs-keyword">new</span> Solution(n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            s.addEdge(Reader.nextInt(), Reader.nextInt(), Reader.nextInt());        &#125;        out.println(s.dfs());        out.flush();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;        <span class="hljs-keyword">int</span> v, e, w;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> w)</span> </span>&#123;            <span class="hljs-keyword">this</span>.v = v;            <span class="hljs-keyword">this</span>.e = e;            <span class="hljs-keyword">this</span>.w = w;        &#125;    &#125;    <span class="hljs-keyword">private</span> List&lt;Edge&gt; []map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V, ans = Integer.MIN_VALUE, cnt;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> []vis;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V)</span> </span>&#123;        <span class="hljs-keyword">this</span>.V = V;        <span class="hljs-keyword">this</span>.vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V + <span class="hljs-number">5</span>];        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> ArrayList[<span class="hljs-number">10005</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= V; i++) &#123;            map[i] = <span class="hljs-keyword">new</span> ArrayList&lt;Edge&gt;();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> w)</span> </span>&#123;        map[v].add(<span class="hljs-keyword">new</span> Edge(v, e, w));        map[e].add(<span class="hljs-keyword">new</span> Edge(e, v, w));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;        dfs(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);        Arrays.fill(vis, <span class="hljs-number">0</span>);        dfs(cnt, <span class="hljs-number">0</span>);        <span class="hljs-keyword">int</span> cs = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= ans; i++) &#123;            cs += (<span class="hljs-number">10</span> + i);        &#125;        <span class="hljs-keyword">return</span> cs;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;        vis[cur] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (sum &gt; ans) &#123;            ans = sum;            cnt = cur;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; map[cur].size(); i++) &#123;            Edge e = map[cur].get(i);            <span class="hljs-keyword">if</span> (vis[e.e] == <span class="hljs-number">0</span>) dfs(e.e, sum + e.w);        &#125;    &#125;&#125;</code></pre></div><hr><h2 id="水图"><a href="#水图" class="headerlink" title="水图"></a>水图</h2><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>小w不会离散数学，所以她van的图论游戏是送分的<br>小w有一张n个点n-1条边的无向联通图,每个点编号为1~n,每条边都有一个长度<br>小w现在在点x上<br>她想知道从点x出发经过每个点至少一次，最少需要走多少路</p><h4 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h4><p>第一行两个整数 n,x,代表点数,和小w所处的位置<br>第二到第n行,每行三个整数 u,v,w,表示u和v之间有一条长为w的道路</p><h4 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h4><p>一个数表示答案</p><h4 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h4><div class="hljs"><pre><code class="hljs text">3 11 2 12 3 1</code></pre></div><h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><div class="hljs"><pre><code class="hljs text">2</code></pre></div><h4 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h4><blockquote><p>1 ≤ n ≤ 50000 , 1 ≤ w ≤ 2147483647</p></blockquote><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>从一个结点出发要遍历所有的结点，所以每条路径都要走两次，而只有一条路径只用走一次，所以我们只需要找出最长的一条路径让他只走一次就好了，所以最后的结果就是所有边的权值之和的二倍减去最长的一条路径。</p><h4 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.StringTokenizer;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/1/22 13:09</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">reader</span> </span>&#123;        <span class="hljs-keyword">static</span> BufferedReader read = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));        <span class="hljs-keyword">static</span> StringTokenizer tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(<span class="hljs-string">""</span>);        <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">nextLine</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> read.readLine();        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">while</span> (!tokenizer.hasMoreTokens()) &#123;                tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(read.readLine());            &#125;            <span class="hljs-keyword">return</span> tokenizer.nextToken();        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextInt</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Integer.parseInt(next());        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">nextDouble</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            <span class="hljs-keyword">return</span> Double.parseDouble(next());        &#125;        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            read.close();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-keyword">int</span> n = reader.nextInt();        <span class="hljs-keyword">int</span> x = reader.nextInt();        Solution_6 solution_6 = <span class="hljs-keyword">new</span> Solution_6(n);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;            solution_6.addEdge(reader.nextInt(), reader.nextInt(), reader.nextInt());        &#125;        solution_6.dfs(x);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution_6</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> </span>&#123;        <span class="hljs-keyword">int</span> v, e;        <span class="hljs-keyword">long</span> w;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">long</span> w)</span> </span>&#123;            <span class="hljs-keyword">this</span>.v = v;            <span class="hljs-keyword">this</span>.e = e;            <span class="hljs-keyword">this</span>.w = w;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> ans;    <span class="hljs-keyword">private</span> LinkedList&lt;Edge&gt; []map;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> []vis;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sum;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Solution_6</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> LinkedList[n + <span class="hljs-number">5</span>];        <span class="hljs-keyword">this</span>.vis = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">5</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            map[i] = <span class="hljs-keyword">new</span> LinkedList&lt;Edge&gt;();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">long</span> w)</span> </span>&#123;        sum += w;        map[v].add(<span class="hljs-keyword">new</span> Edge(v, e, w));        map[e].add(<span class="hljs-keyword">new</span> Edge(e, v, w));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-keyword">this</span>.search(start, <span class="hljs-number">0</span>);        System.out.println(<span class="hljs-number">2</span> * sum - ans);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">long</span> dis)</span> </span>&#123;        vis[cur] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(map[cur].size() == <span class="hljs-number">1</span> &amp;&amp; vis[map[cur].get(<span class="hljs-number">0</span>).e] == <span class="hljs-number">1</span>) &#123;            ans = Math.max(ans, dis);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; map[cur].size(); i++) &#123;            Edge e = map[cur].get(i);            <span class="hljs-keyword">if</span>(vis[e.e] == <span class="hljs-number">0</span>) &#123;                search(e.e, dis + map[cur].get(i).w);            &#125;        &#125;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>刷题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-红黑树</title>
    <link href="/2019/10/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2019/10/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>红黑树是二叉查找树中的一种，要学习红黑树，首先要先了解什么是二叉查找树，这里可以看我的另外一边文章 <a href="https://www.lwjppz.cn/BST-implement-Java.html" target="_blank" rel="noopener"> 二叉排序（搜索）树</a></p><p>BST存在的问题：<br>依次插入如下五个节点：7,6,5,4,3。依照二叉查找树的特性，结果会变成一下的样子</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/3490195d7e3a405c97c34d391c71f09b.png" srcset="/img/loading.gif" alt=""></p><p>这样的形态虽然也符合二插查找树的特性，但是查找的性能大打折扣，几乎变成了线性。所以为了解决这一问题，红黑树就应运而生。</p><h4 id="红黑树定义和性质"><a href="#红黑树定义和性质" class="headerlink" title="红黑树定义和性质"></a>红黑树定义和性质</h4><p>红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li><strong>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</strong></li></ul><p>下图中这棵树，就是一颗典型的红黑树：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/eefb5a3397ef4089b356e7c9f0938a8d.jpeg" srcset="/img/loading.gif" alt=""></p><p>虽然红黑树的规则限制有点多，但正是这些限制才保证了红黑树的自平衡，红黑树从根到叶子的最长路径不会超过最短路径的两倍</p><h4 id="红黑树插入和删除节点"><a href="#红黑树插入和删除节点" class="headerlink" title="红黑树插入和删除节点"></a>红黑树插入和删除节点</h4><p>党插入和删除节点时，红黑树的规则可能会被打破，这时候就需要做出一些调整，来继续维持我们的规则。</p><p>什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的例子：</p><p>1.向原红黑树插入值为14的新节点：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/1f1a6ca2e3674e71bb5e815c3d042ee5.jpeg" srcset="/img/loading.gif" alt=""></p><p>2.向原红黑树插入值为21的新节点：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/c0042741a40d47249e287908c16a9203.jpeg" srcset="/img/loading.gif" alt=""></p><p>由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。</p><p>那么，我们需要做出怎样的调整，才能保证红黑树始终是一颗红黑树呢？</p><p>调整的方法有两种：</p><ul><li>变色</li><li>旋转<br>而旋转由分为：左旋转和右旋转</li></ul><p><strong>变色：</strong></p><p>为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。</p><p>下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/142bd79263094ec89bccb2cfd8316113.png" srcset="/img/loading.gif" alt=""></p><p>但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/3e651c84a1494495a73287df0ca92216.jpeg" srcset="/img/loading.gif" alt=""></p><p>此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/a8c4ce5620424588bdbee69f4bb3d527.png" srcset="/img/loading.gif" alt=""></p><p><strong>左旋转：</strong></p><p>逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/b3cd82550b29445eac5b6e6b0f40f03c.png" srcset="/img/loading.gif" alt=""></p><p>图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。</p><p><strong>右旋转：</strong></p><p>顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/c739da55ba784729919bc18b57c3a5c3.png" srcset="/img/loading.gif" alt=""></p><p>图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。</p><p>有点复杂，红黑输的插入和删除包含很多种情况，每一种情况都有不同的处理方式，下面举个例子体会一下：</p><p>我们以刚才插入节点21的情况为例：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/7a4055b4eaa14fd097ffa241abd86032.jpeg" srcset="/img/loading.gif" alt=""></p><p>首先，我们需要做的是变色，把节点25及其下方的节点变色：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/a0c2409f6c7d4c468a3d1c80c18ebe9b.jpeg" srcset="/img/loading.gif" alt=""></p><p>此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。</p><p>变色已无法解决问题，我们把节点13看做X，把节点17看做Y，像刚才的示意图那样进行左旋转：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/cb7731c2eb4e4e2b839004e3dcaf7126.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/9f6949f1ca624323ad26bd474912571a.jpeg" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/d7da48b838514b33bd8b44ab1b55c9e1.jpeg" srcset="/img/loading.gif" alt=""></p><p>由于根节点必须是黑色节点，所以需要变色，变色结果如下：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/d32de019907c4e9a9c2e3490d66677de.jpeg" srcset="/img/loading.gif" alt=""></p><p>这样就结束了吗？并没有。因为其中两条路径(17 -&gt; 8 -&gt; 6 -&gt; NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。</p><p>这时候我们需要把节点13看做X，节点8看做Y，像刚才的示意图那样进行右旋转：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/2e7e68bb13de4558a66b0a1262e072e7.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/1fdcb0466c7a4ecc84b54cb701781243.jpeg" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/b3fcbe987f214340b0b03d129b2a2059.jpeg" srcset="/img/loading.gif" alt=""></p><p>最后根据规则来进行变色：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/79bbe75c48da4a7492c21af0e18065a5.jpeg" srcset="/img/loading.gif" alt=""></p><p>如此一来，我们的红黑树变得重新符合规则。这一个例子的调整过程比较复杂，经历了如下步骤：</p><p>变色 -&gt; 左旋转 -&gt; 变色 -&gt; 右旋转 -&gt; 变色</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>红黑树的应用很多，JDK的集合类TreeMap和TreeSet底层就是红黑树实现的，在Java8中，HashMap也用到了红黑树。</p><p>红黑树在最坏的情况下，基本的动态几何操作的时间均为O（lgn）。</p><p>转载于 <a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment" target="_blank" rel="noopener">漫画:什么是红黑树</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9月份学习总结</title>
    <link href="/2019/09/30/9%E6%9C%88%E4%BB%BD%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2019/09/30/9%E6%9C%88%E4%BB%BD%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>时间过得很快，不知不觉已经上了一个月了，这一个月的学习过程中，自己找到了自身的许多不足，也幸好发现了这些不足，才能拼命的改正过来</p><h3 id="这学期主要的课程："><a href="#这学期主要的课程：" class="headerlink" title="这学期主要的课程："></a>这学期主要的课程：</h3><ol><li>数据结构与算法</li><li>数据库原理与应用</li><li>网页制作与实践</li><li>C#程序设计</li></ol><p>当时看到这些课程的时候，简直惊呆了， 一个学期要学的东西怎么这么多</p><p>虽然有一些课程自己已经学过的了，但是由于学艺不精，所以再次学习的时候发现有很多其实是自己不懂的<br>在这个月的努力下，数据结构基本过了一遍，数据库原理与应用在自己自学下也有了一些成果。<br>回想暑假自己写的一个博客系统，里面用到的SQL个工具类，既浪费了时间，而且效率非常低。导致响应时间很长。</p><p>还有CSS和JS，我认为我和前端应该有仇，学了一年的CSS和JS，但是现在还是懵懵懂懂的状态，写个网页还是迷迷糊糊的，而且，不知道为什么，学了总是忘，可能和我没有经常写有关吧.所以这个东西只能靠今后多练了</p><p>还有最想吐槽的就是C#，不知道老师安排我们学C#是什么意思，既然以后的方向是Java，为什么还要学习C#，贼烦学这个，导致自己学习其他的东西的时间被挤了。</p><p>最近几天准备开始系统的学习Linux，作为一个合格的后端程序员，Linux知识还是必不可少的</p>]]></content>
    
    
    <categories>
      
      <category>个人总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人总结</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性表 - Java实现</title>
    <link href="/2019/09/09/%E7%BA%BF%E6%80%A7%E8%A1%A8---Java%E5%AE%9E%E7%8E%B0/"/>
    <url>/2019/09/09/%E7%BA%BF%E6%80%A7%E8%A1%A8---Java%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>老师布置的作业,用Java实现线性表,自己写了一个,小小的测试了一下,可能我不够细心,没发现什么bug.如果有发现什么问题,欢迎指出(✪ω✪)</p><p>代码:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;                      <span class="hljs-comment">//  判断线性表是否为空</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span></span>;                           <span class="hljs-comment">//  求线性表长度</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;                           <span class="hljs-comment">//  清空线性表</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T elem)</span></span>;                       <span class="hljs-comment">//  向表尾添加元素</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(List&lt;? extends T&gt; list)</span></span>;    <span class="hljs-comment">//  合并两个表</span>    <span class="hljs-function">T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;                       <span class="hljs-comment">//  获得指定位置的值</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, T elem)</span></span>;         <span class="hljs-comment">//  向指定位置插入元素</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, T elem)</span></span>;        <span class="hljs-comment">//  替换指定位置的值</span>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(T elem)</span></span>;                    <span class="hljs-comment">//  返回元素在表中的位置</span>    <span class="hljs-function">T <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>;                    <span class="hljs-comment">//  删除指定位置的值</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T elem)</span></span>;               <span class="hljs-comment">//  判断值是否在表中</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeqList</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> defaultCapacity = <span class="hljs-number">10</span>;       <span class="hljs-comment">//  默认容器大小</span>    <span class="hljs-keyword">private</span> Object[] elemData;              <span class="hljs-comment">//  存储元素的容器</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;                       <span class="hljs-comment">//  线性表长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqList</span><span class="hljs-params">()</span> </span>&#123;        elemData = <span class="hljs-keyword">new</span> Object[defaultCapacity];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        elemData = <span class="hljs-keyword">new</span> Object[initialCapacity];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeqList</span><span class="hljs-params">(Object[] arr)</span> </span>&#123;        <span class="hljs-keyword">this</span>.elemData = <span class="hljs-keyword">new</span> Object[arr.length];        System.arraycopy(arr, <span class="hljs-number">0</span>, elemData, <span class="hljs-number">0</span>, arr.length);        size = arr.length - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判空</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获得表长</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清空</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        elemData = <span class="hljs-keyword">new</span> Object[defaultCapacity];        size = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T elem)</span> </span>&#123;        <span class="hljs-keyword">if</span> (size &gt; elemData.length) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"顺序表已满!"</span>);        &#125;        elemData[size++] = elem;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(List&lt;? extends T&gt; list)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.length(); i++) &#123;            insert(<span class="hljs-keyword">this</span>.length(), list.get(i));        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获得顺序表指定位置的元素</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(index + <span class="hljs-string">"超出线性表范围"</span>);        &#125;        <span class="hljs-keyword">return</span> (T) elemData[index];    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 向指定位置插入元素,如果表满了,则进行扩容操作</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> elem</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, T elem)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(index + <span class="hljs-string">"超出线性表范围"</span>);        &#125;        Object[] objects = elemData;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 表满了,扩容</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">if</span> (size == elemData.length) &#123;            elemData = <span class="hljs-keyword">new</span> Object[objects.length * <span class="hljs-number">2</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; index; j++) &#123;                <span class="hljs-keyword">this</span>.elemData[j] = objects[j];            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size - <span class="hljs-number">1</span>; i &gt;= index; i--) &#123;            elemData[i + <span class="hljs-number">1</span>] = objects[i];        &#125;        elemData[index] = elem;        size++;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 替换指定位置的元素</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> elem</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, T elem)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(index + <span class="hljs-string">"超出线性表范围"</span>);        &#125;        elemData[index] = elem;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获得指定元素第一次出现的位置</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> elem</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(T elem)</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            <span class="hljs-keyword">if</span> (elemData[i].equals(elem)) &#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除表中指定位置的元素</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(index + <span class="hljs-string">"超出线性表范围"</span>);        &#125;        T old = (T) <span class="hljs-keyword">this</span>.elemData[index];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = index; j &lt; size - <span class="hljs-number">1</span>; j++) &#123;            <span class="hljs-keyword">this</span>.elemData[j] = <span class="hljs-keyword">this</span>.elemData[j + <span class="hljs-number">1</span>];        &#125;        <span class="hljs-comment">//将表的末尾元素置空</span>        <span class="hljs-keyword">this</span>.elemData[<span class="hljs-keyword">this</span>.size - <span class="hljs-number">1</span>] = <span class="hljs-keyword">null</span>;        size--;        <span class="hljs-keyword">return</span> old;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断表中是否包含此元素</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> elem</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(T elem)</span> </span>&#123;        <span class="hljs-keyword">return</span> indexOf(elem) != -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">public</span> Object[] toArray() &#123;        Object[] arr = <span class="hljs-keyword">new</span> Object[<span class="hljs-keyword">this</span>.length()];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            arr[i] = elemData[i];        &#125;        <span class="hljs-keyword">return</span> arr;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将线性表反转</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object[] reverseList(Object[] list) &#123;        <span class="hljs-comment">//计算出要移动元素的长度</span>        <span class="hljs-keyword">int</span> len = list.length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? list.length / <span class="hljs-number">2</span> : list.length / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            Object temp = list[list.length - i - <span class="hljs-number">1</span>];            list[list.length - i - <span class="hljs-number">1</span>] = list[i];            list[i] = temp;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        sb.append(<span class="hljs-string">"["</span>);        sb.append(elemData[<span class="hljs-number">0</span>]);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-keyword">this</span>.size; i++)            sb.append(<span class="hljs-string">", "</span> + <span class="hljs-keyword">this</span>.elemData[i]);        sb.append(<span class="hljs-string">"]"</span>);        <span class="hljs-keyword">return</span> sb.toString();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.size; i++)&#123;            <span class="hljs-keyword">if</span>(elemData[i] != <span class="hljs-keyword">null</span>)            System.out.println(elemData[i]);        &#125;    &#125;&#125;</code></pre></div><p>排序顺序表:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortedSeqList</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;? <span class="hljs-title">super</span> <span class="hljs-title">T</span>&gt;&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">SeqList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SortedSeqList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SortedSeqList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;        <span class="hljs-keyword">super</span>(initialCapacity);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SortedSeqList</span><span class="hljs-params">(Object[] arr)</span></span>&#123;        <span class="hljs-keyword">super</span>(arr);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 插入元素,按照元素升序排列</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> elem</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(T elem)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) &#123;            <span class="hljs-keyword">this</span>.insert(<span class="hljs-number">0</span>, elem);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> index = <span class="hljs-keyword">this</span>.length();            <span class="hljs-comment">//找出待插入的位置</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length(); i++) &#123;                <span class="hljs-keyword">if</span> (elem.compareTo(<span class="hljs-keyword">this</span>.get(i)) &lt; <span class="hljs-number">0</span>) &#123;                    index = i;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            <span class="hljs-comment">//调用父类的插入方法</span>            <span class="hljs-keyword">this</span>.insert(index, elem);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 由于线性表有序,则使用二分查找提高查找效率</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> elem</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(T elem)</span> </span>&#123;        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> high = <span class="hljs-keyword">this</span>.length() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;            mid = low + ((high - low) / <span class="hljs-number">2</span>);            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.get(mid).compareTo(elem) &lt; <span class="hljs-number">0</span>) &#123;                low = mid + <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.get(mid).compareTo(elem) &gt; <span class="hljs-number">0</span>) &#123;                high = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> mid;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> SortedSeqList&lt;T&gt; <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(SortedSeqList&lt;T&gt; another)</span> </span>&#123;                Object[] arr = <span class="hljs-keyword">new</span> Object[<span class="hljs-keyword">this</span>.length() + another.length()];        <span class="hljs-comment">/**</span><span class="hljs-comment">         * System.arraycopy()</span><span class="hljs-comment">         * 参数: Object src,  int srcPos, Object dest, int destPos,int length</span><span class="hljs-comment">         * src 源数组</span><span class="hljs-comment">         * srcpos 源数组起始位置</span><span class="hljs-comment">         * dest 目标数组</span><span class="hljs-comment">         * destPos 目标数组起始位置</span><span class="hljs-comment">         * length 要进行复制的长度</span><span class="hljs-comment">         */</span>        System.arraycopy(<span class="hljs-keyword">this</span>.toArray(), <span class="hljs-number">0</span>, arr, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.length());        <span class="hljs-comment">//也可以使用下面的</span><span class="hljs-comment">//        for(int i = 0; i &lt; this.length(); i++)&#123;</span><span class="hljs-comment">//            arr[i] = this.get(i);</span><span class="hljs-comment">//        &#125;</span>                SortedSeqList&lt;T&gt; new_s = <span class="hljs-keyword">new</span> SortedSeqList&lt;&gt;(arr);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; another.length(); i++) &#123;            new_s.insert(another.get(i));        &#125;                <span class="hljs-keyword">return</span> new_s;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">remove</span><span class="hljs-params">(T elem)</span> </span>&#123;        <span class="hljs-keyword">int</span> index = binarySearch(elem);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.remove(index);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SortedSeqList&lt;Student&gt; s = <span class="hljs-keyword">new</span> SortedSeqList&lt;&gt;();        s.insert(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"20180861201"</span>, <span class="hljs-string">"力尚龙"</span>, <span class="hljs-string">"男"</span>));        s.insert(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"20180861229"</span>, <span class="hljs-string">"任德祺"</span>, <span class="hljs-string">"男"</span>));        s.insert(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"20180861202"</span>, <span class="hljs-string">"孔德水"</span>, <span class="hljs-string">"男"</span>));                System.out.println(<span class="hljs-string">"顺序表一:"</span>);        s.Print();                System.out.println();        SortedSeqList&lt;Student&gt; q = <span class="hljs-keyword">new</span> SortedSeqList&lt;&gt;();        q.insert(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"20180861203"</span>, <span class="hljs-string">"林宇轩"</span>, <span class="hljs-string">"男"</span>));        q.insert(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"20180861225"</span>, <span class="hljs-string">"游章勋"</span>, <span class="hljs-string">"男"</span>));        q.insert(<span class="hljs-keyword">new</span> Student(<span class="hljs-string">"20180861224"</span>, <span class="hljs-string">"蔡凯洲"</span>, <span class="hljs-string">"男"</span>));               System.out.println(<span class="hljs-string">"顺序表二:"</span>);        q.Print();        System.out.println();        SortedSeqList&lt;Student&gt; mergeTwoLists = s.mergeTwoLists(q);        System.out.println(<span class="hljs-string">"两个排序顺序表合并后:"</span>);        mergeTwoLists.Print();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树实现 - Java</title>
    <link href="/2019/08/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0---Java/"/>
    <url>/2019/08/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0---Java/</url>
    
    <content type="html"><![CDATA[<p>写这篇完全就是为了后面的作业用的φ(&gt;ω&lt;*) ,代码都有测试过,虽然目前没有发现什么bug.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">import</span> java.util.Stack;<span class="hljs-comment">/**</span><span class="hljs-comment"> * author      : lwj</span><span class="hljs-comment"> * createTime  : 2019/2/15 20:07</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> Node&lt;T&gt; root;   <span class="hljs-comment">//  根结点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BinaryTree</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取树的根结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">getRoot</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断树是否为空</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> root == <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 插入结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> parentItem 父结点的值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> direction  -1表示左,1表示右</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T item, T parentItem, <span class="hljs-keyword">int</span> direction)</span> </span>&#123;        Node&lt;T&gt; new_node = <span class="hljs-keyword">new</span> Node&lt;T&gt;(item, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            root = new_node;        &#125; <span class="hljs-keyword">else</span> &#123;            Node&lt;T&gt; parentNode = find(parentItem);            <span class="hljs-keyword">if</span> (direction == -<span class="hljs-number">1</span>) &#123;                new_node.left = parentNode.left;                parentNode.left = new_node;                new_node.parent = parentNode;            &#125;            <span class="hljs-keyword">if</span> (direction == <span class="hljs-number">1</span>) &#123;                new_node.right = parentNode.right;                parentNode.right = new_node;                new_node.parent = parentNode;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 向指定结点插入左孩子</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> parent</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertLeft</span><span class="hljs-params">(T parent, T item)</span> </span>&#123;        Node&lt;T&gt; par_node = find(parent);        Node&lt;T&gt; left_node = <span class="hljs-keyword">new</span> Node&lt;T&gt;(item, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (par_node.left != <span class="hljs-keyword">null</span>) &#123;            left_node.left = par_node.left;            par_node.left = left_node;            par_node.left.parent = left_node;            left_node.parent = par_node;        &#125; <span class="hljs-keyword">else</span> &#123;            par_node.left = left_node;            left_node.parent = par_node;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 向指定结点插入右孩子</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> parent</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertRight</span><span class="hljs-params">(T parent, T item)</span> </span>&#123;        Node&lt;T&gt; par_node = find(parent);        Node&lt;T&gt; right_node = <span class="hljs-keyword">new</span> Node&lt;T&gt;(item, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (par_node.right != <span class="hljs-keyword">null</span>) &#123;            right_node.right = par_node.right;            par_node.right = right_node;            par_node.right.parent = right_node;            right_node.parent = par_node;        &#125; <span class="hljs-keyword">else</span> &#123;            par_node.right = right_node;            right_node.parent = par_node;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查找指定结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">find</span><span class="hljs-params">(T item)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find(root, item);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">find</span><span class="hljs-params">(Node&lt;T&gt; root, T item)</span> </span>&#123;        Queue&lt;Node&lt;T&gt;&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&lt;T&gt;&gt;();        Node&lt;T&gt; q_node = <span class="hljs-keyword">null</span>;        queue.offer(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            q_node = queue.poll();            <span class="hljs-keyword">if</span> (q_node.item.equals(item)) &#123;                <span class="hljs-keyword">return</span> q_node;            &#125;            <span class="hljs-keyword">if</span> (q_node.left != <span class="hljs-keyword">null</span>) &#123;                queue.offer(q_node.left);            &#125;            <span class="hljs-keyword">if</span> (q_node.right != <span class="hljs-keyword">null</span>) &#123;                queue.offer(q_node.right);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">(T item)</span> </span>&#123;        Node&lt;T&gt; temp_node = find(item);        <span class="hljs-keyword">if</span> (temp_node == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        Node&lt;T&gt; par = temp_node.parent;        <span class="hljs-comment">//如果要删除的是根结点</span>        <span class="hljs-keyword">if</span> (temp_node.item == <span class="hljs-keyword">this</span>.root.item) &#123;            clear();        &#125;        <span class="hljs-comment">//左子树</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (par.left.item.equals(temp_node.item)) &#123;            par.left = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">//右子树</span>        <span class="hljs-keyword">else</span> &#123;            par.right = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 清空树</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.root = <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获得二叉树的高</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getHeight(<span class="hljs-keyword">this</span>.root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(Node&lt;T&gt; root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> leftH = getHeight(root.left);            <span class="hljs-keyword">int</span> rightH = getHeight(root.right);            <span class="hljs-keyword">return</span> (leftH &gt; rightH ? leftH : rightH) + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 求根结点到指定结点的路径</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rootToNode</span><span class="hljs-params">(T item)</span> </span>&#123;        Node&lt;T&gt; p_node = find(item);        <span class="hljs-keyword">if</span> (p_node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">this</span>.rootToNode(p_node);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rootToNode</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x.parent != <span class="hljs-keyword">null</span>) &#123;            rootToNode(x.parent);            System.out.print(<span class="hljs-string">"-&gt;"</span> + x.item);        &#125; <span class="hljs-keyword">else</span> &#123;            System.out.print(x.item);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取左子树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">getLeft</span><span class="hljs-params">(T item)</span> </span>&#123;        Node&lt;T&gt; p_node = find(item);        <span class="hljs-keyword">return</span> p_node == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : p_node.left;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取右子树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">getRight</span><span class="hljs-params">(T item)</span> </span>&#123;        Node&lt;T&gt; p_node = find(item);        <span class="hljs-keyword">return</span> p_node == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : p_node.right;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 统计叶子结点的个数</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">statisticsLeafNodeCount</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.statisticsLeafNodeCount(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">statisticsLeafNodeCount</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span> &amp;&amp; x.right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            count = statisticsLeafNodeCount(x.left) + statisticsLeafNodeCount(x.right);        &#125;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断是否是叶子结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLeafNode</span><span class="hljs-params">(T item)</span> </span>&#123;        Node&lt;T&gt; p_node = find(item);        <span class="hljs-keyword">if</span> (p_node.left == <span class="hljs-keyword">null</span> &amp;&amp; p_node.right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取所有结点个数</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">statisticsNodeCount</span><span class="hljs-params">()</span> </span>&#123;        Node&lt;T&gt; p_node = root;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.statisticsNodeCount(p_node);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">statisticsNodeCount</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> statisticsNodeCount(x.left) + statisticsNodeCount(x.right) + <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将广义表转换为二叉树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> gLists</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createBinTreeByGLists</span><span class="hljs-params">(String gLists)</span> </span>&#123;        <span class="hljs-keyword">this</span>.root = (Node&lt;T&gt;) <span class="hljs-keyword">this</span>.createByGList(gLists);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;Character&gt; <span class="hljs-title">createByGList</span><span class="hljs-params">(String gLists)</span> </span>&#123;        Node&lt;Character&gt; root_node = <span class="hljs-keyword">null</span>;        Node&lt;Character&gt; curr_node = <span class="hljs-keyword">null</span>;        Stack&lt;Node&lt;Character&gt;&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&lt;Character&gt;&gt;();        <span class="hljs-keyword">int</span> flag = <span class="hljs-number">0</span>;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> left = <span class="hljs-number">1</span>;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> right = <span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; gLists.length(); i++) &#123;            <span class="hljs-keyword">char</span> ch = gLists.charAt(i);            <span class="hljs-keyword">switch</span> (ch) &#123;                <span class="hljs-keyword">case</span> <span class="hljs-string">'('</span>:                    flag = left;                    stack.push(curr_node);                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">','</span>:                    flag = right;                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">')'</span>:                    stack.pop();                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:                    <span class="hljs-keyword">break</span>;                <span class="hljs-keyword">default</span>:                    curr_node = <span class="hljs-keyword">new</span> Node&lt;Character&gt;(ch, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);                    <span class="hljs-keyword">if</span> (root_node == <span class="hljs-keyword">null</span>) &#123;                        root_node = curr_node;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;                            stack.peek().left = curr_node;                        &#125; <span class="hljs-keyword">else</span> &#123;                            stack.peek().right = curr_node;                        &#125;                    &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> root_node;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将二叉树表示为广义表</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toGeeneralizedList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.toGeeneralizedList(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toGeeneralizedList</span><span class="hljs-params">(Node&lt;T&gt; root)</span> </span>&#123;        System.out.print(root.item);        <span class="hljs-keyword">if</span> (root.left != <span class="hljs-keyword">null</span>) &#123;            System.out.print(<span class="hljs-string">"("</span>);            toGeeneralizedList(root.left);            <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span>) &#123;                System.out.print(<span class="hljs-string">",^)"</span>);            &#125;        &#125;        <span class="hljs-keyword">if</span> (root.right != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span>) &#123;                System.out.print(<span class="hljs-string">"(^"</span>);            &#125;            System.out.print(<span class="hljs-string">","</span>);            toGeeneralizedList(root.right);            System.out.print(<span class="hljs-string">")"</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断是否为完全二叉树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isCompleteTree(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(Node&lt;T&gt; root)</span> </span>&#123;        Node&lt;T&gt; p_node = <span class="hljs-keyword">null</span>;        Queue&lt;Node&lt;T&gt;&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&lt;T&gt;&gt;();        queue.offer(root);        <span class="hljs-keyword">while</span> ((p_node = queue.poll()) != <span class="hljs-keyword">null</span>) &#123;            queue.offer(p_node.left);            queue.offer(p_node.right);        &#125;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            p_node = queue.poll();            <span class="hljs-keyword">if</span> (p_node != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据后序和中序遍历建立二叉树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> post 后续遍历集合</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in   中序遍历集合</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 树的根结点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">buildTree</span><span class="hljs-params">(T[] post, T[] in)</span> </span>&#123;        <span class="hljs-keyword">int</span> len = in.length;        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>, post, in);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 递归构建树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inl</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inr</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> postl</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> postr</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> post</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> inl, <span class="hljs-keyword">int</span> inr, <span class="hljs-keyword">int</span> postl, <span class="hljs-keyword">int</span> postr, T[] post, T[] in)</span> </span>&#123;        <span class="hljs-keyword">if</span> (inl &gt; inr || postl &gt; postr) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        T val = post[postr];        <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inl; i &lt; inr + <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> (in[i] == val) &#123;                k = i;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        Node&lt;T&gt; root = <span class="hljs-keyword">new</span> Node&lt;T&gt;(val, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">// 第 4 个参数是计算出来的，依据：两边区间长度相等</span>        root.left = dfs(inl, k - <span class="hljs-number">1</span>, postl, k - <span class="hljs-number">1</span> - inl + postl, post, in);        <span class="hljs-comment">// 第 3 个参数是计算出来的，依据：两边区间长度相等</span>        root.right = dfs(k + <span class="hljs-number">1</span>, inr, postr + k - inr, postr - <span class="hljs-number">1</span>, post, in);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 前序遍历</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.preOrderTraverse(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">(Node&lt;T&gt; root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            System.out.print(root.item);            preOrderTraverse(root.left);            preOrderTraverse(root.right);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 前序遍历非递归</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderByStack</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.preOrderByStack(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderByStack</span><span class="hljs-params">(Node&lt;T&gt; root)</span> </span>&#123;        Stack&lt;Node&lt;T&gt;&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&lt;T&gt;&gt;();        Node&lt;T&gt; temp = root;        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> || !stack.empty())&#123;            <span class="hljs-keyword">if</span>(temp != <span class="hljs-keyword">null</span>)&#123;                System.out.print(temp.item);                stack.push(temp);                temp = temp.left;            &#125;<span class="hljs-keyword">else</span> &#123;                temp = stack.pop();                temp = temp.right;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 中序遍历</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.inOrderTraverse(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">(Node&lt;T&gt; root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            inOrderTraverse(root.left);            System.out.print(root.item);            inOrderTraverse(root.right);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 中序遍历非递归</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderByStack</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">this</span>.inOrderStack(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderStack</span><span class="hljs-params">(Node&lt;T&gt; root)</span></span>&#123;        Stack&lt;Node&lt;T&gt;&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;Node&lt;T&gt;&gt;();        Node&lt;T&gt; temp= root;        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> || !stack.empty())&#123;            <span class="hljs-keyword">if</span>(temp != <span class="hljs-keyword">null</span>)&#123;                stack.push(temp);                temp = temp.left;            &#125;<span class="hljs-keyword">else</span> &#123;                temp = stack.pop();                System.out.print(temp.item);                temp = temp.right;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 后序遍历</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.postOrderTraverse(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">(Node&lt;T&gt; root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            postOrderTraverse(root.left);            postOrderTraverse(root.right);            System.out.print(root.item);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 后序遍历非递归</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderByStack</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">this</span>.postOrderByStack(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderByStack</span><span class="hljs-params">(Node&lt;T&gt; root)</span></span>&#123;        Stack&lt;Node&lt;T&gt;&gt; stack  = <span class="hljs-keyword">new</span> Stack&lt;Node&lt;T&gt;&gt;();        Node&lt;T&gt; temp = root;        Node&lt;T&gt; lastNode = root;        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span> || !stack.empty())&#123;            <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>)&#123;                stack.push(temp);                temp = temp.left;            &#125;            temp = stack.peek();            <span class="hljs-keyword">if</span>(temp.right == <span class="hljs-keyword">null</span> || temp.right == lastNode)&#123;                System.out.print(temp.item);                stack.pop();                lastNode = temp;                temp = <span class="hljs-keyword">null</span>;            &#125;<span class="hljs-keyword">else</span> &#123;                temp = temp.right;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 层序遍历二叉树</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.levelOrderTraverse(root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelOrderTraverse</span><span class="hljs-params">(Node&lt;T&gt; root)</span> </span>&#123;        Node&lt;T&gt; temp = <span class="hljs-keyword">null</span>;        Queue&lt;Node&lt;T&gt;&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&lt;T&gt;&gt;();        queue.offer(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            temp = queue.poll();            System.out.print(temp.item);            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != temp.left)                queue.offer(temp.left);            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != temp.right) &#123;                queue.offer(temp.right);            &#125;        &#125;        System.out.println();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 树的结点类</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;        Node&lt;T&gt; left;        Node&lt;T&gt; right;        Node&lt;T&gt; parent;        T item;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(T item, Node&lt;T&gt; left, Node&lt;T&gt; right, Node&lt;T&gt; parent)</span> </span>&#123;            <span class="hljs-keyword">this</span>.left = left;            <span class="hljs-keyword">this</span>.right = right;            <span class="hljs-keyword">this</span>.parent = parent;            <span class="hljs-keyword">this</span>.item = item;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//        String str = "ABC.D.E..FG...H";</span><span class="hljs-comment">//        char[] arr = str.toCharArray();</span><span class="hljs-comment">//        BinaryTree&lt;Character&gt; binaryTree = new BinaryTree&lt;Character&gt;();</span><span class="hljs-comment">//        for (int i = 0; i &lt; arr.length; i++) &#123;</span><span class="hljs-comment">//            if (arr[i] != '.') &#123;</span><span class="hljs-comment">//                if (i % 2 == 0) &#123;</span><span class="hljs-comment">//                    binaryTree.put(arr[i], arr[(i - 1) / 2], 1);</span><span class="hljs-comment">//                &#125; else &#123;</span><span class="hljs-comment">//                    binaryTree.put(arr[i], arr[(i - 1) / 2], -1);</span><span class="hljs-comment">//                &#125;</span><span class="hljs-comment">//            &#125;</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//        binaryTree.rootToNode('L');</span><span class="hljs-comment">//        System.out.println(binaryTree.statisticsLeafNodeCount());</span><span class="hljs-comment">//        System.out.println(binaryTree.getHeight());</span><span class="hljs-comment">//        System.out.println(binaryTree.statisticsNodeCount());</span><span class="hljs-comment">//        System.out.println(binaryTree.isCompleteTree());</span><span class="hljs-comment">//        String str = "A(B(D(^,G),^),C(E,F))";</span><span class="hljs-comment">//        BinaryTree&lt;Character&gt; binaryTree = new BinaryTree&lt;Character&gt;();</span><span class="hljs-comment">//        binaryTree.createBinTreeByGLists(str);</span><span class="hljs-comment">//        binaryTree.inOrderTraverse();</span><span class="hljs-comment">//        Scanner sc = new Scanner(System.in);</span><span class="hljs-comment">//        int n = sc.nextInt();</span><span class="hljs-comment">//        Character[] post = new Character[n];</span><span class="hljs-comment">//        Character[] in = new Character[n];</span><span class="hljs-comment">//        for (int i = 0; i &lt; n; i++) &#123;</span><span class="hljs-comment">//            post[i] = String.valueOf(sc.nextInt()).charAt(0);</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//        for (int i = 0; i &lt; n; i++) &#123;</span><span class="hljs-comment">//            in[i] = String.valueOf(sc.nextInt()).charAt(0);</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//        System.out.print("Preorder:");</span><span class="hljs-comment">//        BinaryTree&lt;Character&gt; binaryTree = new BinaryTree&lt;&gt;();</span><span class="hljs-comment">//        binaryTree.preOrderTraverse(binaryTree.buildTree(post, in));</span><span class="hljs-comment">//        System.out.println();</span>    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-二叉排序（搜索）树</title>
    <link href="/2019/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%EF%BC%88%E6%90%9C%E7%B4%A2%EF%BC%89%E6%A0%91/"/>
    <url>/2019/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%EF%BC%88%E6%90%9C%E7%B4%A2%EF%BC%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="二叉排序树或者是一棵空树，或者是具有下列性质的二叉树："><a href="#二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：" class="headerlink" title="二叉排序树或者是一棵空树，或者是具有下列性质的二叉树："></a>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</h3><ol><li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ol><h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下:"></a>代码如下:</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BST</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;? <span class="hljs-title">super</span> <span class="hljs-title">T</span>&gt;&gt; </span>&#123;    <span class="hljs-keyword">private</span> Node&lt;T&gt; root;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BST</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(T item)</span> </span>&#123;        root = <span class="hljs-keyword">this</span>.put(root, item);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建二叉排序树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">put</span><span class="hljs-params">(Node&lt;T&gt; x, T item)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            x = <span class="hljs-keyword">new</span> Node&lt;T&gt;(item, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-keyword">if</span> (item.compareTo(x.item) &lt; <span class="hljs-number">0</span>) &#123;            x.left = put(x.left, item);        &#125; <span class="hljs-keyword">else</span> &#123;            x.right = put(x.right, item);        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">search</span><span class="hljs-params">(T s)</span> </span>&#123;        <span class="hljs-keyword">return</span> search(<span class="hljs-keyword">this</span>.root, s);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 递归查找要查找的值</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">search</span><span class="hljs-params">(Node&lt;T&gt; x, T s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (s.compareTo(x.item) &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> search(x.left, s);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.compareTo(x.item) &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> search(x.right, s);        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">min</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> min(root);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查找二叉排序树中值最小的结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">min</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-keyword">return</span> min(x.left);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> max(root);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查找二叉排序树中值最大的结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">max</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-keyword">return</span> max(x.right);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMin</span><span class="hljs-params">()</span> </span>&#123;        root = deleteMin(root);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除二叉排序树中的最小结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">deleteMin</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> x.right;        &#125;        x.left = deleteMin(x.left);        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(T s)</span> </span>&#123;        root = delete(root, s);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除结点，要分三种情况考虑</span><span class="hljs-comment">     * 1、如果要删除的结点是叶子结点，那么直接将它删去</span><span class="hljs-comment">     * 2、如果要删除的结点有左或右孩子，那么将此节点删去，用它的左或右孩子取代它</span><span class="hljs-comment">     * 3、如果要删除的结点有左右孩子，那么先查找此节点的右子树的最小结点，将此结点赋给要删除的那个节点，之后将此节点删除，然后将原来要删除结点的左右孩子分别赋给此节点；</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> s</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node&lt;T&gt; <span class="hljs-title">delete</span><span class="hljs-params">(Node&lt;T&gt; x, T s)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (s.compareTo(x.item) &lt; <span class="hljs-number">0</span>) &#123;            x.left = delete(x.left, s);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.compareTo(x.item) &gt; <span class="hljs-number">0</span>) &#123;            x.right = delete(x.right, s);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (x.left == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> x.right;            &#125;            <span class="hljs-keyword">if</span> (x.right == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> x.left;            &#125;            Node&lt;T&gt; temp = x;            x = min(temp.right);            x.right = deleteMin(temp.right);            x.left = temp.left;        &#125;        <span class="hljs-keyword">return</span> x;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.preOrderTraverse(root);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 前序遍历树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraverse</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x != <span class="hljs-keyword">null</span>) &#123;            System.out.print(x.item + <span class="hljs-string">" "</span>);            preOrderTraverse(x.left);            preOrderTraverse(x.right);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.inOrderTraverse(root);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 中序遍历树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderTraverse</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x != <span class="hljs-keyword">null</span>) &#123;            inOrderTraverse(x.left);            System.out.print(x.item + <span class="hljs-string">" "</span>);            inOrderTraverse(x.right);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.postOrderTraverse(root);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 后序遍历树</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> x</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrderTraverse</span><span class="hljs-params">(Node&lt;T&gt; x)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x != <span class="hljs-keyword">null</span>) &#123;            postOrderTraverse(x.left);            postOrderTraverse(x.right);            System.out.print(x.item + <span class="hljs-string">" "</span>);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 层次遍历树</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leverTraverse</span><span class="hljs-params">()</span> </span>&#123;        Queue&lt;Node&lt;T&gt;&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Node&lt;T&gt;&gt;();        Node&lt;T&gt; pnode = <span class="hljs-keyword">null</span>;        queue.offer(root);        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            pnode = queue.poll();            System.out.print(pnode.item + <span class="hljs-string">" "</span>);            <span class="hljs-keyword">if</span> (pnode.left != <span class="hljs-keyword">null</span>) &#123;                queue.offer(pnode.left);            &#125;            <span class="hljs-keyword">if</span> (pnode.right != <span class="hljs-keyword">null</span>) &#123;                queue.offer(pnode.right);            &#125;        &#125;        System.out.println();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 二叉排序树的树节点</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;        T item;        Node&lt;T&gt; left;        Node&lt;T&gt; right;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(T item, Node&lt;T&gt; left, Node&lt;T&gt; right)</span> </span>&#123;            <span class="hljs-keyword">this</span>.item = item;            <span class="hljs-keyword">this</span>.left = left;            <span class="hljs-keyword">this</span>.right = right;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">"数据为："</span> + <span class="hljs-keyword">this</span>.item + <span class="hljs-string">" "</span> + <span class="hljs-string">"左孩子为："</span> + (<span class="hljs-keyword">this</span>.left == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"null"</span> : <span class="hljs-keyword">this</span>.left.item) + <span class="hljs-string">" "</span> +                    <span class="hljs-string">"右孩子为："</span> + (<span class="hljs-keyword">this</span>.right == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"null"</span> : <span class="hljs-keyword">this</span>.right.item);        &#125;    &#125;&#125;</code></pre></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>优点：插入，删除操作的时间复杂度都是O(log(n))级的，即经过O(log(n))时间搜索到了需插入和删除的节点的位置，后经过O(1)级的时间就可以直接插入和删除，比有序顺序表的插入和删除O(n)(查找O(log(n))，移动节点O(n))快，而和无序顺序表插入O(1)，删除O(n)比，因为是有序的，所以查找的速度要快很多。<br>缺点：二叉排序树的构造不止和最终节点的顺序有关，还和节点插入和删除的顺序有关，在某些特殊的情况下，树的高度可以等于节点的数量，于是查找的时间复杂度就退化成了O(n)了,相当也无序顺序表的查找</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-哈夫曼树</title>
    <link href="/2019/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
    <url>/2019/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是哈夫曼树"><a href="#什么是哈夫曼树" class="headerlink" title="什么是哈夫曼树"></a>什么是哈夫曼树</h1><p>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在计算机数据处理中，哈夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。<br>例如，在英文中，e的出现机率最高，而z的出现概率则最低。当利用哈夫曼编码对一篇英文进行压缩时，e极有可能用一个比特来表示，而z则可能花去25个比特（不是26）。用普通的表示方法时，每个英文字母均占用一个字节，即8个比特。二者相比，e使用了一般编码的1/8的长度，z则使用了3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。<br>哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1<em>L1+W2</em>L2+W3<em>L3+…+Wn</em>Ln），N个权值Wi（i=1,2,…n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,…n）。可以证明哈夫曼树的WPL是最小的。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p><strong>1.</strong> <strong>路径和路径长度</strong><br>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p><p><strong>2.</strong> <strong>结点的权及带权路径长度</strong></p><p>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。<br><strong>3. ** **树的带权路径长度</strong>‘</p><p>树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><div class="hljs"><pre><code>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；(3)从森林中删除选取的两棵树，并将新树加入森林；(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</code></pre></div><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Huffman</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">15</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"没优化前："</span>);        TreeNode root = CreateHuffman(arr);        System.out.println(<span class="hljs-string">"前序遍历结果："</span>);        PreTraver(root);        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"共耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);        System.out.println(<span class="hljs-string">"----------------------------------"</span>);        start = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"优化后："</span>);        TreeNode rootByPQ = creatHuffmanByPriorityQueue(arr);        System.out.println(<span class="hljs-string">"前序遍历结果："</span>);        PreTraver(rootByPQ);        end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"共耗时："</span> + (end - start) + <span class="hljs-string">"ms"</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 未经过优化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">CreateHuffman</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        List&lt;TreeNode&gt; treeNodes = <span class="hljs-keyword">new</span> ArrayList&lt;TreeNode&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            treeNodes.add(<span class="hljs-keyword">new</span> TreeNode(arr[i], <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>));        &#125;        <span class="hljs-comment">//如果treenodes长度为1，则哈夫曼树创建好了，只剩下根结点</span>        <span class="hljs-keyword">while</span> (treeNodes.size() &gt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">//使用Collections集合对treenodes进行排序</span>            Collections.sort(treeNodes, <span class="hljs-keyword">new</span> Comparator&lt;TreeNode&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode o1, TreeNode o2)</span> </span>&#123;                    <span class="hljs-keyword">return</span> o1.getNo() - o2.getNo();                &#125;            &#125;);            <span class="hljs-comment">//排序之后，取出头两个进行创建结点</span>            TreeNode left = treeNodes.get(<span class="hljs-number">0</span>);            TreeNode right = treeNodes.get(<span class="hljs-number">1</span>);            TreeNode parent = <span class="hljs-keyword">new</span> TreeNode(left.getNo() + right.getNo(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);            <span class="hljs-comment">//根结点创建好之后，将左右结点接上去,并将根结点加入集合</span>            parent.setLeft(left);            parent.setRight(right);            treeNodes.add(parent);            <span class="hljs-comment">//之后将头两个节点删除</span>            treeNodes.remove(left);            treeNodes.remove(right);        &#125;        <span class="hljs-keyword">return</span> treeNodes.get(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 经过优先队列优化</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TreeNode <span class="hljs-title">creatHuffmanByPriorityQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;        <span class="hljs-comment">//构造结点依次加入优先队列</span>        Queue&lt;TreeNode&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;TreeNode&gt;(<span class="hljs-keyword">new</span> Comparator&lt;TreeNode&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode o1, TreeNode o2)</span> </span>&#123;                <span class="hljs-keyword">return</span> o1.getNo() - o2.getNo();            &#125;        &#125;);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;            pq.offer(<span class="hljs-keyword">new</span> TreeNode(arr[i], <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>));        &#125;        <span class="hljs-comment">//当队列中只剩一个元素时，Huffman树就创建完成了</span>        <span class="hljs-keyword">while</span>(pq.size() &gt; <span class="hljs-number">1</span>)&#123;            <span class="hljs-comment">//从优先队列中取出值最小的两个结点</span>            TreeNode left = pq.poll();            TreeNode right = pq.poll();            <span class="hljs-comment">//创建父结点</span>            TreeNode parent = <span class="hljs-keyword">new</span> TreeNode(left.getNo() + right.getNo(),<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);            <span class="hljs-comment">//为父结点添加左右孩子</span>            parent.setLeft(left);            parent.setRight(right);            <span class="hljs-comment">//加入优先队列</span>            pq.offer(parent);        &#125;        <span class="hljs-keyword">return</span> pq.poll();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PreTraver</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) &#123;            System.out.print(root.getNo() + <span class="hljs-string">" "</span>);            PreTraver(root.getLeft());            PreTraver(root.getRight());        &#125;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Huffman树的结点</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> no;             <span class="hljs-comment">//编号</span>    <span class="hljs-keyword">private</span> TreeNode left;      <span class="hljs-comment">//左结点</span>    <span class="hljs-keyword">private</span> TreeNode right;     <span class="hljs-comment">//右节点</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no, TreeNode left, TreeNode right)</span> </span>&#123;        <span class="hljs-keyword">this</span>.no = no;        <span class="hljs-keyword">this</span>.left = left;        <span class="hljs-keyword">this</span>.right = right;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> no;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> no)</span> </span>&#123;        <span class="hljs-keyword">this</span>.no = no;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> left;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(TreeNode left)</span> </span>&#123;        <span class="hljs-keyword">this</span>.left = left;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> right;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(TreeNode right)</span> </span>&#123;        <span class="hljs-keyword">this</span>.right = right;    &#125;&#125;</code></pre></div><h2 id="示例结果："><a href="#示例结果：" class="headerlink" title="示例结果："></a>示例结果：</h2><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/9d17da0f.PNG" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表（Java）实现</title>
    <link href="/2019/08/24/%E9%93%BE%E8%A1%A8%EF%BC%88Java%EF%BC%89%E5%AE%9E%E7%8E%B0/"/>
    <url>/2019/08/24/%E9%93%BE%E8%A1%A8%EF%BC%88Java%EF%BC%89%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 单链表实现</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinglyLinkedList</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;? <span class="hljs-title">super</span> <span class="hljs-title">T</span>&gt;&gt; </span>&#123;    <span class="hljs-keyword">private</span> Node&lt;T&gt; head;          <span class="hljs-comment">//  指向链表头结点</span>    <span class="hljs-keyword">private</span> Node&lt;T&gt; tail;          <span class="hljs-comment">//  指向链表尾结点</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;              <span class="hljs-comment">//  链表长度</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SinglyLinkedList</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.head = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.tail = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 向链表头部添加元素</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(T val)</span> </span>&#123;        Node&lt;T&gt; new_node = <span class="hljs-keyword">new</span> Node&lt;T&gt;(val, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (!isEmpty()) &#123;            new_node.next = head;            head = new_node;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.head = new_node;            <span class="hljs-keyword">this</span>.tail = new_node;        &#125;        size++;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 向链表尾部添加元素</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(T val)</span> </span>&#123;        Node&lt;T&gt; new_node = <span class="hljs-keyword">new</span> Node&lt;T&gt;(val, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (!isEmpty()) &#123;            tail.next = new_node;            tail = tail.next;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.head = new_node;            <span class="hljs-keyword">this</span>.tail = new_node;        &#125;        size++;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 有序添加元素(自定义升序排序)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T val)</span> </span>&#123;        Node&lt;T&gt; new_node = <span class="hljs-keyword">new</span> Node&lt;T&gt;(val, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (!isEmpty()) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.tail.item.compareTo(new_node.item) &lt;= <span class="hljs-number">0</span>) &#123;                tail.next = new_node;                tail = tail.next;            &#125; <span class="hljs-keyword">else</span> &#123;                Node&lt;T&gt; p_node = <span class="hljs-keyword">this</span>.head;                Node&lt;T&gt; q_node = p_node;                <span class="hljs-keyword">while</span> (p_node != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-keyword">if</span> (new_node.item.compareTo(p_node.item) &lt; <span class="hljs-number">0</span>) &#123;                        <span class="hljs-keyword">break</span>;                    &#125;                    q_node = p_node;                    p_node = p_node.next;                &#125;                new_node.next = p_node;                q_node.next = new_node;            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.head = new_node;            <span class="hljs-keyword">this</span>.tail = new_node;        &#125;        size++;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 插入指定位置</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, T val)</span> </span>&#123;        Node&lt;T&gt; new_node = <span class="hljs-keyword">new</span> Node&lt;T&gt;(val, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            head = new_node;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (index &gt; size + <span class="hljs-number">1</span>) &#123;                System.out.println(<span class="hljs-string">"下标超限"</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                Node&lt;T&gt; pre = findIndex(index - <span class="hljs-number">1</span>);                new_node.next = pre.next;                pre.next = new_node;            &#125;        &#125;        size++;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查找指定位置的结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">findIndex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;        Node&lt;T&gt; p = head;        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (i == index) &#123;                <span class="hljs-keyword">return</span> p;            &#125;            i++;            p = p.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 寻找链表中指定结点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">find</span><span class="hljs-params">(T val)</span> </span>&#123;        Node&lt;T&gt; x = <span class="hljs-keyword">this</span>.head;        Node&lt;T&gt; t = <span class="hljs-keyword">new</span> Node&lt;T&gt;(val, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">while</span> (x != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (x.item.compareTo(t.item) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> x;            &#125;            x = x.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断链表中是否含有指定的Val</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsVal</span><span class="hljs-params">(T val)</span> </span>&#123;        Node&lt;T&gt; p_node = <span class="hljs-keyword">this</span>.head;        Node&lt;T&gt; q_node = <span class="hljs-keyword">new</span> Node&lt;T&gt;(val, <span class="hljs-keyword">null</span>);        <span class="hljs-keyword">while</span> (p_node != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (p_node.item.compareTo(q_node.item) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            p_node = p_node.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 反转链表</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反转后的头指针</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">reverseList</span><span class="hljs-params">(Node&lt;T&gt; head)</span> </span>&#123;        Node&lt;T&gt; new_head = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;            Node&lt;T&gt; p = head.next;            head.next = new_head;            new_head = head;            head = p;        &#125;        <span class="hljs-keyword">return</span> new_head;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除链表中重复元素</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 删除重复元素后的头指针</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">()</span> </span>&#123;        Node&lt;T&gt; current = <span class="hljs-keyword">this</span>.head;        <span class="hljs-keyword">while</span> (current != <span class="hljs-keyword">null</span> &amp;&amp; current.next != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (current.item.compareTo(current.next.item) == <span class="hljs-number">0</span>) &#123;                current.next = current.next.next;                size--;            &#125; <span class="hljs-keyword">else</span> &#123;                current = current.next;            &#125;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除链表中指定元素</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> val</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(T val)</span> </span>&#123;        Node&lt;T&gt; dummyNode = <span class="hljs-keyword">new</span> Node&lt;T&gt;(val, <span class="hljs-keyword">null</span>);        dummyNode.next = head;        Node&lt;T&gt; prev = dummyNode;        <span class="hljs-keyword">while</span> (prev.next != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (prev.next.item == val) &#123;                prev.next = prev.next.next;            &#125; <span class="hljs-keyword">else</span> &#123;                prev = prev.next;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 合并两个有序链表（迭代）</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l1</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> l2</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 合并后的头结点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(Node&lt;T&gt; l1, Node&lt;T&gt; l2)</span> </span>&#123;        Node&lt;T&gt; prehead = <span class="hljs-keyword">new</span> Node&lt;T&gt;();        Node&lt;T&gt; prev = prehead;        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (l1.item.compareTo(l2.item) &lt;= <span class="hljs-number">0</span>) &#123;                prev.next = l1;                l1 = l1.next;            &#125; <span class="hljs-keyword">else</span> &#123;                prev.next = l2;                l2 = l2.next;            &#125;            prev = prev.next;        &#125;        prev.next = l1 == <span class="hljs-keyword">null</span> ? l2 : l1;        <span class="hljs-keyword">return</span> prehead.next;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将链表以数组的形式返回</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> Object[] toArray() &#123;        Object[] result = <span class="hljs-keyword">new</span> Object[size];        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (Node&lt;T&gt; x = head; x != <span class="hljs-keyword">null</span>; x = x.next)            result[i++] = x.item;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断链表是否为空</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> head == null</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.head == <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">getHead</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Node&lt;T&gt; <span class="hljs-title">getTail</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> tail;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getsize</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> size;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        Node&lt;T&gt; p_node = <span class="hljs-keyword">this</span>.head;        <span class="hljs-keyword">while</span> (p_node != <span class="hljs-keyword">null</span>) &#123;            sb.append(p_node.item + <span class="hljs-string">" "</span>);            p_node = p_node.next;        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>&#123;        Node&lt;T&gt; p = <span class="hljs-keyword">this</span>.head;        <span class="hljs-keyword">while</span>(p != <span class="hljs-keyword">null</span>)&#123;            System.out.println(p.item);            p = p.next;        &#125;    &#125;    &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dijkstra算法</title>
    <link href="/2019/08/22/Dijkstra%E7%AE%97%E6%B3%95/"/>
    <url>/2019/08/22/Dijkstra%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1、最短路径问题介绍"><a href="#1、最短路径问题介绍" class="headerlink" title="1、最短路径问题介绍"></a><strong>1、最短路径问题介绍</strong></h1><p>问题解释：<br>从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径</p><p>解决问题的算法：</p><ul><li>迪杰斯特拉算法（Dijkstra算法）</li><li><a href="http://blog.csdn.net/qq_35644234/article/details/60875818" target="_blank" rel="noopener">弗洛伊德算法（Floyd算法）</a></li><li><a href="http://blog.csdn.net/qq_35644234/article/details/61614581" target="_blank" rel="noopener">SPFA算法</a></li></ul><p>这篇博客，就对Dijkstra算法来做一个详细的整理</p><h3 id="1、什么是Dijkstra算法"><a href="#1、什么是Dijkstra算法" class="headerlink" title="1、什么是Dijkstra算法"></a>1、什么是Dijkstra算法</h3><p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家<a href="https://baike.baidu.com/item/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89/2828872" target="_blank" rel="noopener">狄克斯特拉</a>于1959 年提出的，因此又叫<a href="https://baike.baidu.com/item/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/6764865" target="_blank" rel="noopener">狄克斯特拉算法</a>。是从一个顶点到其余各顶点的<a href="https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84" target="_blank" rel="noopener">最短路径</a>算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p><h3 id="2、Dijkstra算法介绍"><a href="#2、Dijkstra算法介绍" class="headerlink" title="2、Dijkstra算法介绍"></a>2、Dijkstra算法介绍</h3><ul><li><p><strong>算法特点：</strong><br>迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。</p></li><li><p><strong>算法的思路</strong><br>Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。<br>然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，<br>然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。<br>然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。</p></li></ul><h3 id="3、Dijkstra算法示例演示"><a href="#3、Dijkstra算法示例演示" class="headerlink" title="3、Dijkstra算法示例演示"></a>3、Dijkstra算法示例演示</h3><p>求下图，从顶点v1到其他各个顶点的最短路径</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20170308144724663-460f7033.png" srcset="/img/loading.gif" alt=""></p><p>首先第一步，我们先声明一个dis数组，该数组初始化的值为：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/1-b979b62c.png" srcset="/img/loading.gif" alt=""></p><p>我们的顶点集T的初始化为：T={v1}</p><p>既然是求 v1顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离v1顶点最近是 v3顶点。当选择了 2 号顶点后，dis[2]（下标从0开始）的值就已经从“估计值”变为了“确定值”，即 v1顶点到 v3顶点的最短路程就是当前 dis[2]值。将V3加入到T中。<br>为什么呢？因为目前离 v1顶点最近的是 v3顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 v1顶点到 v3顶点的路程进一步缩短了。因为 v1顶点到其它顶点的路程肯定没有 v1到 v3顶点短.</p><p>OK，既然确定了一个顶点的最短路径，下面我们就要根据这个新入的顶点V3会有出度，发现以v3 为弧尾的有： &lt; v3,v4 &gt;,那么我们看看路径：v1–v3–v4的长度是否比v1–v4短，其实这个已经是很明显的了，因为dis[3]代表的就是v1–v4的长度为无穷大，而v1–v3–v4的长度为：10+50=60，所以更新dis[3]的值,得到如下结果：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/2-b98a6ef8.png" srcset="/img/loading.gif" alt=""></p><p>因此 dis[3]要更新为 60。这个过程有个专业术语叫做“松弛”。即 v1顶点到 v4顶点的路程即 dis[3]，通过 &lt; v3,v4&gt; 这条边松弛成功。这便是 Dijkstra 算法的主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。</p><p>然后，我们又从除dis[2]和dis[0]外的其他值中寻找最小值，发现dis[4]的值最小，通过之前是解释的原理，可以知道v1到v5的最短距离就是dis[4]的值，然后，我们把v5加入到集合T中，然后，考虑v5的出度是否会影响我们的数组dis的值，v5有两条出度：&lt; v5,v4&gt;和 &lt; v5,v6&gt;,然后我们发现：v1–v5–v4的长度为：50，而dis[3]的值为60，所以我们要更新dis[3]的值.另外，v1-v5-v6的长度为：90，而dis[5]为100，所以我们需要更新dis[5]的值。更新后的dis数组如下图：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/3-64056ef9.png" srcset="/img/loading.gif" alt=""></p><p>然后，继续从dis中选择未确定的顶点的值中选择一个最小的值，发现dis[3]的值是最小的，所以把v4加入到集合T中，此时集合T={v1,v3,v5,v4},然后，考虑v4的出度是否会影响我们的数组dis的值，v4有一条出度：&lt; v4,v6&gt;,然后我们发现：v1–v5–v4–v6的长度为：60，而dis[5]的值为90，所以我们要更新dis[5]的值，更新后的dis数组如下图：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/4-2c337b99.png" srcset="/img/loading.gif" alt=""></p><p>然后，我们使用同样原理，分别确定了v6和v2的最短路径，最后dis的数组的值如下：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/5-6e821cd5.png" srcset="/img/loading.gif" alt=""></p><p>因此，从图中，我们可以发现v1-v2的值为：∞，代表没有路径从v1到达v2。所以我们得到的最后的结果为：</p><div class="hljs"><pre><code class="hljs smali">起点  终点    最短路径    长度v1    v2     无          ∞          v3     &#123;v1,v3&#125;    10      v4     &#123;v1,v5,v4&#125;  50      v5     &#123;v1,v5&#125;    30      v6     &#123;v1，v5,v4,v6&#125; 60</code></pre></div><h2 id="Dijkstra算法的代码实现（Java）"><a href="#Dijkstra算法的代码实现（Java）" class="headerlink" title="Dijkstra算法的代码实现（Java）"></a>Dijkstra算法的代码实现（Java）</h2><h4 id="Dis类"><a href="#Dis类" class="headerlink" title="Dis类"></a><strong>Dis类</strong></h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 记录起点到每个顶点的最短路径的信息</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dis</span> </span>&#123;    <span class="hljs-keyword">private</span> String path;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> visit;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dis</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dis</span><span class="hljs-params">(String path, <span class="hljs-keyword">boolean</span> visit, <span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.path = path;        <span class="hljs-keyword">this</span>.visit = visit;        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPath</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> path;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPath</span><span class="hljs-params">(String path)</span> </span>&#123;        <span class="hljs-keyword">this</span>.path = path;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isVisit</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> visit;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVisit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> visit)</span> </span>&#123;        <span class="hljs-keyword">this</span>.visit = visit;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = value;    &#125;&#125;</code></pre></div><h4 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a><strong>实现类</strong></h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 实现类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dijkstra</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V;                  <span class="hljs-comment">//  图的顶点个数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;                  <span class="hljs-comment">//  图的边数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] graph;          <span class="hljs-comment">//  图的邻接矩阵</span>    <span class="hljs-keyword">private</span> Dis[] dis;              <span class="hljs-comment">//  记录各个顶点最短路径的信息</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造函数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> V</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> E</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V, <span class="hljs-keyword">int</span> E)</span> </span>&#123;        <span class="hljs-comment">//初始化顶点数和边数</span>        <span class="hljs-keyword">this</span>.V = V;        <span class="hljs-keyword">this</span>.E = E;        <span class="hljs-comment">//为邻接矩阵和Dis数组开辟空间及赋初值</span>        <span class="hljs-keyword">this</span>.graph = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V][V];        <span class="hljs-keyword">this</span>.dis = <span class="hljs-keyword">new</span> Dis[V];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;            dis[v] = <span class="hljs-keyword">new</span> Dis();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;                graph[v][i] = Integer.MAX_VALUE;            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 为邻接矩阵对应点赋值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> from</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> to</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> weight</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> from, <span class="hljs-keyword">int</span> to, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;        graph[from][to] = weight;        <span class="hljs-comment">//加上这句就是无向图</span>        <span class="hljs-comment">//graph[to][from] = weight;</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Dijkstra算法实现</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> start</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;        <span class="hljs-comment">//初始化Dis数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;            <span class="hljs-comment">//设置当前的路径</span>            dis[i].setPath(<span class="hljs-string">"V"</span> + String.valueOf(start) + <span class="hljs-string">"-&gt;V"</span> + String.valueOf(i));            dis[i].setValue(graph[start][i]);        &#125;        <span class="hljs-comment">//设置起点到起点的路径为0</span>        dis[start].setValue(<span class="hljs-number">0</span>);        dis[start].setVisit(<span class="hljs-keyword">true</span>);        <span class="hljs-comment">//计算剩余的顶点的最短路径（剩余 V - 1 个顶点）</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">1</span>; v &lt; V; v++) &#123;            <span class="hljs-comment">//min记录的当前的最小值</span>            <span class="hljs-comment">//index用于保存当前dis数组中最小的那个下标</span>            <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;            <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; V; i++) &#123;                <span class="hljs-keyword">if</span> (!dis[i].isVisit() &amp;&amp; dis[i].getValue() &lt; min) &#123;                    min = dis[i].getValue();                    index = i;                &#125;            &#125;            <span class="hljs-comment">//把index对应的顶点标记为已访问过</span>            dis[index].setVisit(<span class="hljs-keyword">true</span>);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; V; j++) &#123;                <span class="hljs-comment">//如果新得到的边可以影响其他为访问的顶点，那就就更新它的最短路径和长度</span>                <span class="hljs-keyword">if</span> (!dis[j].isVisit() &amp;&amp; graph[index][j] != Integer.MAX_VALUE &amp;&amp; (dis[index].getValue() + graph[index][j] &lt; dis[j].getValue())) &#123;                    dis[j].setPath(dis[index].getPath() + <span class="hljs-string">"-&gt;V"</span> + String.valueOf(j));                    dis[j].setValue(graph[index][j] + dis[index].getValue());                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printPath</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-keyword">this</span>.V; i++) &#123;            <span class="hljs-keyword">if</span> (dis[i].getValue() != Integer.MAX_VALUE) &#123;                System.out.println(dis[i].getPath() + <span class="hljs-string">"\t\t最短路径长度为"</span> + dis[i].getValue());            &#125; <span class="hljs-keyword">else</span> &#123;                System.out.println(dis[i].getPath() + <span class="hljs-string">"\t\t无最短路径"</span>);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printGraph</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] a : graph) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;                <span class="hljs-keyword">if</span> (a[i] == Integer.MAX_VALUE) &#123;                    System.out.print(<span class="hljs-string">"\tMAX\t"</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    System.out.print(<span class="hljs-string">"\t"</span> + a[i] + <span class="hljs-string">"\t"</span>);                &#125;            &#125;            System.out.println();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">int</span> V = sc.nextInt();        <span class="hljs-keyword">int</span> E = sc.nextInt();        Dijkstra dijkstra = <span class="hljs-keyword">new</span> Dijkstra(V, E);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;             dijkstra.addEdge(sc.nextInt(), sc.nextInt(), sc.nextInt());        &#125;        dijkstra.dijkstra(<span class="hljs-number">0</span>);        dijkstra.printPath();    &#125;&#125;</code></pre></div><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><div class="hljs"><pre><code class="hljs yaml"><span class="hljs-string">/**</span> <span class="hljs-string">*</span> <span class="hljs-string">测试数据</span> <span class="hljs-string">*</span> <span class="hljs-number">6</span> <span class="hljs-number">11</span> <span class="hljs-string">*</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">50</span> <span class="hljs-string">*</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span> <span class="hljs-string">*</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">45</span> <span class="hljs-string">*</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">10</span> <span class="hljs-string">*</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">15</span> <span class="hljs-string">*</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-string">*</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">15</span> <span class="hljs-string">*</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">20</span> <span class="hljs-string">*</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">35</span> <span class="hljs-string">*</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">30</span> <span class="hljs-string">*</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-string">*</span> <span class="hljs-string">有向图的邻接矩阵如下：</span> <span class="hljs-string">*</span>      <span class="hljs-number">0</span>       <span class="hljs-number">1</span>       <span class="hljs-number">2</span>       <span class="hljs-number">3</span>       <span class="hljs-number">4</span>       <span class="hljs-number">5</span> <span class="hljs-string">*</span> <span class="hljs-number">0</span>    <span class="hljs-string">MAX</span>     <span class="hljs-number">50</span>      <span class="hljs-number">10</span>      <span class="hljs-string">MAX</span>     <span class="hljs-number">45</span>      <span class="hljs-string">MAX</span> <span class="hljs-string">*</span> <span class="hljs-number">1</span>    <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span>     <span class="hljs-number">15</span>      <span class="hljs-string">MAX</span>     <span class="hljs-number">10</span>      <span class="hljs-string">MAX</span> <span class="hljs-string">*</span> <span class="hljs-number">2</span>    <span class="hljs-number">20</span>      <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span>     <span class="hljs-number">15</span>      <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span> <span class="hljs-string">*</span> <span class="hljs-number">3</span>    <span class="hljs-string">MAX</span>     <span class="hljs-number">20</span>      <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span>     <span class="hljs-number">35</span>      <span class="hljs-string">MAX</span> <span class="hljs-string">*</span> <span class="hljs-number">4</span>    <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span>     <span class="hljs-number">30</span>      <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span> <span class="hljs-string">*</span> <span class="hljs-number">5</span>    <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span>     <span class="hljs-number">3</span>       <span class="hljs-string">MAX</span>     <span class="hljs-string">MAX</span> <span class="hljs-string">*/</span></code></pre></div><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><div class="hljs"><pre><code class="hljs angelscript">L:\jdk<span class="hljs-number">-11.0</span><span class="hljs-number">.2</span>\bin\java.exe <span class="hljs-string">"-javaagent:L:\IDEA\IntelliJ IDEA 2018.3.5\lib\idea_rt.jar=54359:L:\IDEA\IntelliJ IDEA 2018.3.5\bin"</span> -Dfile.encoding=UTF<span class="hljs-number">-8</span> -classpath C:\Users\lwj\Desktop\数据结构与算法\<span class="hljs-keyword">out</span>\production\algorithms Main.Graph.Dijkstra<span class="hljs-number">6</span> <span class="hljs-number">11</span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">50</span><span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">10</span><span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">45</span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">10</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">15</span><span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">20</span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">15</span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">20</span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">35</span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">30</span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span>V0-&gt;V2-&gt;V3-&gt;V1 最短路径长度为<span class="hljs-number">45</span>V0-&gt;V2 最短路径长度为<span class="hljs-number">10</span>V0-&gt;V2-&gt;V3 最短路径长度为<span class="hljs-number">25</span>V0-&gt;V4 最短路径长度为<span class="hljs-number">45</span>V0-&gt;V5 无最短路径</code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Dijkstra算法适用于权值为非负的图的单源最短路径，算法时间复杂度为<strong>O(n^2)</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-最小生成树</title>
    <link href="/2019/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2019/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是最小生成树？"><a href="#什么是最小生成树？" class="headerlink" title="什么是最小生成树？"></a>什么是最小生成树？</h1><p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在一给定的无向图G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边（即），而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集且为无循环图，使得的 <strong>w(T)</strong> 最小，则此 T 为 G 的<strong>最小生成树</strong>。</p><p>最小生成树其实是<strong>最小权重生成树</strong>的简称</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>例如：要在n个城市之间铺设光缆，主要目标是要使这 n 个城市的任意两个之间都可以通信，但铺设光缆的费用很高，且各个城市之间铺设光缆的费用不同，因此另一个目标是要使铺设光缆的总费用最低。这就需要找到带权的最小生成树。</p><h3 id="关于图的几个概念定义："><a href="#关于图的几个概念定义：" class="headerlink" title="关于图的几个概念定义："></a>关于图的几个概念定义：</h3><ul><li><strong>连通图</strong>：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。</li><li><strong>强连通图</strong>：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。</li><li><strong>连通网</strong>：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。</li><li><strong>生成树</strong>：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。</li></ul><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/1-bcc3eada.jpg" srcset="/img/loading.gif" alt=""></p><hr><h3 id="以下代码会用到的数据类型："><a href="#以下代码会用到的数据类型：" class="headerlink" title="以下代码会用到的数据类型："></a>以下代码会用到的数据类型：</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">* 图中的边</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Edge</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> v;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> w;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;        <span class="hljs-keyword">this</span>.v = v;        <span class="hljs-keyword">this</span>.w = w;        <span class="hljs-keyword">this</span>.weight = weight;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">either</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> v;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">other</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (vertex == v) &#123;            <span class="hljs-keyword">return</span> w;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> v;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> weight;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Edge o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.weight &gt; o.weight) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.weight &lt; o.weight) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Edge&#123;"</span> +  <span class="hljs-string">"v="</span> + v +  <span class="hljs-string">", w="</span> + w + <span class="hljs-string">", weight="</span> + weight + <span class="hljs-string">'&#125;'</span>;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">* 无向连通图的数据类型</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EdgeWeightedGraph</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> V;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;    <span class="hljs-keyword">private</span> LinkedList&lt;Edge&gt;[] adj;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EdgeWeightedGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> V)</span> </span>&#123;        <span class="hljs-keyword">this</span>.V = V;        <span class="hljs-keyword">this</span>.E = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.adj = (LinkedList&lt;Edge&gt;[]) <span class="hljs-keyword">new</span> LinkedList[V];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;            adj[v] = <span class="hljs-keyword">new</span> LinkedList&lt;Edge&gt;();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">V</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> V;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">E</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> E;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(Edge e)</span> </span>&#123;        <span class="hljs-keyword">int</span> v = e.either();        <span class="hljs-keyword">int</span> w = e.other(v);        adj[v].add(e);        adj[w].add(e);        E++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> LinkedList&lt;Edge&gt; <span class="hljs-title">edges</span><span class="hljs-params">()</span> </span>&#123;        LinkedList&lt;Edge&gt; b = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v &lt; V; v++) &#123;            <span class="hljs-keyword">for</span> (Edge e : adj[v]) &#123;                <span class="hljs-keyword">if</span> (e.other(v) &gt; v) &#123;                    b.add(e);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterable&lt;Edge&gt; <span class="hljs-title">adj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;        <span class="hljs-keyword">return</span> adj[v];    &#125;&#125;</code></pre></div><h2 id="下面介绍两种求最小生成树算法"><a href="#下面介绍两种求最小生成树算法" class="headerlink" title="下面介绍两种求最小生成树算法"></a>下面介绍两种求最小生成树算法</h2><h3 id="1-Kruskal算法"><a href="#1-Kruskal算法" class="headerlink" title="1.Kruskal算法"></a><strong>1.Kruskal算法</strong></h3><p>此算法可以称为<strong>加边法</strong>，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 </p><ol><li>把图中的所有边按代价从小到大排序； </li><li>把图中的n个顶点看成独立的n棵树组成的森林； </li><li>按权值从小到大选择边，所选的边连接的两个顶点 ui , vi。ui , vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。  </li><li>重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。</li></ol><p>此算法需要用到 <strong>并查集(Union-Find)</strong> 的知识,不懂得同学请先点击这里<a href="https://www.lwjppz.cn/articles/2019/08/10/1565430386067.html" target="_blank" rel="noopener">Union-Find</a>查看有关知识。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20160714144315409-ac2c445e.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><h5 id="并查集："><a href="#并查集：" class="headerlink" title="并查集："></a>并查集：</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span> </span>&#123;        count = N;        id = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;            id[i] = i;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;        <span class="hljs-keyword">return</span> find(p) == find(q);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;        <span class="hljs-keyword">while</span> (p != id[p]) &#123;            p = id[p];        &#125;        <span class="hljs-keyword">return</span> p;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;        <span class="hljs-keyword">int</span> pRoot = find(p);        <span class="hljs-keyword">int</span> qRoot = find(q);        <span class="hljs-keyword">if</span> (pRoot == qRoot) &#123;            <span class="hljs-keyword">return</span>;        &#125;        id[pRoot] = qRoot;        count--;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KruskalMST</span> </span>&#123;    <span class="hljs-keyword">private</span> Queue&lt;Edge&gt; mst;                <span class="hljs-comment">//  存储最小生成树的每条边</span>    <span class="hljs-keyword">private</span> Queue&lt;Edge&gt; pq;                 <span class="hljs-comment">//  优先队列，获取权重最小的边</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> weight;                     <span class="hljs-comment">//  权重和</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">KruskalMST</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kruskalMST</span><span class="hljs-params">(EdgeWeightedGraph G)</span> </span>&#123;        mst = <span class="hljs-keyword">new</span> LinkedList&lt;Edge&gt;();        pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;Edge&gt;();        <span class="hljs-keyword">for</span> (Edge e : G.edges()) &#123;            pq.offer(e);        &#125;        UF uf = <span class="hljs-keyword">new</span> UF(G.V());        <span class="hljs-keyword">while</span> (!pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - <span class="hljs-number">1</span>) &#123;            Edge e = pq.poll();             <span class="hljs-comment">//  从pq中获得权重最小的边和它的顶点</span>            <span class="hljs-keyword">int</span> v = e.either();            <span class="hljs-keyword">int</span> w = e.other(v);            <span class="hljs-keyword">if</span> (!uf.connected(v, w)) &#123;      <span class="hljs-comment">//  如果v和w不构成环</span>                uf.union(v, w);             <span class="hljs-comment">//  合并分量</span>                mst.offer(e);               <span class="hljs-comment">//  将边添加到最小生成树中</span>            &#125;        &#125;        printKruskalMST();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printKruskalMST</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (!mst.isEmpty()) &#123;            Edge e = mst.poll();            weight += e.getWeight();            System.out.println(e);        &#125;        System.out.println(<span class="hljs-string">"总权重为："</span>+weight);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span> (sc.hasNext()) &#123;            <span class="hljs-keyword">int</span> V = sc.nextInt();            <span class="hljs-keyword">int</span> E = sc.nextInt();            EdgeWeightedGraph edgeWeightedGraph = <span class="hljs-keyword">new</span> EdgeWeightedGraph(V);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;                Edge e = <span class="hljs-keyword">new</span> Edge(sc.nextInt() - <span class="hljs-number">1</span>, sc.nextInt() - <span class="hljs-number">1</span>, sc.nextInt());                edgeWeightedGraph.addEdge(e);            &#125;            KruskalMST kruskal = <span class="hljs-keyword">new</span> KruskalMST();            kruskal.kruskalMST(edgeWeightedGraph);        &#125;    &#125;&#125;</code></pre></div><h4 id="测试如下："><a href="#测试如下：" class="headerlink" title="测试如下："></a>测试如下：</h4><div class="hljs"><pre><code class="hljs java">L:\jdk-<span class="hljs-number">11.0</span><span class="hljs-number">.2</span>\bin\java.exe <span class="hljs-string">"-javaagent:L:\IDEA\IntelliJ IDEA 2018.3.5\lib\idea_rt.jar=60157:L:\IDEA\IntelliJ IDEA 2018.3.5\bin"</span> -Dfile.encoding=UTF-<span class="hljs-number">8</span> -classpath C:\Users\lwj\Desktop\数据结构与算法\out\production\algorithms Main.Tree.KruskalMST<span class="hljs-number">6</span> <span class="hljs-number">10</span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>Edge&#123;v=<span class="hljs-number">0</span>, w=<span class="hljs-number">2</span>, weight=<span class="hljs-number">1</span>&#125;Edge&#123;v=<span class="hljs-number">3</span>, w=<span class="hljs-number">5</span>, weight=<span class="hljs-number">2</span>&#125;Edge&#123;v=<span class="hljs-number">1</span>, w=<span class="hljs-number">4</span>, weight=<span class="hljs-number">3</span>&#125;Edge&#123;v=<span class="hljs-number">2</span>, w=<span class="hljs-number">5</span>, weight=<span class="hljs-number">4</span>&#125;Edge&#123;v=<span class="hljs-number">1</span>, w=<span class="hljs-number">2</span>, weight=<span class="hljs-number">5</span>&#125;总权重为：<span class="hljs-number">15</span></code></pre></div><h3 id="2-Prim算法"><a href="#2-Prim算法" class="headerlink" title="2.Prim算法"></a><strong>2.Prim算法</strong></h3><p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。</p><ol><li>图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;</li><li>在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。</li><li>重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。</li></ol><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20160714161107576-757f8695.jpg" srcset="/img/loading.gif" alt=""></p><h4 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimMST</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] marked;    <span class="hljs-keyword">private</span> Queue&lt;Edge&gt; mst;    <span class="hljs-keyword">private</span> Queue&lt;Edge&gt; pq;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">primMST</span><span class="hljs-params">(EdgeWeightedGraph G)</span> </span>&#123;        pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;Edge&gt;();        marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];        mst = <span class="hljs-keyword">new</span> LinkedList&lt;Edge&gt;();        visit(G, <span class="hljs-number">0</span>);        <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;        Edge e = pq.poll();        <span class="hljs-keyword">int</span> v = e.either();        <span class="hljs-keyword">int</span> w = e.other(v);        <span class="hljs-keyword">if</span> (marked[v] &amp;&amp; marked[w]) <span class="hljs-keyword">continue</span>;            mst.offer(e);            <span class="hljs-keyword">if</span> (!marked[v]) visit(G, v);            <span class="hljs-keyword">if</span> (!marked[w]) visit(G, w);        &#125;        printMST();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(EdgeWeightedGraph G, <span class="hljs-keyword">int</span> v)</span> </span>&#123;        marked[v] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">for</span> (Edge e : G.adj(v)) &#123;            <span class="hljs-keyword">if</span> (!marked[e.other(v)]) &#123;                pq.offer(e);            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printMST</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (!mst.isEmpty()) &#123;            Edge e = mst.poll();            weight += e.getWeight();            System.out.println(e);        &#125;        System.out.println(<span class="hljs-string">"总权重为："</span>+weight);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        <span class="hljs-keyword">while</span> (sc.hasNext()) &#123;            <span class="hljs-keyword">int</span> V = sc.nextInt();            <span class="hljs-keyword">int</span> E = sc.nextInt();            EdgeWeightedGraph edgeWeightedGraph = <span class="hljs-keyword">new</span> EdgeWeightedGraph(V);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; E; i++) &#123;                Edge e = <span class="hljs-keyword">new</span> Edge(sc.nextInt() - <span class="hljs-number">1</span>, sc.nextInt() - <span class="hljs-number">1</span>, sc.nextInt());                edgeWeightedGraph.addEdge(e);            &#125;                 PrimMST primMST = <span class="hljs-keyword">new</span> PrimMST();            primMST.primMST(edgeWeightedGraph);        &#125;    &#125;&#125;</code></pre></div><h4 id="测试如下：-1"><a href="#测试如下：-1" class="headerlink" title="测试如下："></a>测试如下：</h4><div class="hljs"><pre><code class="hljs java">L:\jdk-<span class="hljs-number">11.0</span><span class="hljs-number">.2</span>\bin\java.exe <span class="hljs-string">"-javaagent:L:\IDEA\IntelliJ IDEA 2018.3.5\lib\idea_rt.jar=60266:L:\IDEA\IntelliJ IDEA 2018.3.5\bin"</span> -Dfile.encoding=UTF-<span class="hljs-number">8</span> -classpath C:\Users\lwj\Desktop\数据结构与算法\out\production\algorithms Main.Tree.PrimMST<span class="hljs-number">6</span> <span class="hljs-number">10</span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>Edge&#123;v=<span class="hljs-number">0</span>, w=<span class="hljs-number">2</span>, weight=<span class="hljs-number">1</span>&#125;Edge&#123;v=<span class="hljs-number">2</span>, w=<span class="hljs-number">5</span>, weight=<span class="hljs-number">4</span>&#125;Edge&#123;v=<span class="hljs-number">3</span>, w=<span class="hljs-number">5</span>, weight=<span class="hljs-number">2</span>&#125;Edge&#123;v=<span class="hljs-number">1</span>, w=<span class="hljs-number">2</span>, weight=<span class="hljs-number">5</span>&#125;Edge&#123;v=<span class="hljs-number">1</span>, w=<span class="hljs-number">4</span>, weight=<span class="hljs-number">3</span>&#125;总权重为：<span class="hljs-number">15</span></code></pre></div><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/767231c6.PNG" srcset="/img/loading.gif" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>克鲁斯卡尔（Kruskal）算法因为只与边相关，则适合求稀疏图的最小生成树。而prime算法因为只与顶点有关，所以适合求稠密图的最小生成树。 无疑，Kruskal算法在效率上要比Prim算法快，因为Kruskal只需要对权重边做一次排序，而Prim算法则需要做多次排序。尽管Prim算法每次做的算法涉及的权重边不一定会涵盖连通图中的所有边，但是随着所使用的排序算法的效率的提高，Kruskal算法和Prim算法之间的差异将会清晰的显性出来。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>union-find（并查集）算法</title>
    <link href="/2019/08/13/union-find%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%E7%AE%97%E6%B3%95/"/>
    <url>/2019/08/13/union-find%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%89%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文引用了算法（第四版）这本书进行分析</p></blockquote><h2 id="动态连通性"><a href="#动态连通性" class="headerlink" title="动态连通性"></a>动态连通性</h2><p>首先我们详细地说明一下问题：问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，一对整数 <code>p q</code> 可以被理解为“<code>p</code> 和 <code>q</code> 是相连的”。我们假设“相连”是一种<strong>等价</strong>关系，这也就意味着它具有：</p><ul><li><strong>自反性</strong>：<code>p</code> 和 <code>p</code> 是相连的；</li><li><strong>对称性</strong>：如果<code>p</code> 和<code>q</code> 是相连的，那么<code>q</code> 和<code>p</code> 也是相连的；</li><li><strong>传递性</strong>：如果 <code>p</code> 和 <code>q</code> 是相连的且 <code>q</code> 和 <code>r</code> 是相连的，那么 <code>p</code> 和 <code>r</code> 也是相连的。</li></ul><p>等价关系能够将对象分为多个<strong>等价类</strong>。在这里，当且仅当两个对象相连时它们才属于同一个等价类。我们的目标是编写一个程序来过滤掉序列中所有无意义的整数对（两个整数均来自于同一个等价类中）。换句话说，当程序从输入中读取了整数对 <code>p q</code> 时，如果已知的所有整数对都不能说明 <code>p</code> 和 <code>q</code> 是相连的，那么则将这一对整数写入到输出中。如果已知的数据可以说明<code>p</code> 和 <code>q</code> 是相连的，那么程序应该忽略 <code>p q</code> 这对整数并继续处理输入中的下一对整数。图 1.5.1 用一个例子说明了这个过程。为了达到所期望的效果，我们需要设计一个数据结构来保存程序已知的所有整数对的足够多的信息，并用它们来判断一对新对象是否是相连的。我们将这个问题通俗地叫做<strong>动态连通性</strong>问题。这个问题可能有以下应用。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/05.d01z.061-04257761.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.1　动态连通性问题</strong></p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>输入中的整数表示的可能是一个大型计算机网络中的计算机，而整数对则表示网络中的连接。这个程序能够判定我们是否需要在 <code>p</code> 和 <code>q</code> 之间架设一条新的连接才能进行通信，或是我们可以通过已有的连接在两者之间建立通信线路；或者这些整数表示的可能是电子电路中的触点，而整数对表示的是连接触点之间的电路；或者这些整数表示的可能是社交网络中的人，而整数对表示的是朋友关系。在此类应用中，我们可能需要处理数百万的对象和数十亿的连接。</p><h3 id="变量名等价性"><a href="#变量名等价性" class="headerlink" title="变量名等价性"></a>变量名等价性</h3><p>某些编程环境允许声明两个等价的变量名（指向同一个对象的多个引用）。在一系列这样的声明之后，系统需要能够判别两个给定的变量名是否等价。这种较早出现的应用（如 FORTRAN 语言）推动了我们即将讨论的算法的发展。</p><h3 id="数学集合"><a href="#数学集合" class="headerlink" title="数学集合"></a>数学集合</h3><p>在更高的抽象层次上，可以将输入的所有整数看做属于不同的数学集合。在处理一个整数对 <code>p q</code> 时，我们是在判断它们是否属于相同的集合。如果不是，我们会将 <code>p</code> 所属的集合和 <code>q</code> 所属的集合归并到同一个集合。</p><p>为了进一步限定话题，我们会在本节以下内容中使用网络方面的术语，将对象称为<strong>触点</strong>，将整数对称为<strong>连接</strong>，将等价类称为<strong>连通分量</strong>或是简称<strong>分量</strong>。简单起见，假设我们有用 0 到<img src="https://img.hacpai.com/file/2019/08/gif-e8407621.gif" srcset="/img/loading.gif" alt="gif.gif">)的整数所表示的<img src="https://img.hacpai.com/file/2019/08/gif1-d2c0ace2.gif" srcset="/img/loading.gif" alt="gif1.gif">个触点。这样做并不会降低算法的通用性，因为我们在第 3 章中将会学习一组高效的算法，将整数标识符和任意名称关联起来。</p><p>图 1.5.2 是一个较大的例子，意在说明连通性问题的难度。你很快就可以找到图左侧中部一个只含有一个触点的分量，以及左下方一个含有 5 个触点的分量，但让你验证其他所有触点是否都是相互连通的可能就有些困难了。对于程序来说，这个任务更加困难，因为它所处理的只有触点的名字和连接而并不知道触点在图像中的几何位置。我们如何才能快速知道这种网络中任意给定的两个触点是否相连呢？</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/05.d01z.062-865de5ac.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.2　中等规模的连通性问题举例（625 个触点，900 条边，3 个连通分量）</strong></p><p>我们在设计算法时面对的第一个任务就是精确地定义问题。我们希望算法解决的问题越大，它完成任务所需的时间和空间可能就越多。我们不可能<strong>预先</strong>知道这其间的量化关系，而且我们通常只会在发现解决问题很困难，或是代价巨大，或是在幸运地发现算法所提供的信息比原问题所需要的更加有用时修改问题。例如，连通性问题只要求我们的程序能够判别给定的整数对 <code>p q</code> 是否相连，但并没有要求给出两者之间的通路上的所有连接。这样的要求会使问题更加困难，并得到另一组不同的算法，我们会在 4.1 节中学习它们。</p><p>为了说明问题，我们设计了一份 API 来封装所需的基本操作：初始化、连接两个触点、判断包含某个触点的分量、判断两个触点是否存在于同一个分量之中以及返回所有分量的数量。详细的 API 如表 1.5.1 所示。</p><p><strong>表 1.5.1　union-find 算法的 API</strong></p><table><thead><tr><th>public class <strong>UF</strong></th></tr></thead><tbody><tr><td>UF(int N)</td></tr><tr><td>void   union(int p, int q)</td></tr><tr><td>int   find(int p)</td></tr><tr><td>boolean   connected(int p, int q)</td></tr><tr><td>int   count()</td></tr></tbody></table><p>如果两个触点在不同的分量中，<code>union()</code> 操作会将两个分量归并。<code>find()</code> 操作会返回给定触点所在的连通分量的标识符。<code>connected()</code> 操作能够判断两个触点是否存在于同一个分量之中。<code>count()</code> 方法会返回所有连通分量的数量。一开始我们有 <img src="https://private.codecogs.com/gif.latex?N" srcset="/img/loading.gif" alt="N">个分量，将两个分量归并的每次 <code>union()</code> 操作都会使分量总数减一。</p><p>我们马上就将看到，为解决动态连通性问题设计算法的任务转化为了实现这份 API。所有的实现都应该：</p><ul><li>定义一种数据结构表示已知的连接；</li><li>基于此数据结构实现高效的 <code>union()</code>、<code>find()</code>、<code>connected()</code> 和 <code>count()</code> 方法。</li></ul><p>众所周知，数据结构的性质将直接影响到算法的效率，因此数据结构和算法的设计是紧密相关的。API 已经说明触点和分量都会用 <code>int</code> 值表示，所以我们可以用一个<strong>以触点为索引</strong>的数组<code>id[]</code> 作为基本数据结构来表示所有分量。我们将使用分量中的某个触点的名称作为分量的标识符，因此你可以认为每个分量都是由它的触点之一所表示的。一开始，我们有 <img src="https://private.codecogs.com/gif.latex?N" srcset="/img/loading.gif" alt="N"> 个分量，每个触点都构成了一个只含有它自己的分量，因此我们将<code>id[i]</code> 的值初始化为 <code>i</code>，其中 <code>i</code> 在 <code>0</code> 到 <code>N-1</code> 之间。对于每个触点 <code>i</code>，我们将 <code>find()</code> 方法用来判定它所在的分量所需的信息保存在 <code>id[i]</code> 之中。<code>connected()</code> 方法的实现只用一条语句 <code>find(p) == find(q)</code>，它返回一个布尔值，我们在所有方法的实现中都会用到 <code>connected()</code> 方法。</p><p>总之，我们的起点就是算法 1.5。我们维护了两个实例变量，一个是连通分量的个数，一个是数组<code>id[]</code>。<code>find()</code> 和 <code>union()</code> 的实现是本节剩余内容将要讨论的主题。</p><blockquote><p><strong>算法 1.5　union-find 的实现</strong></p></blockquote><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span></span><span class="hljs-class">&#123;</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] id;     <span class="hljs-comment">// 分量id（以触点作为索引）</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">// 分量数量</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span><span class="hljs-function">   </span>&#123;  <span class="hljs-comment">// 初始化分量id数组</span>      count = N;      id = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)         id[i] = i;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">()</span></span><span class="hljs-function">   </span>&#123;  <span class="hljs-keyword">return</span> count;  &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span><span class="hljs-function">   </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p) == <span class="hljs-built_in">find</span>(q);  &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>  <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span><span class="hljs-function">   <span class="hljs-comment">// 请见1.5.2.1节用例（quick-find）、1.5.2.3节用例（quick-union）和算法1.5（加权quick-union）</span></span><span class="hljs-function">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span><span class="hljs-function">   </span>&#123;  <span class="hljs-comment">// 解决由StdIn得到的动态连通性问题</span>      <span class="hljs-keyword">int</span> N = StdIn.readInt();              <span class="hljs-comment">// 读取触点数量</span>      UF uf = <span class="hljs-keyword">new</span> UF(N);                    <span class="hljs-comment">// 初始化N个分量</span>      <span class="hljs-keyword">while</span> (!StdIn.isEmpty())      &#123;         <span class="hljs-keyword">int</span> p = StdIn.readInt();         <span class="hljs-keyword">int</span> q = StdIn.readInt();           <span class="hljs-comment">// 读取整数对</span>         <span class="hljs-keyword">if</span> (uf.<span class="hljs-built_in">connected</span>(p, q)) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 如果已经连通则忽略</span>         uf.<span class="hljs-keyword">union</span>(p, q);                    <span class="hljs-comment">// 归并分量</span>         StdOut.<span class="hljs-built_in">println</span>(p + <span class="hljs-string">" "</span> + q);      <span class="hljs-comment">// 打印连接</span>      &#125;      StdOut.<span class="hljs-built_in">println</span>(uf.count() + <span class="hljs-string">"components"</span>);   &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs angelscript">% java UF &lt; tinyUF.txt<span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-number">3</span> <span class="hljs-number">8</span><span class="hljs-number">6</span> <span class="hljs-number">5</span><span class="hljs-number">9</span> <span class="hljs-number">4</span><span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-number">5</span> <span class="hljs-number">0</span><span class="hljs-number">7</span> <span class="hljs-number">2</span><span class="hljs-number">6</span> <span class="hljs-number">1</span><span class="hljs-number">2</span> components</code></pre></div><blockquote><p>这份代码是我们对 UF 的实现。它维护了一个整型数组 <code>id[]</code>，使得 <code>find()</code> 对于处在同一个连通分量中的触点均返回相同的整数值。<code>union()</code> 方法必须保证这一点。</p></blockquote><p>为了测试 API 的可用性并方便开发，我们在 <code>main()</code> 方法中包含了一个用例用于解决动态连通性问题。它会从输入中读取 <code>N</code> 值以及一系列整数对，并对每一对整数调用 <code>connected()</code> 方法：如果某一对整数中的两个触点已经连通，程序会继续处理下一对数据；如果不连通，程序会调用 <code>union()</code> 方法并打印这对整数。在讨论实现之前，我们也准备了一些测试数据（如右侧的代码框所示）：文件 tinyUF.txt 含有 10 个触点和 11 条连接，图 1.5.1 使用的就是它；文件 mediumUF.txt 含有 625 个触点和 900 条连接，如图 1.5.2 所示；例子文件 largeUF.txt 含有 100 万个触点和 200 万条连接。我们的目标是在可以接受的时间范围内处理和 largeUF.txt 规模类似的输入。</p><div class="hljs"><pre><code class="hljs angelscript">% more tinyUF.txt<span class="hljs-number">10</span><span class="hljs-number">4</span> <span class="hljs-number">3</span><span class="hljs-number">3</span> <span class="hljs-number">8</span><span class="hljs-number">6</span> <span class="hljs-number">5</span><span class="hljs-number">9</span> <span class="hljs-number">4</span><span class="hljs-number">2</span> <span class="hljs-number">1</span><span class="hljs-number">8</span> <span class="hljs-number">9</span><span class="hljs-number">5</span> <span class="hljs-number">0</span><span class="hljs-number">7</span> <span class="hljs-number">2</span><span class="hljs-number">6</span> <span class="hljs-number">1</span><span class="hljs-number">1</span> <span class="hljs-number">0</span><span class="hljs-number">6</span> <span class="hljs-number">7</span>% more mediumUF.txt<span class="hljs-number">625</span><span class="hljs-number">528</span> <span class="hljs-number">503</span><span class="hljs-number">548</span> <span class="hljs-number">523</span>...<span class="hljs-number">900</span>条连接% more largeUF.txt<span class="hljs-number">1000000</span><span class="hljs-number">786321</span> <span class="hljs-number">134521</span><span class="hljs-number">696834</span> <span class="hljs-number">98245</span>...<span class="hljs-number">200</span>万条连接</code></pre></div><p>为了分析算法，我们将重点放在不同算法访问任意数组元素的总次数上。我们这样做相当于隐式地猜测各种算法在一台特定的计算机上的运行时间在这个量乘以某个常数的范围之内。这个猜想基于代码，用实验验证它并不困难。我们将会看到，这个猜想是算法比较的一个很好的开始。</p><blockquote><p><strong>union-find 的成本模型</strong>。在研究实现 union-find 的 API 的各种算法时，我们统计的是<strong>数组的访问</strong>次数（访问任意数组元素的次数，无论读写）。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="quick-find-算法"><a href="#quick-find-算法" class="headerlink" title="quick-find 算法"></a>quick-find 算法</h4><p>一种方法是保证当且仅当 <code>id[p]</code> 等于 <code>id[q]</code> 时 <code>p</code> 和 <code>q</code> 是连通的。换句话说，在同一个连通分量中的所有触点在 <code>id[]</code> 中的值必须全部相同。这意味着 <code>connected(p, q)</code> 只需要判断 <code>id[p] == id[q]</code>，当且仅当<code>p</code> 和<code>q</code> 在同一连通分量中该语句才会返回<code>true</code>。为了调用<code>union(p, q)</code> 确保这一点，我们首先要检查它们是否已经存在于同一个连通分量之中。如果是我们就不需要采取任何行动，否则我们面对的情况就是 <code>p</code> 所在的连通分量中的所有触点的<code>id[]</code> 值均为同一个值，而 <code>q</code> 所在的连通分量中的所有触点的 <code>id[]</code> 值均为另一个值。要将两个分量合二为一，我们必须将两个集合中所有触点所对应的<code>id[]</code> 元素变为同一个值，如表 1.5.2 所示。为此，我们需要遍历整个数组，将所有和 <code>id[p]</code> 相等的元素的值变为 <code>id[q]</code> 的值。我们也可以将所有和 <code>id[q]</code> 相等的元素的值变为 <code>id[p]</code> 的值——两者皆可。根据上述文字得到的<code>find()</code> 和<code>union()</code> 的代码简单明了，如下面的代码框所示。图 1.5.3 显示的是我们的开发用例在处理测试数据 tinyUF.txt 时的完整轨迹。</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">return</span> id[p];  &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">// 将p和q归并到相同的分量中</span>   <span class="hljs-keyword">int</span> pID = <span class="hljs-built_in">find</span>(p);   <span class="hljs-keyword">int</span> qID = <span class="hljs-built_in">find</span>(q);   <span class="hljs-comment">// 如果p和q已经在相同的分量之中则不需要采取任何行动</span>   <span class="hljs-keyword">if</span> (pID == qID) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">// 将p的分量重命名为q的名称</span>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; id.length; i++)       <span class="hljs-keyword">if</span> (id[i] == pID) id[i] = qID;   count--;&#125;</code></pre></div><p>quick-find</p><p><strong>表 1.5.2　quick-find 概览</strong></p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/05.d01z.063-76bf26f2.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/05.d01z.064-f46320e5.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.3　quick-find 的轨迹</strong></p><h4 id="quick-find-算法的分析"><a href="#quick-find-算法的分析" class="headerlink" title="quick-find 算法的分析"></a>quick-find 算法的分析</h4><p><code>find()</code> 操作的速度显然是很快的，因为它只需要访问 <code>id[]</code> 数组一次。但 quick-find 算法一般无法处理大型问题，因为对于每一对输入 <code>union()</code> 都需要扫描整个 <code>id[]</code> 数组。</p><blockquote><p><strong>命题 F</strong>。在 quick-find 算法中，每次 <code>find()</code> 调用只需要访问数组一次，而归并两个分量的 <code>union()</code> 操作访问数组的次数在 <strong>N+3</strong>到 <strong>2N+1</strong>之间。</p><p><strong>证明</strong>。由代码马上可以知道，每次 <code>connected()</code> 调用都会检查 <code>id[]</code> 数组中的两个元素是否相等，即会调用两次 <code>find()</code> 方法。归并两个分量的 <code>union()</code> 操作会调用两次 <code>find()</code>，检查 <code>id[]</code> 数组中的全部<strong>N</strong>元素并改变它们中 1 到<strong>N-1</strong>个元素的值。</p></blockquote><p>假设我们使用 quick-find 算法来解决动态连通性问题并且最后只得到了一个连通分量，那么这至少需要调用<strong>N-1 <em><em>次<code>union()</code>，即至少 *</em>(N-1)</em>(N+3)~N^2</strong>次数组访问——我们马上可以猜想动态连通性的 quick-find 算法是平方级别的。将这种分析推广我们可以得到，quick-find 算法的运行时间对于最终只能得到少数连通分量的一般应用是平方级别的。在计算机上用倍率测试可以很容易验证这个猜想（指导性的例子请见练习 1.5.23）。现代计算机每秒钟能够执行数亿甚至数十亿条指令，因此如果 <strong>N</strong> 较小的话这个成本并不是很明显。但是在现代应用中我们也很可能需要处理几百万甚至数十亿的触点和连接，例如我们的测试文件 largeUF.txt。如果你还不相信并且觉得自己的计算机足够快，请使用 quick-find 算法找出largeUF.txt 中所有整数对所表示的连通分量的数量。结论无可争议，使用 quick-find 算法解决这种问题是不可行的，我们需要寻找更好的算法。</p><h4 id="quick-union-算法"><a href="#quick-union-算法" class="headerlink" title="quick-union 算法"></a>quick-union 算法</h4><p>我们要讨论的下一个算法的重点是提高 <code>union()</code> 方法的速度，它和 quick-find 算法是互补的。它也基于相同的数据结构——以触点作为索引的 <code>id[]</code> 数组，但我们赋予这些值的意义不同，我们需要用它们来定义更加复杂的结构。确切地说，每个触点所对应的 <code>id[]</code> 元素都是同一个分量中的另一个触点的名称（也可能是它自己）——我们将这种联系称为<strong>链接</strong>。在实现 <code>find()</code> 方法时，我们从给定的触点开始，由它的链接得到另一个触点，再由这个触点的链接到达第三个触点，如此继续跟随着链接直到到达一个<strong>根触点</strong>，即链接指向自己的触点（你将会看到，这样一个触点必然存在）。当且仅当分别由两个触点开始的这个过程到达了同一个根触点时它们存在于同一个连通分量之中。为了保证这个过程的有效性，我们需要<code>union(p, q)</code> 来保证这一点。它的实现很简单：我们由 <code>p</code> 和 <code>q</code> 的链接分别找到它们的根触点，然后只需将一个根触点链接到另一个即可将一个分量重命名为另一个分量，因此这个算法叫做 <code>quick-union</code>。和刚才一样，无论是重命名含有 <code>p</code> 的分量还是重命名含有 <code>q</code> 的分量都可以，右侧的这段实现重命名了 <code>p</code> 所在的分量。图 1.5.5 显示了 quick-union 算法在处理 tinyUF.txt 时的轨迹。图 1.5.4 能够很好地说明图 1.5.5（见 1.5.2.4 节）中的轨迹，我们接下来要讨论的就是它。</p><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">// 找出分量的名称</span>   <span class="hljs-keyword">while</span> (p != id[p]) p = id[p];   <span class="hljs-keyword">return</span> p;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-comment">// 将p和q的根节点统一</span>   <span class="hljs-keyword">int</span> pRoot = <span class="hljs-built_in">find</span>(p);   <span class="hljs-keyword">int</span> qRoot = <span class="hljs-built_in">find</span>(q);   <span class="hljs-keyword">if</span> (pRoot == qRoot) <span class="hljs-keyword">return</span>;   id[pRoot] = qRoot;   count--;&#125;</code></pre></div><p>quick-union</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190724171330-682439ed.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.4　quick-union 算法概述</strong></p><h4 id="森林的表示"><a href="#森林的表示" class="headerlink" title="森林的表示"></a>森林的表示</h4><p>quick-union 算法的代码很简洁，但有些难以理解。用<strong>节点</strong>（带标签的圆圈）表示触点，用从一个节点到另一个节点的箭头表示<strong>链接</strong>，由此得到数据结构的图像表示使我们理解算法的操作变得相对容易。我们的得到的结构是<strong>树</strong>——从技术上来说，<code>id[]</code> 数组用父链接的形式表示了一片森林。为了简化图表，我们常常会省略链接的箭头（因为它们的指向全部朝上）和树的根节点中指向自己的链接。tinyUF.txt 的<code>id[]</code> 数组所对应的森林如图1.5.5 所示。无论我们从任何触点所对应的节点开始跟随链接，最终都将达到含有该节点的树的根节点。可以用归纳法证明这个性质的正确性：在数组被初始化之后，每个节点的链接都指向它自己；如果在某次<code>union()</code> 操作之前这条性质成立，那么操作之后它必然也成立。因此，quick-union 中的<code>find()</code> 方法能够返回根节点所对应的触点的名称（这样<code>connected()</code> 才能够判定两个触点是否在同一棵树中）。这种表示方法对于这个问题很实用，因为当且仅当两个触点存在于相同的分量之中时它们对应的节点才会在同一棵树中。另外，构造树并不困难：quick-union 中<code>union()</code> 的实现只用了一条语句就将一个根节点变为另一个根节点的父节点，从而归并了两棵树。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190724171330-e912c9b8.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.5　quick-union 算法的轨迹（以及相应的森林）</strong></p><h4 id="quick-union-算法的分析"><a href="#quick-union-算法的分析" class="headerlink" title="quick-union 算法的分析"></a>quick-union 算法的分析</h4><p>quick-union 算法看起来比 quick-find 算法更快，因为它不需要为每对输入遍历整个数组。但它能够快多少呢？分析 quick-union 算法的成本比分析 quick-find 算法的成本更困难，因为这依赖于输入的特点。在最好的情况下，<code>find()</code> 只需要访问数组一次就能够得到一个触点所在的分量的标识符；而在最坏情况下，这需要<strong>2N+1</strong>次数组访问，如图 1.5.6 中的 0 触点（这个估计是较为保守的，因为 <code>while</code> 循环中经过编译的代码对 <code>id[p]</code> 的第二次引用一般都<strong>不会</strong>访问数组）。由此我们不难构造一个最佳情况的输入使得解决动态连通性问题的用例的运行时间是线性级别的；另一方面，我们也可以构造一个最坏情况的输入，此时它的运行时间是平方级别的（请见图 1.5.6 和下面的命题 G）。幸好我们不需要面对分析 quick-union 算法的问题，我们也不会仔细对比 quick-union 算法和quick-find 算法的性能，因为我们下面将会学习一种比两者的效率都高得多的算法。目前，我们可以将 quick-union 算法看做是 quick-find 算法的一种改良，因为它解决了 quick-find 算法中最主要的问题（<code>union()</code> 操作总是线性级别的）。对于一般的输入数据这个变化显然是一次改进，但 quick-union 算法仍然存在问题，我们不能保证在所有情况下它都能比 quick-find 算法快得多（对于某些输入，quick-union 算法并不比 quick-find 算法快）。</p><blockquote><p><strong>定义</strong>。一棵树的<strong>大小</strong>是它的节点的数量。树中的一个节点的<strong>深度</strong>是它到根节点的路径上的链接数。树的<strong>高度</strong>是它的所有节点中的最大深度。</p><p><strong>命题 G</strong>。quick-union 算法中的 <code>find()</code> 方法访问数组的次数为 1 加上给定触点所对应的节点的深度的两倍。<code>union()</code> 和 <code>connected()</code> 访问数组的次数为两次 <code>find()</code> 操作（如果 <code>union()</code> 中给定的两个触点分别存在于不同的树中则还需要加 1）。</p><p><strong>证明</strong>。请见代码。</p></blockquote><p>同样，假设我们使用quick-union 算法解决了动态连通性问题并最终只得到了一个分量，由命题 G 我们马上可以知道算法的运行时间在最坏情况下是平方级别的。假设输入的整数对是有序的 0-1、0-2、0-3 等，<strong>N-1</strong>对之后我们的 <strong>N</strong>个触点将全部处于相同的集合之中且由quick-union 算法得到的树的高度为 <strong>N-1</strong>，其中 0 链接到 1，1 链接到 2，2 链接到 3，如此下去（请见图 1.5.6）。由命题 G 可知，对于整数对 0-i，<code>union()</code> 操作访问数组的次数为<strong>2i+1</strong>（触点 0 的深度为 <strong>i-1</strong>，触点<strong>i</strong>的深度为 0）。因此，处理<strong>N</strong> 对整数所需的所有<code>find()</code> 操作访问数组的总次数为<strong>3+5+6+……..(2N-1)~N^2</strong>。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190724171330-8985b392.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.6　quick-union 算法的最坏情况</strong></p><h4 id="加权-quick-union-算法"><a href="#加权-quick-union-算法" class="headerlink" title="加权 quick-union 算法"></a>加权 quick-union 算法</h4><p>幸好，我们只需简单地修改 quick-union 算法就能保证像这样的糟糕情况不再出现。与其在 <code>union()</code> 中随意将一棵树连接到另一棵树，我们现在会记录每一棵树的大小并总是将较小的树连接到较大的树上。这项改动需要添加一个数组和一些代码来记录树中的节点数，如算法 1.5 所示，但它能够大大改进算法的效率。我们将它称为<strong>加权</strong> quick-union 算法（如图 1.5.7 所示）。该算法在处理 tinyUF.txt 时构造的森林如图 1.5.8 中左侧的图所示。即使对于这个较小的例子，该算法构造的树的高度也远远小于未加权的版本所构造的树的高度。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190724171330-9977daa1.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.7　加权 quick-union</strong></p><h4 id="加权-quick-union-算法的分析"><a href="#加权-quick-union-算法的分析" class="headerlink" title="加权 quick-union 算法的分析"></a>加权 quick-union 算法的分析</h4><p>图 1.5.8 显示了加权 quick-union 算法的最坏情况。其中将要被归并的树的大小总是相等的（且总是 2 的幂）。这些树的结构看起来很复杂，但它们均含有<strong>2^n</strong>个节点，因此高度都正好是<strong>n</strong>。另外，当我们归并两个含有 <strong>2^n</strong> 个节点的树时，我们得到的树含有 <strong>2^n+1</strong> 个节点，由此将树的高度增加到了 <strong>n+1</strong>。由此推广我们可以证明加权 quick-union 算法能够保证<strong>对数级别</strong>的性能。加权 quick-union 算法的实现如算法 1.5 所示。</p><div class="hljs"><pre><code class="hljs angelscript">% java WeightedQuickUnionUF &lt; mediumUF.txt<span class="hljs-number">528</span> <span class="hljs-number">503</span><span class="hljs-number">548</span> <span class="hljs-number">523</span>...<span class="hljs-number">3</span> components% java WeightedQuickUnionUF &lt; largeUF.txt<span class="hljs-number">786321</span> <span class="hljs-number">134521</span><span class="hljs-number">696834</span> <span class="hljs-number">98245</span>...<span class="hljs-number">6</span> components</code></pre></div><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190724171330-1515e42d.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.8　加权 quick-union 算法的轨迹（森林）</strong></p><p><strong>算法 1.5（续）　union-find 算法的实现（加权 quick-union 算法）</strong></p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190724171330-e1ed0dad.png" srcset="/img/loading.gif" alt=""></p><p>根据正文所述的森林表示方法这段代码很容易理解。我们加入了一个由触点索引的实例变量数组 <code>sz[]</code>，这样<code>union()</code> 就可以将小树的根节点连接到大树的根节点。这使得算法能够处理规模较大的问题。</p><p><strong>命题 H</strong>。对于 <strong>N</strong> 个触点，加权 quick-union 算法构造的森林中的任意节点的深度最多为<strong>lgN</strong>。</p><p><strong>证明</strong>。我们可以用归纳法证明一个更强的命题，即森林中大小为<strong>k</strong>的树的高度最多为 <strong>lgk</strong>。在原始情况下，当 <strong>k</strong> 等于 1 时树的高度为 0。根据归纳法，我们假设大小为<strong>i</strong> 的树的高度最多为 <strong>lgi</strong>，其中 <strong>i&lt;k</strong>。设<strong>i&lt;=j</strong>且 <strong>i+j=k</strong>，当我们将大小为 <strong>i</strong>和大小为 <strong>j</strong> 的树归并时，quick-union 算法和加权 quick-union 算法中触点与深度示例如图 1.5.9 所示。小树中的所有节点的深度增加了 1，但它们现在所在的树的大小为 <strong>i+j=k</strong>，而 <strong>1+lgi=lg(i+i)&lt;=lg(i+j)=lgk</strong>，性质成立。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190724171330-9016b2b2.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.9　quick-union 算法与加权 quick-union 算法的对比（100 个触点，88 次 <code>union()</code> 操作）</strong></p><blockquote><p><strong>推论</strong>。对于加权 quick-union 算法和 <strong>N</strong> 个触点，在最坏情况下 <code>find()</code>、<code>connected()</code> 和 <code>union()</code> 的成本的增长数量级为<strong>logN</strong>。</p><p><strong>证明</strong>。在森林中，对于从一个节点到它的根节点的路径上的每个节点，每种操作最多都只会访问数组常数次。</p></blockquote><p>对于动态连通性问题，命题H 和它的推论的实际意义在于加权quick-union 算法是三种算法中唯一可以用于解决大型实际问题的算法。加权quick-union 算法处理<strong>N</strong>个触点和 <strong>M</strong> 条连接时最多访问数组 <strong>cMlgN</strong> 次，其中c 为常数。这个结果和 quick-find 算法（以及某些情况下的quick-union 算法）需要访问数组<strong>至少MN</strong> 次形成了鲜明的对比。因此，有了加权quick-union 算法我们就能保证能够在合理的时间范围内解决实际中的大规模动态连通性问题。只需要多写几行代码，我们所得到的程序在处理实际应用中的大型动态连通性问题时就会比简单的算法快数百万倍。</p><p>图 1.5.9 显示的是一个含有 100 个触点的例子。从图中我们可以很明显地看到，加权 quick-union 算法中远离根节点的节点相对较少。事实上，只含有一个节点的树被归并到更大的树中的情况很常见，这样该节点到根节点的距离也只有一条链接而已。针对大规模问题的经验性研究告诉我们，加权 quick-union 算法在解决实际问题时一般都能在<strong>常数</strong>时间内完成每个操作（如表 1.5.3 所示）。我们可能很难找到比它效率更高的算法了。</p><p><strong>表 1.5.3　各种 union-find 算法的性能特点</strong></p><table><thead><tr><th>算法</th><th>存在 <img src="https://private.codecogs.com/gif.latex?N" srcset="/img/loading.gif" alt="null"> 个触点时成本的增长数量级（最坏情况下）</th></tr></thead><tbody><tr><td>构造函数</td><td><code>union()</code></td></tr><tr><td>quick-find 算法</td><td><strong>N</strong></td></tr><tr><td>quick-union 算法</td><td><strong>N</strong></td></tr><tr><td>加权 quick-union 算法</td><td><strong>N</strong></td></tr><tr><td>使用路径压缩的加权 quick-union 算法</td><td><strong>N</strong></td></tr><tr><td>理想情况</td><td><strong>N</strong></td></tr></tbody></table><h4 id="最优算法"><a href="#最优算法" class="headerlink" title="最优算法"></a>最优算法</h4><p>们可以找到一种能够<strong>保证</strong>在常数时间内完成各种操作的算法吗？这个问题非常困难并且困扰了研究者们许多年。在寻找答案的过程中，大家研究了 quick-union 算法和加权 quick-union 算法的各种变体。例如，下面这种<strong>路径压缩</strong>方法很容易实现。理想情况下，我们希望每个节点都直接链接到它的根节点上，但我们又不想像 quick-find 算法那样通过修改大量链接做到这一点。我们接近这种理想状态的方式很简单，就是在检查节点的同时将它们直接链接到根节点。这种方法乍一看很激进，但它的实现非常容易，而且这些树并没有阻止我们进行这种修改的特殊结构：如果这么做能够改进算法的效率，我们就应该实现它。要实现路径压缩，只需要为<code>find()</code> 添加一个循环，将在路径上遇到的所有节点都直接链接到根节点。我们所得到的结果是几乎完全扁平化的树，它和 quick-find 算法理想情况下所得到的树非常接近。这种方法即简单又有效，但在实际情况下已经不太可能对加权 quick-union 算法继续进行任何改进了（请见练习 1.5.24）。对该情况的理论研究结果非常复杂也值得我们注意：<strong>路径压缩的加权 quick-union 算法是最优的算法</strong>，但并非所有操作<strong>都能在常数时间内完成</strong>。也就是说，使用路径压缩的加权 quick-union 算法的每个操作在在最坏情况下（即均摊后）都不是常数级别的，而且<strong>不存在</strong>其他算法能够保证 union-find 算法的所有操作在均摊后都是常数级别的（在非常一般的 cell probe 模型之下）。使用路径压缩的加权 quick-union 算法已经是我们对于这个问题能够给出的最优解了。</p><h4 id="均摊成本的图像"><a href="#均摊成本的图像" class="headerlink" title="均摊成本的图像"></a>均摊成本的图像</h4><p>与对其他任何数据结构实现的讨论一样，我们应该按照 1.4 节中的讨论在实验中用典型的用例验证我们对算法性能的猜想。图 1.5.10 详细显示了我们的动态连通性问题的开发用例在使用各种算法处理一份含有 625 个触点的样例数据（mediumUF.txt）时的性能。绘制这种图像很简单（请见练习 1.5.16）：在处理第 <strong>i</strong> 个连接时，用一个变量 <code>cost</code> 记录其间访问数组（<code>id[]</code> 或 <code>sz[]</code>）的次数，并用一个变量 <code>total</code> 记录到目前为止数组访问的总次数。我们在 <code>(i, cost)</code> 处画一个灰点，在 <code>(i, total/i)</code> 处画一个红点，红点表示的是每个操作的平均成本，即均摊成本。图像能够帮助我们更好地理解算法的行为。对于 quick-find 算法，每次 <code>union()</code> 操作都至少访问数组 625 次（每归并一个分量还要加 1，最多再加 625），每次 <code>connected()</code> 操作都访问数组 2 次。一开始，大多数连接都会产生一个 <code>union()</code> 调用，因此累计平均值徘徊在 625 左右；后来，大多数连接产生的 <code>connected()</code> 调用会跳过 <code>union()</code>，因此累计平均值开始下降，但仍保持了相对较高的水平（能够产生大量 <code>connected()</code> 调用并跳过 <code>union()</code>的输入性能要好得多，例子请见练习 1.5.23）。对于 quick-union 算法，所有的操作在初始阶段访问数组的次数都不多；到了后期，树的高度成为一个重要因素，均摊成本的增长很明显。对于加权 quick-union 算法，树的高度一直很小，没有任何昂贵的操作，均摊成本也很低。这些实验验证了我们的结论，显然非常有必要实现加权 quick-union 算法，在解决实际问题时已经没有多少进一步改进的空间了。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20190724171330-59170f78.png" srcset="/img/loading.gif" alt=""></p><p><strong>图 1.5.10　所有操作的总成本（625 个触点）</strong></p><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><p>直观感觉上，我们学习的每种 UF 的实现都改进了上一个版本的实现，但这个过程并不突兀，因为我们可以总结学者们对这些算法多年的研究。我们很明确地说明了问题，解决方法的实现也很简单，因此可以用经验性的数据评估各个算法的优劣。另外，还可以通过这些研究验证将算法的性能量化的数学结论。只要可能，我们在本书中研究各种基础问题时都会遵循类似于本节中讨论union-find 问题时的基本步骤，在这里我们要再次强调它们。</p><ul><li>完整而详细地定义问题，找出解决问题所必需的基本抽象操作并定义一份 API。</li><li>简洁地实现一种初级算法，给出一个精心组织的开发用例并使用实际数据作为输入。</li><li>当实现所能解决的问题的最大规模达不到期望时决定改进还是放弃。</li><li>逐步改进实现，通过经验性分析或（和）数学分析验证改进后的效果。</li><li>用更高层次的抽象表示数据结构或算法来设计更高级的改进版本。</li><li>如果可能尽量为最坏情况下的性能提供保证，但在处理普通数据时也要有良好的性能。</li><li>在适当的时候将更细致的深入研究留给有经验的研究者并继续解决下一个问题。</li></ul><p>我们从 union-find 问题中可以看到，算法设计在解决实际问题时能够为程序的性能带来惊人的提高，这种潜力使它成为热门研究领域。还有什么其他类型的设计行为可能将成本降为原来的数百万甚至数十亿分之一呢？</p><p>设计高效的算法是一种很有成就感的智力活动，同时也能够产生直接的实际效益。正如动态连通性问题所示，为解决一个简单的问题我们学习了许多算法，它们不但有用有趣，也精巧而引人入胜。我们还将遇到许多新颖独特的算法，它们都是人们在数十年以来为解决许多实际问题而发明的。随着计算机算法在科学和商业领域的应用范围越来越广，能够使用高效的算法来解决老问题并为新问题开发有效的解决方案也越来越重要了。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马踏棋盘（骑士周游问题）</title>
    <link href="/2019/08/10/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%EF%BC%88%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98%EF%BC%89/"/>
    <url>/2019/08/10/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%EF%BC%88%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>关于马踏棋盘的基本过程：国际象棋的棋盘为 8*8 的方格棋盘。现将”马”放在任意指定的方格中，按照”马”走棋的规则将”马”进行移动。要求每个方格只能进入一次，最终使得”马”走遍棋盘的64个方格。</p><h2 id="实现-没有优化"><a href="#实现-没有优化" class="headerlink" title="实现(没有优化)"></a>实现(没有优化)</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">horse</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] load = &#123;&#123;-<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>&#125;, &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>&#125;, &#123;-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;&#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] chessBoard;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[][] check;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">horse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.chessBoard = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];        <span class="hljs-keyword">this</span>.check = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;                check[i][j] = <span class="hljs-keyword">false</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">horseTrav</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        chessBoard[x][y] = count;        check[x][y] = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">64</span>) &#123;            printChessBoard();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">int</span> nextX = x + load[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> nextY = y + load[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (judgeNext(nextX, nextY)) &#123;                count++;                <span class="hljs-keyword">boolean</span> flag = horseTrav(nextX, nextY, count);                <span class="hljs-keyword">if</span> (!flag) &#123;                    check[nextX][nextY] = <span class="hljs-keyword">false</span>;                    count--;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judgeNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">8</span> || x &lt; <span class="hljs-number">0</span> || y &gt;= <span class="hljs-number">8</span> || y &lt; <span class="hljs-number">0</span> || check[x][y]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printChessBoard</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : chessBoard) &#123;            System.out.println(Arrays.toString(arr));        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        horse h = <span class="hljs-keyword">new</span> horse();        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        h.horseTrav(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println(<span class="hljs-string">"共耗时:"</span> + (end - start) + <span class="hljs-string">"ms"</span>);    &#125;&#125;</code></pre></div><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/8332bd50.PNG" srcset="/img/loading.gif" alt=""></p><h2 id="贪心优化后"><a href="#贪心优化后" class="headerlink" title="贪心优化后"></a>贪心优化后</h2><p>代码:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">horse</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>[][] load = &#123;&#123;-<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>&#125;, &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>&#125;, &#123;-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>&#125;&#125;;  <span class="hljs-comment">//马下一步的方向</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] chessBoard;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">horse</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.chessBoard = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;                chessBoard[i][j] = <span class="hljs-number">0</span>;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">horseTrav</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-comment">//64个格子都走过,退出,打印棋盘</span>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">64</span>) &#123;            printChessBoard();            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//判断当前位置是否能走</span>        <span class="hljs-keyword">if</span> (!judgeNext(x, y)) &#123;            <span class="hljs-keyword">return</span>;        &#125;        count++;        chessBoard[x][y] = count;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 贪心算法,记录下一个可走位置的可走步数,将步数最少的可走位置作为下一步的位置</span><span class="hljs-comment">         * 网上的解释是：“选择最难走的路，才能走的远”</span><span class="hljs-comment">         * 这边个人理解为,有些位置的下一步很少,如果不先遍历它的话以后可能会很难遍历到它。</span><span class="hljs-comment">         * 甚至极端一点的情况是，如果现在不遍历它，以后都遍历不到了。遍历不成功的时候只能回溯，一直回溯到此刻的点，然后选了这个点以后才能完成，这就浪费了大量的时间。</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">int</span>[] next = &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">int</span> x_next = x + load[i][<span class="hljs-number">0</span>];            <span class="hljs-keyword">int</span> y_next = y + load[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (judgeNext(x_next, y_next)) &#123;                next[i]++;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;                    <span class="hljs-keyword">int</span> m_next_next = x_next + load[j][<span class="hljs-number">0</span>];                    <span class="hljs-keyword">int</span> n_next_next = y_next + load[j][<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span> (judgeNext(m_next_next, n_next_next))                        next[i]++;                &#125;            &#125;        &#125;        <span class="hljs-keyword">int</span> direct = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录下一步的方向</span>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">if</span>(next[i] != -<span class="hljs-number">1</span> &amp;&amp; next[i] &lt; min)&#123;                min = next[i];                direct = i;            &#125;        &#125;        <span class="hljs-keyword">int</span> nextX = x + load[direct][<span class="hljs-number">0</span>];        <span class="hljs-keyword">int</span> nextY = y + load[direct][<span class="hljs-number">1</span>];        <span class="hljs-comment">//递归,进行下一步</span>        horseTrav(nextX, nextY, count);        <span class="hljs-comment">//回溯,对应位置标记为0</span>        chessBoard[x][y] = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judgeNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;        <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">8</span> || x &lt; <span class="hljs-number">0</span> || y &gt;= <span class="hljs-number">8</span> || y &lt; <span class="hljs-number">0</span> || chessBoard[x][y] != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printChessBoard</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">7</span>; j++) &#123;                System.out.print(String.format(<span class="hljs-string">"%2d"</span>,chessBoard[i][j]) + <span class="hljs-string">" "</span>);            &#125;            System.out.println(String.format(<span class="hljs-string">"%2d"</span>,chessBoard[i][<span class="hljs-number">7</span>]));        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        horse h = <span class="hljs-keyword">new</span> horse();        System.out.println(<span class="hljs-string">"\t  递归+贪心优化"</span>);        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();        h.horseTrav(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        System.out.println();        System.out.println(<span class="hljs-string">"共耗时:"</span> + (end - start) + <span class="hljs-string">"ms"</span>);    &#125;&#125;</code></pre></div><p>结果<br><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98%E9%80%92%E5%BD%92%E8%B4%AA%E5%BF%83%E4%BC%98%E5%8C%96-61d04661.PNG" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
