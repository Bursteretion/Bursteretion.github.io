<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p><p><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</p><p><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory*。接着定义工厂类 *ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。然后创建一个工厂创造器/生成器类 <em>FactoryProducer</em>。</p><p>演示类使用 <em>FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape<em>Type（</em>CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。同时它还向 *AbstractFactory</em> 传递颜色信息 <em>Color</em>Type（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt=""></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建两个接口:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绘图方法，由实现类来实现此方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Color</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 填充颜色方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制矩形......"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制圆形......"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制正方形......"</span>);        &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Color</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"填充蓝色........."</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Green</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Color</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"填充绿色........."</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Red</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Color</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"填充红色........."</span>);    &#125;&#125;</code></pre></div><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建三个枚举类，可供选择Shape类型和Color类型及Factory类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ShapeType &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 矩形</span><span class="hljs-comment">     */</span>    RECTANGLE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 圆形</span><span class="hljs-comment">     */</span>    CIRCLE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 正方形</span><span class="hljs-comment">     */</span>    SQUARE;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ColorType &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 红色</span><span class="hljs-comment">     */</span>    RED,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绿色</span><span class="hljs-comment">     */</span>    GREEN,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 蓝色</span><span class="hljs-comment">     */</span>    BLUE;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FactoryType &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 图形工厂</span><span class="hljs-comment">     */</span>    SHAPE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 颜色工厂</span><span class="hljs-comment">     */</span>    COLOR;&#125;</code></pre></div><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>为 Color 和 Shape 对象创建抽象类来获取工厂。。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过指定类型获取图形</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> shapeType 图形类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Shape 图形</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Shape <span class="hljs-title">getShape</span><span class="hljs-params">(ShapeType shapeType)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过指定类型获取颜色</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> colorType 颜色类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Color 颜色</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Color <span class="hljs-title">getColor</span><span class="hljs-params">(ColorType colorType)</span></span>;&#125;</code></pre></div><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShapeFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">getShape</span><span class="hljs-params">(ShapeType shapeType)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (shapeType) &#123;            <span class="hljs-keyword">case</span> CIRCLE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circle();            <span class="hljs-keyword">case</span> SQUARE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Square();            <span class="hljs-keyword">case</span> RECTANGLE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">getColor</span><span class="hljs-params">(ColorType colorType)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Shape <span class="hljs-title">getShape</span><span class="hljs-params">(ShapeType shapeType)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Color <span class="hljs-title">getColor</span><span class="hljs-params">(ColorType colorType)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (colorType) &#123;            <span class="hljs-keyword">case</span> RED:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Red();            <span class="hljs-keyword">case</span> GREEN:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Green();            <span class="hljs-keyword">case</span> BLUE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Blue();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="步骤-7"><a href="#步骤-7" class="headerlink" title="步骤 7"></a>步骤 7</h3><p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryProducer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据指定工厂类型获取工厂</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> factoryType 工厂类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Factory</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractFactory <span class="hljs-title">getFactory</span><span class="hljs-params">(FactoryType factoryType)</span></span>&#123;        <span class="hljs-keyword">switch</span> (factoryType) &#123;            <span class="hljs-keyword">case</span> COLOR:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ColorFactory();            <span class="hljs-keyword">case</span> SHAPE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ShapeFactory();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="步骤-8"><a href="#步骤-8" class="headerlink" title="步骤 8"></a>步骤 8</h3><p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactoryTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 获取图形工厂</span>        AbstractFactory shapeFactory = FactoryProducer.getFactory(FactoryType.SHAPE);        <span class="hljs-keyword">assert</span> shapeFactory != <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 获取形状为 Rectangle 的对象</span>        Shape shape_r = shapeFactory.getShape(ShapeType.RECTANGLE);        shape_r.draw();        <span class="hljs-comment">// 获取形状为 Circle 的对象</span>        Shape shape_c = shapeFactory.getShape(ShapeType.CIRCLE);        shape_c.draw();        <span class="hljs-comment">// 获取形状为 Square 的对象</span>        Shape shape_s = shapeFactory.getShape(ShapeType.SQUARE);        shape_s.draw();        <span class="hljs-comment">// 获取颜色工厂</span>        AbstractFactory colorFactory = FactoryProducer.getFactory(FactoryType.COLOR);        <span class="hljs-keyword">assert</span> colorFactory != <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 获取颜色为 Red 的对象</span>        Color color_r = colorFactory.getColor(ColorType.RED);        color_r.fill();        <span class="hljs-comment">// 获取颜色为 Green 的对象</span>        Color color_g = colorFactory.getColor(ColorType.GREEN);        color_g.fill();        <span class="hljs-comment">// 获取颜色为 Blue 的对象</span>        Color color_b = colorFactory.getColor(ColorType.BLUE);        color_b.fill();    &#125;&#125;</code></pre></div><h3 id="步骤-9"><a href="#步骤-9" class="headerlink" title="步骤 9"></a>步骤 9</h3><p>执行程序，输出结果：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200805114114.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p><strong>主要解决：</strong>主要解决接口选择的问题。</p><p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p><p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p><strong>关键代码：</strong>创建过程在其子类执行。</p><p><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory</em>。</p><p>演示类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递所需对象的类型。从而获取所需对象</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt=""></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个接口:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绘图方法，由实现类来实现此方法</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制矩形......"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制圆形......"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Shape</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"绘制正方形......"</span>);        &#125;&#125;</code></pre></div><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建一个枚举类，可供选择Shape类型。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ShapeType &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 矩形</span><span class="hljs-comment">     */</span>    RECTANGLE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 圆形</span><span class="hljs-comment">     */</span>    CIRCLE,    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 正方形</span><span class="hljs-comment">     */</span>    SQUARE;&#125;</code></pre></div><h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>创建一个工厂，生成基于给定信息的实体类的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShapeFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ShapeFactory</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Shape <span class="hljs-title">createShape</span><span class="hljs-params">(ShapeType shapeType)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (shapeType) &#123;            <span class="hljs-keyword">case</span> CIRCLE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Circle();            <span class="hljs-keyword">case</span> SQUARE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Square();            <span class="hljs-keyword">case</span> RECTANGLE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Rectangle();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h3><p>使用该工厂，通过传递类型信息来获取实体类的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-05</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        Objects.requireNonNull(ShapeFactory.createShape(ShapeType.CIRCLE)).draw();        Objects.requireNonNull(ShapeFactory.createShape(ShapeType.RECTANGLE)).draw();        Objects.requireNonNull(ShapeFactory.createShape(ShapeType.SQUARE)).draw();    &#125;&#125;</code></pre></div><h3 id="步骤-6"><a href="#步骤-6" class="headerlink" title="步骤 6"></a>步骤 6</h3><p>执行程序，输出结果：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/20200805101451.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="/2020/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。</li></ul><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong>构造函数是私有的。</p><p><strong>应用实例：</strong></p><ul><li>1、一个班级只有一个班主任。</li><li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ul><p><strong>优点：</strong></p><ul><li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>2、避免对资源的多重占用（比如写文件操作）。</li></ul><p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong></p><ul><li>1、要求生产唯一序列号。</li><li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li><li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li></ul><p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>SingletonHungryMan</em> 类。 <em>SingletonHungryMan</em> 类有它的私有构造函数和本身的一个静态实例。</p><p> <em>SingletonHungryMan</em> 类提供了一个静态方法，供外界获取它的静态实例。演示类使用  <em>SingletonHungryMan</em> 类来获取  <em>SingletonHungryMan</em>对象。</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-20200804191751504.png" srcset="/img/loading.gif" alt=""></p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个 <em>SingleObject</em> 类。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleObject</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建 SingleObject 的一个对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingleObject instance = <span class="hljs-keyword">new</span> SingleObject();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 让构造函数为 private，这样该类就不会被实例化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingleObject</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取唯一可用的对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> instance</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showMessage</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"Hello World!"</span>);    &#125;&#125;</code></pre></div><h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>从  <em>SingleObject</em> 类获取唯一的对象。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleObjectTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 不合法的构造函数，编译时错误：构造函数 SingleObject() 是不可见的</span>        <span class="hljs-comment">// SingleObject object = new SingleObject();</span>        <span class="hljs-comment">//获取唯一可用的对象</span>        SingleObject object = SingleObject.getInstance();        <span class="hljs-comment">//显示消息</span>        object.showMessage();    &#125;&#125;</code></pre></div><h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>执行程序，输出结果：</p><p><img src="https://gitee.com/lwjppz/PictureBed/raw/master/img/image-20200804211223102.png" srcset="/img/loading.gif" alt=""></p><h2 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h2><p>单例模式的实现有多种方式，如下所示：</p><h3 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>否</p><p><strong>实现难度：</strong>易</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的懒汉式（线程不安全）</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 起到了 Lazy Loading 的效果，但是只能在单线程下使用。</span><span class="hljs-comment"> *          2) 如果在多线程下，一个线程进入了 if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</span><span class="hljs-comment"> *             所以在多线程环境下不可使用这种方式</span><span class="hljs-comment"> *          3) 结论：在实际开发中，不要使用这种方式.</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonThreadUnSafeLazyMan</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造函数私有化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonThreadUnSafeLazyMan</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 本类内部创建实例</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonThreadUnSafeLazyMan INSTANCE;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 懒汉式（线程不安全）</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonThreadUnSafeLazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == INSTANCE) &#123;            INSTANCE = <span class="hljs-keyword">new</span> SingletonThreadUnSafeLazyMan();        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><p><strong>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</strong></p><h3 id="2、懒汉式，线程安全"><a href="#2、懒汉式，线程安全" class="headerlink" title="2、懒汉式，线程安全"></a>2、懒汉式，线程安全</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的懒汉式（线程安全）</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 解决了线程安全问题</span><span class="hljs-comment"> *          2) 效率太低了，每个线程在想获得类的实例时候，执行 getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，</span><span class="hljs-comment"> *             后面的想获得该类实例，直接 return 就行了。方法进行同步效率太低</span><span class="hljs-comment"> *          3) 结论：在实际开发中，不推荐使用这种方式</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonThreadSafeLazyMan</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造函数私有化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonThreadSafeLazyMan</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 本类内部创建实例</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonThreadSafeLazyMan INSTANCE;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 懒汉式（线程安全）</span><span class="hljs-comment">     * 提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonThreadSafeLazyMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == INSTANCE) &#123;            INSTANCE = <span class="hljs-keyword">new</span> SingletonThreadSafeLazyMan();<span class="hljs-comment">//            /**</span><span class="hljs-comment">//             * 同步代码块</span><span class="hljs-comment">//             */</span><span class="hljs-comment">//            synchronized (LazyManThreadSafeSingleton.class) &#123;</span><span class="hljs-comment">//                INSTANCE = new LazyManThreadSafeSingleton()；</span><span class="hljs-comment">//            &#125;</span>        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><h3 id="3、饿汉式"><a href="#3、饿汉式" class="headerlink" title="3、饿汉式"></a>3、饿汉式</h3><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的饿汉式：</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。</span><span class="hljs-comment"> *          2) 缺点：在类装载的时候就完成实例化，没有达到 Lazy Loading 的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费</span><span class="hljs-comment"> *          3) 这种方式基于 ClassLoader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，在单例模式中大多数都是调用 getInstance 方法，</span><span class="hljs-comment"> *             但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 lazy loading 的效果</span><span class="hljs-comment"> *          4) 结论：这种单例模式可用，可能造成内存浪费</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHungryMan</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 让构造函数为 private，这样该类在外部就无法就不会被实例化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonHungryMan</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 1、本类内部直接创建 SingletonHungryMan 的一个对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonHungryMan INSTANCE = <span class="hljs-keyword">new</span> SingletonHungryMan();<span class="hljs-comment">//    /**</span><span class="hljs-comment">//     * 2、在静态代码块中，创建单例对象</span><span class="hljs-comment">//     */</span><span class="hljs-comment">//    static &#123;</span><span class="hljs-comment">//        INSTANCE = new SingletonHungryMan();</span><span class="hljs-comment">//    &#125;</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取唯一可用的对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonHungryMan <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><h3 id="4、双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4、双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4、双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4、双检锁/双重校验锁（DCL，即 double-checked locking）</h3><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>较复杂</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的双重检查式（线程安全）</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) Double-Check 概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 if (null == INSTANCE) 检查，这样就可以保证线程安全了。</span><span class="hljs-comment"> *          2) 这样，实例化代码只用执行一次，后面再次访问时，判断 if (null == INSTANCE)，直接 return 实例化对象，也避免的反复进行方法同步。</span><span class="hljs-comment"> *          3) 线程安全；延迟加载；效率较高</span><span class="hljs-comment"> *          4) 结论：在实际开发中，推荐使用这种单例设计模式</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDoubleCheck</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDoubleCheck</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 内部实例化对象</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDoubleCheck INSTANCE;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span><span class="hljs-comment">     * 同时保证了效率, 推荐使用</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDoubleCheck <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == INSTANCE) &#123;            <span class="hljs-keyword">synchronized</span> (SingletonDoubleCheck<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == INSTANCE) &#123;                    INSTANCE = <span class="hljs-keyword">new</span> SingletonDoubleCheck();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> INSTANCE;    &#125;&#125;</code></pre></div><h3 id="5、登记式-静态内部类"><a href="#5、登记式-静态内部类" class="headerlink" title="5、登记式/静态内部类"></a>5、登记式/静态内部类</h3><p><strong>是否 Lazy 初始化：</strong>是</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>一般</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的静态内部类式</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</span><span class="hljs-comment"> *          2) 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，</span><span class="hljs-comment"> *             从而完成 Singleton 的实例化。</span><span class="hljs-comment"> *          3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</span><span class="hljs-comment"> *          4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</span><span class="hljs-comment"> *          5) 结论：推荐使用.</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonStaticInnerClass</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造器私有化</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonStaticInnerClass</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 写一个静态内部类,该类中有一个静态属性 SingletonStaticInnerClass</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonStaticInnerClass INSTANCE = <span class="hljs-keyword">new</span> SingletonStaticInnerClass();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 提供一个静态的公有方法，直接返回 Singleton.INSTANCE</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Singleton.INSTANCE</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonStaticInnerClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Singleton.INSTANCE;    &#125;&#125;</code></pre></div><h3 id="6、枚举"><a href="#6、枚举" class="headerlink" title="6、枚举"></a>6、枚举</h3><p><strong>JDK 版本：</strong>JDK1.5 起</p><p><strong>是否 Lazy 初始化：</strong>否</p><p><strong>是否多线程安全：</strong>是</p><p><strong>实现难度：</strong>易</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> : 2020-08-04</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;</span><span class="hljs-comment"> *     单例模式的枚举式</span><span class="hljs-comment"> *      优缺点说明：</span><span class="hljs-comment"> *          1) 这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</span><span class="hljs-comment"> *          2) 这种方式是 Effective Java 作者 Josh Bloch  提倡的方式</span><span class="hljs-comment"> *          3) 结论：推荐使用</span><span class="hljs-comment"> * &lt;/p&gt;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span>  SingletonEnum &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 使用枚举，可以实现单例, 推荐</span><span class="hljs-comment">     */</span>    INSTANCE;&#125;</code></pre></div><p><strong>经验之谈：</strong>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java - 静态代理和动态代理</title>
    <link href="/2020/07/13/Java%20-%20%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2020/07/13/Java%20-%20%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>由于后面要写的文章需要用到代理的知识，所以先写这篇文章为后面的知识做铺垫。</p><blockquote><p>代理就是定义一个行为和某类的对象相似，而又潜在地表示了所有继承自该类的对象的东西。</p></blockquote><p><img src="https://i.loli.net/2020/07/13/GdQDHc7TpaF2Bqv.png" srcset="/img/loading.gif" alt="image.png"></p><p>在说动态代理之前，必须先聊聊什么是静态代理。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>假设现在有这么一个需求：在某个类的方法前后打印日志。</p><p>那么要如何做到在<strong>不修改源代码前提下</strong>，来实现这个功能呢？</p><p>首先想到的就是静态代理，具体做法是：</p><ol><li><p>为这个类编写一个对应的代理类，并让它实现与目标类相同的接口。<br><img src="https://i.loli.net/2020/07/13/a9Ynr3pGFRkeHd1.png" srcset="/img/loading.gif" alt="image.png"></p></li><li><p>在创建代理对象是，通过构造函数传入一个实现了该接口的目标对象，然后在代理对象内部调用目标对象的同名方法，并在调用之前后打印日志。也就是说，<strong>代理对象 = 目标对象 + 增强代码</strong>。而有了代理对象后，就不需要原对象了。<br><img src="https://i.loli.net/2020/07/13/eT2AvUkB3EuMR15.png" srcset="/img/loading.gif" alt="image.png"></p></li></ol><h3 id="编写代码进行测试"><a href="#编写代码进行测试" class="headerlink" title="编写代码进行测试"></a>编写代码进行测试</h3><ol><li>首先先新建一个接口<strong>A</strong><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div></li></ol><p>2.创建一个对应的实现类 <strong>AImpl</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">2</span>;    &#125;&#125;</code></pre></div><ol start="3"><li>接下来建立一个目标对象的代理类 <strong>AProxy</strong><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AProxy</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> A target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AProxy</span><span class="hljs-params">(A target)</span> </span>&#123;        <span class="hljs-keyword">this</span>.target = target;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"方法执行之前..."</span>);        System.out.println(target.add());        System.out.println(<span class="hljs-string">"方法执行之后..."</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div></li><li>运行 代理类中的 <strong>add</strong> 方法进行测试<br><img src="https://i.loli.net/2020/07/13/IWo8VOueqfNcSnm.png" srcset="/img/loading.gif" alt="image.png"></li></ol><p>结果在我们意料之中，这样就实现了一个简单的静态代理。</p><h3 id="静态代理的缺陷"><a href="#静态代理的缺陷" class="headerlink" title="静态代理的缺陷"></a>静态代理的缺陷</h3><p>当在类少的时候还好，但是当你的项目中有成千上万个类时，你需要为每个类都写一个对应的代理类，这工作量太大了。</p><p>我们能不能少写或者不写代理类，却能完成代理功能呢？接下来我们来介绍动态代理。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>Java的动态代理可以动态的创建代理并动态的处理对所代理方法的调用。动态代理有两种实现方法，一种是使用JDK自带的，一种是使用Cglib实现。在这里就先聊聊JDK的动态代理是怎么实现的。</p><p>JDK中提供了 <strong>invocationHandler</strong> 接口和 <strong>Proxy</strong> 类，借助这两个工具可以达到我们想要的效果。</p><h3 id="InvocationHandler-接口"><a href="#InvocationHandler-接口" class="headerlink" title="InvocationHandler 接口"></a>InvocationHandler 接口</h3><p><strong>InvocationHandler</strong> 接口是 <strong>proxy</strong> 代理实例的调用处理程序实现的一个接口，每一个proxy代理实例都有一个关联的调用处理程序；在代理实例调用方法时，方法调用被编码分派到调用处理程序的invoke方法。</p><h3 id="Proxy-类"><a href="#Proxy-类" class="headerlink" title="Proxy 类"></a>Proxy 类</h3><p><strong>Proxy</strong> 类就是用来创建一个代理对象的类，它提供了很多方法，但是我们最常用的是<strong>newProxyInstance</strong> 方法。</p><p>下面我们先来看看代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ClassLoader classLoader = ProxyTest<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>;        Class&lt;?&gt;[] interfaces = &#123;A<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;</span>;        A aImpl = <span class="hljs-keyword">new</span> AImpl();        A aProxy = (A) Proxy.newProxyInstance(classLoader, interfaces, <span class="hljs-keyword">new</span> InvocationHandler() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                Object result = <span class="hljs-keyword">null</span>;                System.out.println(<span class="hljs-string">"方法执行之前"</span>);                result = method.invoke(aImpl, args);                System.out.println(result);                System.out.println(<span class="hljs-string">"方法执行之后"</span>);                <span class="hljs-keyword">return</span> result;            &#125;        &#125;);        aProxy.add();    &#125;&#125;</code></pre></div><p>上面这段代码是什么意思呢？</p><ol><li><p>首先我们可以调用 <strong>Proxy</strong> 类的 <strong>newProxyInstance</strong> 方法获取代理对象。查看源码可以看到该方法需要接收三个参数<br><img src="https://i.loli.net/2020/07/13/owTRJa1cFGzv48i.png" srcset="/img/loading.gif" alt="image.png"></p><ul><li>ClassLoader loader，类加载器， 随便找个类的加载器就可以</li><li>Class&lt;?&gt;[] interfaces，目标对象实现的接口</li><li>InvocationHandler h，传入一个实现了该接口的实现类</li></ul></li><li><p>获取 <strong>Proxy.newProxyInstance(…)</strong> 创建的代理对象，调用其方法</p></li></ol><p>来看结果：</p><p><img src="https://i.loli.net/2020/07/13/jUCO2fWtHz69J4Z.png" srcset="/img/loading.gif" alt="image.png"></p><p>完美！</p><p>我们来分析一下整个流程：</p><ol><li>通过 <strong>Proxy.newProxyInstance(…)</strong> 获得代理对象</li><li>代理对象调用 <strong>add</strong> 方法</li><li>JVM通过将方法导向致 <strong>invoke</strong> 方法</li><li>执行<strong>invoke</strong>方法，若有返回值则返回</li></ol><p><img src="https://i.loli.net/2020/07/13/XzclsrGQuFyEwZA.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>静态代理实现较简单，代理类在编译期生成，效率高。缺点是会生成大量的代理类。</li><li>JDK动态代理不要求代理类和委托类实现同一个接口，但是委托类需要实现接口，代理类需要实现InvocationHandler接口。</li><li>动态代理要求代理类InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理</tag>
      
      <tag>Proxy</tag>
      
      <tag>静态代理</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring - 组件注册（二）</title>
    <link href="/2020/07/03/Spring%20-%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/07/03/Spring%20-%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="Conditional-按照条件注册"><a href="#Conditional-按照条件注册" class="headerlink" title="@Conditional - 按照条件注册"></a>@Conditional - 按照条件注册</h3><h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Conditional &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * All &#123;<span class="hljs-doctag">@link</span> Condition Conditions&#125; that must &#123;<span class="hljs-doctag">@linkplain</span> Condition#matches match&#125;</span><span class="hljs-comment"> * in order for the component to be registered.</span><span class="hljs-comment"> */</span>Class&lt;? extends Condition&gt;[] value();&#125;</code></pre></div><p>我们需要传入一个 <strong>Class&lt;? extends Condition&gt;</strong> 数组，且每个自定义的 <strong>condition</strong> 都需要实现 <strong>Condition</strong> 接口。<br>我们在这里先创建两个Condition，分别判断是Windows系统还是Linux系统</p><h4 id="WindowsCondition"><a href="#WindowsCondition" class="headerlink" title="WindowsCondition"></a><strong>WindowsCondition</strong></h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;<span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Condition;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ConditionContext;<span class="hljs-keyword">import</span> org.springframework.core.env.Environment;<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/2 17:21</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> * 判断是否是Windows系统</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowsCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 判断条件能使用的上下文（环境</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> metadata 注释信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true or false</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;        <span class="hljs-comment">// 获取到IOC使用的beanfactory</span>        ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();        <span class="hljs-comment">// 获取类加载器</span>        ClassLoader classLoader = context.getClassLoader();        <span class="hljs-comment">// 获取当前环境信息</span>        Environment environment = context.getEnvironment();        <span class="hljs-comment">// 获取到bean定义的注册类</span>        BeanDefinitionRegistry registry = context.getRegistry();        String property = environment.getProperty(<span class="hljs-string">"os.name"</span>);        <span class="hljs-keyword">assert</span> property != <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> property.contains(<span class="hljs-string">"Windows"</span>);    &#125;&#125;</code></pre></div><h4 id="LinuxCondition"><a href="#LinuxCondition" class="headerlink" title="LinuxCondition"></a>LinuxCondition</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.support.BeanDefinitionRegistry;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Condition;<span class="hljs-keyword">import</span> org.springframework.context.annotation.ConditionContext;<span class="hljs-keyword">import</span> org.springframework.core.env.Environment;<span class="hljs-keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/2 17:20</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> * 判断是否是Linux系统</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinuxCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;        Environment environment = context.getEnvironment();        <span class="hljs-comment">// 获取到bean定义的注册类</span>        BeanDefinitionRegistry registry = context.getRegistry();        String property = environment.getProperty(<span class="hljs-string">"os.name"</span>);        <span class="hljs-keyword">assert</span> property != <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> property.contains(<span class="hljs-string">"Linux"</span>);    &#125;&#125;</code></pre></div><h4 id="在注册的bean上面加入-Condition注解"><a href="#在注册的bean上面加入-Condition注解" class="headerlink" title="在注册的bean上面加入@Condition注解"></a>在注册的bean上面加入@Condition注解</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.lwjppz.config;<span class="hljs-keyword">import</span> cn.lwjppz.condition.LinuxCondition;<span class="hljs-keyword">import</span> cn.lwjppz.condition.WindowsCondition;<span class="hljs-keyword">import</span> cn.lwjppz.entites.User;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Conditional;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/2 17:31</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig3</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Conditional</span>(&#123;Condition&#125;) 按照一定的条件进行判断，满足条件给容器中注册bean</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 如果是 Windows 系统 则给容器注册 bill</span><span class="hljs-comment">     * 如果是 Linux 系统，则注册 jack</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bill"</span>)    <span class="hljs-meta">@Conditional</span>(WindowsCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">user01</span> () </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>, <span class="hljs-string">"Bill"</span>, <span class="hljs-number">62</span>);    &#125;    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"jack"</span>)    <span class="hljs-meta">@Conditional</span>(LinuxCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">user02</span> () </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>, <span class="hljs-string">"jack"</span>, <span class="hljs-number">22</span>);    &#125;&#125;</code></pre></div><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><img src="https://i.loli.net/2020/07/02/K4wAfZRiLVjbXv3.png" srcset="/img/loading.gif" alt="image.png"></p><p>由于系统是Windows的，所以只给容器中加入了bill。</p><h3 id="Import-给容器中导入组件"><a href="#Import-给容器中导入组件" class="headerlink" title="@Import - 给容器中导入组件"></a>@Import - 给容器中导入组件</h3><h4 id="新建一个Color类"><a href="#新建一个Color类" class="headerlink" title="新建一个Color类"></a>新建一个Color类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span> </span>&#123;&#125;</code></pre></div><h4 id="加入-Import注解"><a href="#加入-Import注解" class="headerlink" title="加入@Import注解"></a>加入@Import注解</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.condition.LinuxCondition;<span class="hljs-keyword">import</span> cn.lwjppz.condition.WindowsCondition;<span class="hljs-keyword">import</span> cn.lwjppz.entites.Color;<span class="hljs-keyword">import</span> cn.lwjppz.entites.User;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Conditional;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Import;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/2 17:31</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-comment">// @Import 导入组件，id默认为组件的全类名</span><span class="hljs-meta">@Import</span>(Color<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">MainConfig3</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@Conditional</span>(&#123;Condition&#125;) 按照一定的条件进行判断，满足条件给容器中注册bean</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 如果是 Windows 系统 则给容器注册 bill</span><span class="hljs-comment">     * 如果是 Linux 系统，则注册 jack</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bill"</span>)    <span class="hljs-meta">@Conditional</span>(WindowsCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">user01</span> () </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>, <span class="hljs-string">"Bill"</span>, <span class="hljs-number">62</span>);    &#125;    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"jack"</span>)    <span class="hljs-meta">@Conditional</span>(LinuxCondition<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">User</span> <span class="hljs-title">user02</span> () </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>, <span class="hljs-string">"jack"</span>, <span class="hljs-number">22</span>);    &#125;&#125;</code></pre></div><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p><img src="https://ae01.alicdn.com/kf/H8ddb4400887d493fabfab45e8ee5a0962.jpg" srcset="/img/loading.gif" alt=""></p><p>可见Color已被加入容器中</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring - 组件注册（一）</title>
    <link href="/2020/07/01/Spring%20-%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/07/01/Spring%20-%20%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="Configuration-和-Bean"><a href="#Configuration-和-Bean" class="headerlink" title="@Configuration 和 @Bean"></a><strong>@Configuration</strong> 和 <strong>@Bean</strong></h3><ul><li>在 <strong>Spring</strong> 中配置类就相当于配置文件</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.entites.User;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/1 9:40</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 配置类 == 配置文件</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span>  <span class="hljs-comment">// 告诉 Spring 这是一个配置类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 给容器注册一个 Bean ，类型为返回值类型，id默认使用方法名作为id</span><span class="hljs-comment">     * 也可给<span class="hljs-doctag">@Bean</span>中传入value参数自定义id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user实例</span><span class="hljs-comment">     */</span><span class="hljs-comment">//    @Bean("user01")</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">"lwjppz"</span>, <span class="hljs-number">20</span>);    &#125;&#125;</code></pre></div><ul><li><p>测试类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.config.MainConfig;<span class="hljs-keyword">import</span> cn.lwjppz.entites.User;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 10:08</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        User user = context.getBean(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        System.out.println(user);        String[] names = context.getBeanNamesForType(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">for</span> (String name : names) &#123;            System.out.println(name);        &#125;    &#125;&#125;</code></pre></div></li><li><p>测试结果<br><img src="https://i.loli.net/2020/07/01/hix75SsOybTElNJ.png" srcset="/img/loading.gif" alt="image.png"></p></li></ul><h3 id="ComponentScan-自动扫描组件-amp-指定扫描规则"><a href="#ComponentScan-自动扫描组件-amp-指定扫描规则" class="headerlink" title="@ComponentScan - 自动扫描组件&amp;指定扫描规则"></a>@ComponentScan - 自动扫描组件&amp;指定扫描规则</h3><ul><li><p>新建UserController、UserDao、UserService，分别加上@Controller，@Repository，@Service注解<br><img src="https://i.loli.net/2020/07/01/SaBREzuIJVcvFpP.png" srcset="/img/loading.gif" alt="image.png"></p></li><li><p>测试</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    String[] names = context.getBeanDefinitionNames();    <span class="hljs-keyword">for</span> (String name : names) &#123;        System.out.println(name);    &#125;&#125;</code></pre></div></li></ul><p><img src="https://i.loli.net/2020/07/01/HfCQVFSDP7lgmbB.png" srcset="/img/loading.gif" alt="image.png"></p><h4 id="指定包扫描规则"><a href="#指定包扫描规则" class="headerlink" title="指定包扫描规则"></a>指定包扫描规则</h4><h5 id="1-指定排除规则"><a href="#1-指定排除规则" class="headerlink" title="1. 指定排除规则"></a>1. 指定排除规则</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// excludeFilters Filter[] 扫描的时候按照指定的规则排除指定的组件</span><span class="hljs-comment">// 排除加了 @Controller 和 @Service 注解的组件</span><span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.lwjppz"</span>, excludeFilters = &#123;<span class="hljs-meta">@Filter</span>(type = FilterType.ANNOTATION, classes = &#123;Controller<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Service</span>.<span class="hljs-title">class</span>&#125;)&#125;)</span></code></pre></div><p>效果：</p><p><img src="https://i.loli.net/2020/07/01/2koKjwPXUAhe4qN.png" srcset="/img/loading.gif" alt="image.png"></p><p>很明显和之前相比少了 <strong>userController</strong> 和 <strong>userService</strong>。</p><h5 id="2-指定包含规则"><a href="#2-指定包含规则" class="headerlink" title="2. 指定包含规则"></a>2. 指定包含规则</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// includeFilters Filter[] 扫描的时候只需要包含哪些组件</span><span class="hljs-comment">// 只扫描加了 @Controller 组件的组件</span><span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.lwjppz"</span>, includeFilters = &#123;<span class="hljs-meta">@Filter</span>(type = FilterType.ANNOTATION, classes = Controller<span class="hljs-class">.<span class="hljs-keyword">class</span>)&#125;, <span class="hljs-title">useDefaultFilters</span> </span>= <span class="hljs-keyword">false</span>)</code></pre></div><p>注意：使用 <strong>includeFilters</strong> 时要排除 <strong>Spring</strong> 默认的 Filters，需在 <strong>@ComponentScan</strong> 中加入 <strong>useDefaultFilters = false</strong></p><p>效果：</p><p><img src="https://i.loli.net/2020/07/01/atcug3hLy4AYBZp.png" srcset="/img/loading.gif" alt="image.png"></p><p>现在就只有加了 <strong>@Controller</strong> 的组件被包含进来了</p><h5 id="3-也可使用-ComponentScans-来指定多个扫描规则"><a href="#3-也可使用-ComponentScans-来指定多个扫描规则" class="headerlink" title="3. 也可使用 @ComponentScans 来指定多个扫描规则"></a>3. 也可使用 <strong>@ComponentScans</strong> 来指定多个扫描规则</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScans</span>(&#123;        <span class="hljs-meta">@ComponentScan</span>(value = <span class="hljs-string">"cn.lwjppz"</span>, includeFilters = &#123;<span class="hljs-meta">@Filter</span>(type = FilterType.ANNOTATION, classes = Controller<span class="hljs-class">.<span class="hljs-keyword">class</span>)&#125;, <span class="hljs-title">useDefaultFilters</span> </span>= <span class="hljs-keyword">false</span>)&#125;)</code></pre></div><p>效果是和之前的一样的。</p><h5 id="4-自定义规则"><a href="#4-自定义规则" class="headerlink" title="4. 自定义规则"></a>4. 自定义规则</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  FilterType.ANNOTATION           按照注解</span><span class="hljs-comment"> *  FilterType.ASSIGNABLE_TYPE      按照给定的类型</span><span class="hljs-comment"> *  FilterType.ASPECTJ              使用 ASPECTJ 表达式</span><span class="hljs-comment"> *  FilterType.REGEX                使用正则表达式</span><span class="hljs-comment"> *  FilterType.CUSTOM               使用自定义规则</span><span class="hljs-comment"> */</span></code></pre></div><p><img src="https://i.loli.net/2020/07/01/8XJRmwf2v7KWIgC.png" srcset="/img/loading.gif" alt="image.png"></p><p>注意：自定义 <strong>Filter</strong> 需实现 <strong>TypeFilter</strong> 接口</p><h3 id="Scope-设置组件作用域"><a href="#Scope-设置组件作用域" class="headerlink" title="@Scope - 设置组件作用域"></a>@Scope - 设置组件作用域</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/7/1 11:33</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig2</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认是单实例的</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> ConfigurableBeanFactory#SCOPE_PROTOTYPE  singleton</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> ConfigurableBeanFactory#SCOPE_SINGLETON  prototype</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_REQUEST request</span><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> org.springframework.web.context.WebApplicationContext#SCOPE_SESSION session</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     *</span><span class="hljs-comment">     * singleton    单实例（默认值）    IOC容器启动后会去调用方法创建对象，放入容器中</span><span class="hljs-comment">     *              以后每次获取都是从容器中拿（map.get())</span><span class="hljs-comment">     * prototype    多实例             IOC容器启动后并不会去调用方法创建对象放入容器中</span><span class="hljs-comment">     *              每次获取的时候才会调用方法创建对象，所以每次获取的对象都不相同</span><span class="hljs-comment">     * request      同一次请求创建一个实例</span><span class="hljs-comment">     * session      同一次 session 创建一个实例</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Scope</span>(<span class="hljs-string">"singleton"</span>)    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">"lisi"</span>, <span class="hljs-number">20</span>);    &#125;&#125;</code></pre></div><p>测试：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;    ApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(MainConfig2<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    User bean1 = context.getBean(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    User bean2 = context.getBean(User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(bean1 == bean2);&#125;</code></pre></div><p><img src="https://i.loli.net/2020/07/01/gPvzRnT1qFH87UJ.png" srcset="/img/loading.gif" alt="image.png"></p><p>换成 <strong>prototype</strong> 之后</p><p><img src="https://i.loli.net/2020/07/01/1RUx534fcPwpGSk.png" srcset="/img/loading.gif" alt="image.png"></p><h3 id="Lazy-Bean懒加载"><a href="#Lazy-Bean懒加载" class="headerlink" title="@Lazy - Bean懒加载"></a>@Lazy - Bean懒加载</h3><p>单实例bean，默认在容器启动的时候创建对象。<br>懒加载，容器启动时不创建对象，在第一次使用（获取）bean的时候创建，并初始化。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式七大原则</title>
    <link href="/2020/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2020/06/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><p>设计模式体现了代码的耦合性， 内聚性以及可维护性，可扩展性，重用性，灵活性。</p><ol><li>代码重用性（即：相同功能的代码，不用多次编写）</li><li>可读性（即：编程规范性，便于其他程序员的阅读和理解）</li><li>可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）</li><li>可靠性（即：当我们增加新的功能后，对原来的功能没有影响）</li><li>使程序呈现高内聚，低耦合的特性</li></ol><p><em>Scott Mayers在其巨著《Effective C++》说过: C++老手和C++新手的区别就是前者手背上有很多伤疤。</em></p><ul><li>同样是面向对象，当然也可指 Java</li></ul><h2 id="一、单一职责原则（Single-responsibility）"><a href="#一、单一职责原则（Single-responsibility）" class="headerlink" title="一、单一职责原则（Single responsibility）"></a>一、单一职责原则（Single responsibility）</h2><p>单一职责原则注意事项和细节：</p><ol><li>降低类的复杂度，一个类只负责一项职责；</li><li>提高类的可读性，可维护性；</li><li>降低变更引起的风险;</li><li>通常情况下，应当遵守单一职责原则， 只有逻辑足够简单，才可以在方法级违反单一职责原则。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:42</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 只有类中方法数量足够少，可以在方法级别保持单一职责原则</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingleResponsibility</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Vehicle vehicle = <span class="hljs-keyword">new</span> Vehicle();        vehicle.run(<span class="hljs-string">"柯尼塞格"</span>);        vehicle.fly(<span class="hljs-string">"波音747"</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 逻辑简单，方法级别实现单一职责</span><span class="hljs-comment"> * 逻辑复杂，分类实现单一职责</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String string)</span> </span>&#123;        System.out.println(string + <span class="hljs-string">"：是陆地交通工具"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(String string)</span> </span>&#123;        System.out.println(string + <span class="hljs-string">"：是空中交通工具"</span>);    &#125;&#125;</code></pre></div><h2 id="二、接口隔离原则（Interface-Segregation）"><a href="#二、接口隔离原则（Interface-Segregation）" class="headerlink" title="二、接口隔离原则（Interface Segregation）"></a>二、接口隔离原则（Interface Segregation）</h2><ol><li>类A通过接口 Interface1、2 依赖类B，类C通过接口 Interface1、3 依赖类D，如果接口 Interface 对于 类A 和 类C 来说不是最小接口，那么 类B 和 类D 必须去实现他们不需要的方法。</li><li>将接口 Interface 拆分为独立的几个接口，类A 和 类C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</li><li>接口 Interface 中出现的方法，根据实际情祝拆分为三个接口。<br><img src="https://i.loli.net/2020/06/30/8rCg7WDYnPzoc19.png" srcset="/img/loading.gif" alt="image.png"></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:49</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceSegregation</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        a.depend1(<span class="hljs-keyword">new</span> B());        a.depend2(<span class="hljs-keyword">new</span> B());        a.depend3(<span class="hljs-keyword">new</span> B());        C c = <span class="hljs-keyword">new</span> C();        c.depend1(<span class="hljs-keyword">new</span> D());        c.depend4(<span class="hljs-keyword">new</span> D());        c.depend5(<span class="hljs-keyword">new</span> D());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interface1</span>, <span class="hljs-title">interface2</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation1"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation2"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation3"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interface1</span>, <span class="hljs-title">interface3</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation1"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation4"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation5"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(interface1 i)</span> </span>&#123;        i.Operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(interface2 i)</span> </span>&#123;        i.Operation2();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(interface2 i)</span> </span>&#123;        i.Operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(interface1 i)</span> </span>&#123;        i.Operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(interface3 i)</span> </span>&#123;        i.Operation4();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(interface3 i)</span> </span>&#123;        i.Operation5();    &#125;&#125;</code></pre></div><h2 id="三、依赖倒转原则（Dependence-Inversion）"><a href="#三、依赖倒转原则（Dependence-Inversion）" class="headerlink" title="三、依赖倒转原则（Dependence Inversion）"></a>三、依赖倒转原则（Dependence Inversion）</h2><ol><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象（缓冲层）；</li><li>抽象不应该依赖细节，细节应该依赖抽象；</li><li>依赖倒转(倒置)的中心思想是面向接口编程;</li><li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中， 抽象指的是接口或抽象类，细节就是具体的实现类；</li><li>使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</li></ol><p><strong>依赖关系三种传递方式：</strong></p><ul><li>接口传递（依赖）</li><li>构造方法传递（依赖）</li><li>setter方式传递（聚合）</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:51</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DependenceInversion</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Person person = <span class="hljs-keyword">new</span> Person();        person.receive(<span class="hljs-keyword">new</span> Email());        person.receive(<span class="hljs-keyword">new</span> WeChat());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Info</span></span>&#123;    <span class="hljs-function">String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Info</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Receive Email"</span>;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeChat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Info</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Receive WeChat"</span>;    &#125;&#125;<span class="hljs-comment">//person 接受信息</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(Info info)</span> </span>&#123;        System.out.println(info.getInfo());    &#125;&#125;</code></pre></div><h2 id="四、里氏替换原则（Liskov-Substitution）"><a href="#四、里氏替换原则（Liskov-Substitution）" class="headerlink" title="四、里氏替换原则（Liskov Substitution）"></a>四、里氏替换原则（Liskov Substitution）</h2><ol><li>里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院一位姓里的女士提出；</li><li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象；</li><li>在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法；</li><li>继承实际上让两个类耦合性增强了，给程序带来侵入性。在适当的情况下，可以通过聚合，组合，依赖来解决问题；</li><li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:56</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiskovSubstitution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        System.out.println(<span class="hljs-string">"2 - 1 = "</span> + a.func1(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));        B b = <span class="hljs-keyword">new</span> B();        System.out.println(<span class="hljs-string">"2 + 1 = "</span> + b.func1(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));        System.out.println(<span class="hljs-string">"2 + 1 + 9 = "</span> + b.func2(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));        System.out.println(<span class="hljs-string">"B类使用A类方法：2 - 1 = "</span> + b.func3(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>));    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">//把基础方法和成员抽取成基类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">return</span> num1 - num2;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<span class="hljs-comment">//    public int func1(int num1, int num2) &#123;</span><span class="hljs-comment">//        return num1 - num2;</span><span class="hljs-comment">//    &#125;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;    <span class="hljs-comment">// TODO 类 B `无意` 重写了父类 A 方法，造成原有方法发生改变。</span><span class="hljs-comment">//    @Override</span><span class="hljs-comment">//    public int func1(int num1, int num2) &#123;</span><span class="hljs-comment">//        return num1 + num2;</span><span class="hljs-comment">//    &#125;</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">return</span> num1 + num2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">return</span> func1(num1, num2) + <span class="hljs-number">9</span>;    &#125;    <span class="hljs-keyword">private</span> A a = <span class="hljs-keyword">new</span> A();<span class="hljs-comment">//组合</span>    <span class="hljs-comment">//使用 A 方法</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num1, <span class="hljs-keyword">int</span> num2)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a.func1(num1, num2);    &#125;&#125;</code></pre></div><h2 id="五、开闭原则-OCP（Open-Closed）"><a href="#五、开闭原则-OCP（Open-Closed）" class="headerlink" title="五、开闭原则 OCP（Open Closed）"></a>五、开闭原则 OCP（Open Closed）</h2><ol><li>开闭原则(Open Closed Principle) 是编程中最基础、最重要的设计原则；</li><li>一个软件实体，比如类，模块和函数应该对提供方扩展开放，对使用方修改关闭。用抽象构建框架，用实现扩展细节；</li><li>当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化；</li><li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/30 19:49</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceSegregation</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        A a = <span class="hljs-keyword">new</span> A();        a.depend1(<span class="hljs-keyword">new</span> B());        a.depend2(<span class="hljs-keyword">new</span> B());        a.depend3(<span class="hljs-keyword">new</span> B());        C c = <span class="hljs-keyword">new</span> C();        c.depend1(<span class="hljs-keyword">new</span> D());        c.depend4(<span class="hljs-keyword">new</span> D());        c.depend5(<span class="hljs-keyword">new</span> D());    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface2</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">interface3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation4</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation5</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interface1</span>, <span class="hljs-title">interface2</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation1"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation2"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"B 实现了 Operation3"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">interface1</span>, <span class="hljs-title">interface3</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation1"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation4</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation4"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Operation5</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"D 实现了 Operation5"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(interface1 i)</span> </span>&#123;        i.Operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend2</span><span class="hljs-params">(interface2 i)</span> </span>&#123;        i.Operation2();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend3</span><span class="hljs-params">(interface2 i)</span> </span>&#123;        i.Operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend1</span><span class="hljs-params">(interface1 i)</span> </span>&#123;        i.Operation1();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend4</span><span class="hljs-params">(interface3 i)</span> </span>&#123;        i.Operation4();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">depend5</span><span class="hljs-params">(interface3 i)</span> </span>&#123;        i.Operation5();    &#125;&#125;</code></pre></div><h2 id="六、迪米特法则（Demeter）"><a href="#六、迪米特法则（Demeter）" class="headerlink" title="六、迪米特法则（Demeter）"></a>六、迪米特法则（Demeter）</h2><p>1.一个对象应该对其他对象保持最少的了解（最少知道原则 LKP）。<br>2. 类与类关系越密切，耦合度越大。要求降低类之间耦合，而不是完全解耦。<br>3. 迪米特法则(Demeter Principle)，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。<br>4. 迪米特法则更简单的定义：只与直接的朋友通信。<br>5. 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/28 19:58</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demeter</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SchoolManager schoolManager = <span class="hljs-keyword">new</span> SchoolManager();        schoolManager.printAllEmployee(<span class="hljs-keyword">new</span> CollegeManager());    &#125;&#125;<span class="hljs-comment">//学院员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-comment">//管理学院员工的管理类:</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollegeManager</span> </span>&#123;    <span class="hljs-comment">//返回学院的所有员工 //TODO CollegeEmployee 直接朋友</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;CollegeEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123; <span class="hljs-comment">//这里我们增加了10 个员工到list ，</span>            CollegeEmployee emp = <span class="hljs-keyword">new</span> CollegeEmployee();            emp.setId(<span class="hljs-string">"学院员工id "</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printCollegeEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;CollegeEmployee&gt; list1 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">"---学院员工----"</span>);        <span class="hljs-keyword">for</span> (CollegeEmployee e : list1) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;<span class="hljs-comment">//学校总部员工类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolEmployee</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;<span class="hljs-comment">//学校管理类</span><span class="hljs-comment">//TODO 直接朋友 Employee CollegeManager</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SchoolManager</span> </span>&#123;    <span class="hljs-comment">//返回学校总部的员工</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;SchoolEmployee&gt; <span class="hljs-title">getAllEmployee</span><span class="hljs-params">()</span> </span>&#123;        List&lt;SchoolEmployee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;SchoolEmployee&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123; <span class="hljs-comment">//这里我们增加了5个员工到list</span>            SchoolEmployee emp = <span class="hljs-keyword">new</span> SchoolEmployee();            emp.setId(<span class="hljs-string">"学校总部员工id= "</span> + i);            list.add(emp);        &#125;        <span class="hljs-keyword">return</span> list;    &#125;    <span class="hljs-comment">//该方法完成输出学校总部和学院员工信息(id)</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAllEmployee</span><span class="hljs-params">(CollegeManager sub)</span> </span>&#123;        <span class="hljs-comment">//获取到学院员工</span>        <span class="hljs-comment">//TODO 非直接朋友 CollegeEmployee  应该提取到  CollegeManager</span><span class="hljs-comment">//        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><span class="hljs-comment">//        System.out.println("---学院员工----");</span><span class="hljs-comment">//        for (CollegeEmployee e : list1) &#123;</span><span class="hljs-comment">//            System.out.println(e.getId());</span><span class="hljs-comment">//        &#125;</span>        sub.printCollegeEmployee();<span class="hljs-comment">//只提供方法，不把具体实现放在其他类里面。</span>        <span class="hljs-comment">//获取到学校总部员工</span>        List&lt;SchoolEmployee&gt; list2 = <span class="hljs-keyword">this</span>.getAllEmployee();        System.out.println(<span class="hljs-string">"------学校总部员工------"</span>);        <span class="hljs-keyword">for</span> (SchoolEmployee e : list2) &#123;            System.out.println(e.getId());        &#125;    &#125;&#125;</code></pre></div><h2 id="七、合成复用原则（Composite-Reuse）"><a href="#七、合成复用原则（Composite-Reuse）" class="headerlink" title="七、合成复用原则（Composite Reuse）"></a>七、合成复用原则（Composite Reuse）</h2><p>合成复用原则 尽量使用组合/聚合的方式，而不是使用继承。</p><ol><li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li>为了交互对象之间的松耦合设计而努力。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/28 21:00</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CompositeReuse</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.out.println(<span class="hljs-string">"------依赖------"</span>);        B b = <span class="hljs-keyword">new</span> B();        b.Operation1(<span class="hljs-keyword">new</span> A());        System.out.println(<span class="hljs-string">"------聚合------"</span>);        b.setA(<span class="hljs-keyword">new</span> A());        b.Operation2();        System.out.println(<span class="hljs-string">"------组合------"</span>);        b.Operation3();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"A Operation1"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"A Operation2"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"A Operation3"</span>);    &#125;&#125;<span class="hljs-comment">//如果只是需要用到 A类的方法，尽量不要使用继承。而是使用，依赖，聚合，组合的方式</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation1</span><span class="hljs-params">(A a)</span> </span>&#123;<span class="hljs-comment">//TODO 依赖</span>        a.Operation1();        a.Operation2();        a.Operation3();    &#125;    <span class="hljs-comment">//==============================================================</span>    A a;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(A a)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a = a;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation2</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//TODO 聚合</span>        a.Operation1();        a.Operation2();        a.Operation3();    &#125;    <span class="hljs-comment">//==============================================================</span>    A a1 = <span class="hljs-keyword">new</span> A();    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Operation3</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//TODO 组合</span>        a1.Operation1();        a1.Operation2();        a1.Operation3();    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>design pattern</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis使用 - 基于XML和注解</title>
    <link href="/2020/06/29/MyBatis%E4%BD%BF%E7%94%A8%20-%20%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <url>/2020/06/29/MyBatis%E4%BD%BF%E7%94%A8%20-%20%E5%9F%BA%E4%BA%8EXML%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-MyBatis？"><a href="#什么是-MyBatis？" class="headerlink" title="什么是 MyBatis？"></a>什么是 MyBatis？</h3><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h2 id="使用MyBatis"><a href="#使用MyBatis" class="headerlink" title="使用MyBatis"></a>使用MyBatis</h2><h3 id="1-准备数据库"><a href="#1-准备数据库" class="headerlink" title="1.准备数据库"></a>1.准备数据库</h3><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> score(    sno           <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">''</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>        primary <span class="hljs-keyword">key</span>,    <span class="hljs-keyword">name</span>          <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-string">''</span> <span class="hljs-literal">null</span>,    <span class="hljs-keyword">Java</span>          <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    C             <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    Algorithm     <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    LinearAlgebra <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    English       <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>,    PE            <span class="hljs-built_in">int</span>(<span class="hljs-number">32</span>)                <span class="hljs-literal">null</span>);</code></pre></div><p>在表里添加几条数据</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861200'</span>, <span class="hljs-string">'张三'</span>, <span class="hljs-number">60</span>, <span class="hljs-number">90</span>, <span class="hljs-number">61</span>, <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861249'</span>, <span class="hljs-string">'王五'</span>, <span class="hljs-number">43</span>, <span class="hljs-number">65</span>, <span class="hljs-number">76</span>, <span class="hljs-number">33</span>, <span class="hljs-number">64</span>, <span class="hljs-number">76</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861255'</span>, <span class="hljs-string">'李四'</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">60</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">100</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861258'</span>, <span class="hljs-string">'john'</span>, <span class="hljs-number">23</span>, <span class="hljs-number">54</span>, <span class="hljs-number">21</span>, <span class="hljs-number">35</span>, <span class="hljs-number">87</span>, <span class="hljs-number">57</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861259'</span>, <span class="hljs-string">'jack'</span>, <span class="hljs-number">41</span>, <span class="hljs-number">43</span>, <span class="hljs-number">54</span>, <span class="hljs-number">75</span>, <span class="hljs-number">43</span>, <span class="hljs-number">13</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-string">`userinfo`</span>.<span class="hljs-string">`score`</span>(<span class="hljs-string">`sno`</span>, <span class="hljs-string">`name`</span>, <span class="hljs-string">`Java`</span>, <span class="hljs-string">`C`</span>, <span class="hljs-string">`Algorithm`</span>, <span class="hljs-string">`LinearAlgebra`</span>, <span class="hljs-string">`English`</span>, <span class="hljs-string">`PE`</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'20180861260'</span>, <span class="hljs-string">'hellen'</span>, <span class="hljs-number">23</span>, <span class="hljs-number">34</span>, <span class="hljs-number">76</span>, <span class="hljs-number">99</span>, <span class="hljs-number">57</span>, <span class="hljs-number">97</span>);</code></pre></div><h3 id="2-新建一个-Maven-项目"><a href="#2-新建一个-Maven-项目" class="headerlink" title="2. 新建一个 Maven 项目"></a>2. 新建一个 Maven 项目</h3><p>将下面的依赖代码置于 pom.xml 文件中：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="3-新建一个-Mybatis-config-xml配置文件"><a href="#3-新建一个-Mybatis-config-xml配置文件" class="headerlink" title="3. 新建一个 Mybatis-config.xml配置文件"></a>3. 新建一个 Mybatis-config.xml配置文件</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><span class="hljs-meta"><span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><span class="hljs-meta"><span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/userinfo?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8<span class="hljs-symbol">&amp;amp;</span>useSSL=true<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"LWJLWJ20000829"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"mapper/ScoreMapper.xml"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p>还有很多可以在 XML 文件中配置的选项，上面的示例仅罗列了最关键的部分。 environment 元素体中包含了事务管理和连接池的配置。mappers 元素则包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息。</p><h3 id="4-获取SqlSessionFactory"><a href="#4-获取SqlSessionFactory" class="headerlink" title="4. 获取SqlSessionFactory"></a>4. 获取SqlSessionFactory</h3><p>每个基于 MyBatis 的应用都是以一个 <strong>SqlSessionFactory</strong> 的实例为核心的。<strong>SqlSessionFactory</strong>的实例可以通过 <strong>SqlSessionFactoryBuilder</strong> 获得。而 <strong>SqlSessionFactoryBuilder</strong> 则可以从 XML 配置文件来构建出 SqlSessionFactory 实例。</p><p>从 XML 文件中构建 <strong>SqlSessionFactory</strong> 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例。MyBatis 中有一个 <strong>Resources</strong> 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。但是在这里我是用自定义工具类来获取。</p><ul><li>在utils包下新建MyBatisUtils工具类<br><img src="https://www.lwjppz.cn/upload/2020/6/image-a66e9bbd27a3483dbea4b71515616c65.png" srcset="/img/loading.gif" alt="image.png"></li><li>加入以下代码<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>      : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/29 14:05</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBatisUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;    <span class="hljs-keyword">static</span> &#123;        InputStream inputStream = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 使用MyBatis 从 XML 文件中构建 SqlSessionFactory 的实例</span>            String resource = <span class="hljs-string">"mybatis-config.xml"</span>;            inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 有了 SqlSessionFactory，可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> SqlSession对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();    &#125;&#125;</code></pre></div></li></ul><h3 id="从-SqlSessionFactory-中获取-SqlSession，执行-SQl-语句"><a href="#从-SqlSessionFactory-中获取-SqlSession，执行-SQl-语句" class="headerlink" title="从 SqlSessionFactory 中获取 SqlSession，执行 SQl 语句"></a>从 SqlSessionFactory 中获取 SqlSession，执行 SQl 语句</h3><p>既然有了 <strong>SqlSessionFactory</strong>，顾名思义，我们可以从中获得 <strong>SqlSession</strong>的实例。<strong>SqlSession</strong> 提供了在数据库执行 SQL 命令所需的所有方法。可以通过 <strong>SqlSession</strong> 实例来直接执行已映射的 SQL 语句。</p><ol><li><p>准备实体类，MyBatis 应用了 <strong>ORM（对象关系映射）</strong> 思想，实体类字段应于数据库字段一一对应</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/29 14:15</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Score</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String sno;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer Java;    <span class="hljs-keyword">private</span> Integer C;    <span class="hljs-keyword">private</span> Integer Algorithm;    <span class="hljs-keyword">private</span> Integer LinearAlgebra;    <span class="hljs-keyword">private</span> Integer English;    <span class="hljs-keyword">private</span> Integer PE;&#125;</code></pre></div><p>其余方法请自行补充</p><ol start="2"><li>在 <strong>dao</strong> 包下新建 ScoreMapper，<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.entites.Score;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/29 14:21</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScoreMapper</span> </span>&#123;    <span class="hljs-function">List&lt;Score&gt; <span class="hljs-title">getAllScores</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div></li></ol></li><li><p>在 <strong>resources</strong> 下新建 <strong>mapper</strong> 文件夹，在此文件夹下新建 ScoreMapper.xml<br><img src="https://www.lwjppz.cn/upload/2020/6/image-177a6fa94929407887a659baa22b7997.png" srcset="/img/loading.gif" alt="image.png"></p></li></ol><p><strong>需要注意：</strong><br><img src="https://www.lwjppz.cn/upload/2020/6/image-76c77cbef5b44ab8bff90684916745f8.png" srcset="/img/loading.gif" alt="image.png"><br>     - namespace：对应刚刚写的那个映射语句类 - <strong>ScoreMapper</strong> （需写全类名）<br>     - id：对应 <strong>ScoreMapper</strong> 中的 <strong>getAllScores</strong> 方法<br>     - resultType：查询结果类型</p><ol start="4"><li>编写测试类测试：<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.lwjppz.dao.ScoreMapper;<span class="hljs-keyword">import</span> cn.lwjppz.entites.Score;<span class="hljs-keyword">import</span> cn.lwjppz.utils.MyBatisUtils;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> : lwj</span><span class="hljs-comment"> * createTime  : 2020/6/29 14:55</span><span class="hljs-comment"> * description : Reprint please indicate the source</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        SqlSession sqlSession = MyBatisUtils.getSqlSession();        ScoreMapper scoreMapper = sqlSession.getMapper(ScoreMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        List&lt;Score&gt; scores = scoreMapper.getAllScores();        <span class="hljs-keyword">for</span> (Score score: scores) &#123;            System.out.println(score);        &#125;    &#125;&#125;</code></pre></div></li><li>测试结果<br><img src="https://www.lwjppz.cn/upload/2020/6/image-a495ae4bc00149f397ad8a26010923af.png" srcset="/img/loading.gif" alt="image.png"></li></ol><h4 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h4><p>使用注解的方法很简单，只需在 <strong>ScoreMapper</strong> 中的 <strong>getAllScores</strong> 方法上加入 <strong>Select</strong> 注解<br><img src="https://www.lwjppz.cn/upload/2020/6/image-9e72e0b0cdb947a196c672cf4640471a.png" srcset="/img/loading.gif" alt="image.png"></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ScoreMapper</span> </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * FROM score"</span>)    <span class="hljs-function">List&lt;Score&gt; <span class="hljs-title">getAllScores</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div><p>删除 <strong>ScoreMapper.xml</strong> 中的 select 标签</p><p><img src="https://www.lwjppz.cn/upload/2020/6/image-76f46a04112b4a7f9ac15d88dbf2b50f.png" srcset="/img/loading.gif" alt="image.png"></p><p>测试通过</p><p><img src="https://www.lwjppz.cn/upload/2020/6/image-301227922c1e4b399c140c5dfe5e9532.png" srcset="/img/loading.gif" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</p><p>选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。</p>]]></content>
    
    
    <categories>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASP.NET MVC 学习笔记</title>
    <link href="/2020/06/21/ASP.NET%20MVC%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/21/ASP.NET%20MVC%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="ASP-NET-MVC"><a href="#ASP-NET-MVC" class="headerlink" title="ASP.NET MVC"></a>ASP.NET MVC</h1><h3 id="1-数据的验证"><a href="#1-数据的验证" class="headerlink" title="1. 数据的验证"></a>1. 数据的验证</h3><ol><li>在Models文件夹下，为需要验证的model类中加入 </li></ol><p><strong>using System.ComponentModel.DataAnnotations;</strong> 命名空间的引入</p><ol start="2"><li><p>添加注解：</p><ul><li><p>显示自定义名称</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">Display(Name = <span class="hljs-meta-string">"标题"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Title &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div></li><li><p>使用正则表达式验证输入的字符串是否符合格式要求。</p><div class="hljs"><pre><code class="hljs C#">[RegularExpression(@&quot;^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$&quot;, ErrorMessage &#x3D; &quot;邮箱不正确&quot;)]public string Email &#123; get; set; &#125;</code></pre></div></li><li><p>Required特性，则此项为必填项。用于不为空校验。默认为不允许为空。允许为空则添加AllowEmptyStrings = true</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">Required(ErrorMessage = <span class="hljs-meta-string">"密码不能为空"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Password &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div></li><li><p>限定字符串长度。</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">StringLength(20,ErrorMessage = <span class="hljs-meta-string">"密码不能超过20个字符"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Password &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div></li><li><p>用来判断两个属性是否拥有相同的值。例如，确保两次输入的密码相同。比较两个值是否一致，一般用于二次输入。<strong>Password</strong>是需要比较的值</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">Compare(<span class="hljs-meta-string">"Password"</span>,ErrorMessage = <span class="hljs-meta-string">"两次输入不一致"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> PasswordConfirm &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div><p>以上验证将对PasswordConfirm和Password进行是否一致的比较。</p></li><li><p><strong>Remote</strong>利用服务器端的回调函数执行客户端的逻辑验证。这个在登录的时候用的非常多。比如你的用户名ID是否已经被注册</p><p>需要添加 <strong>using System.Web.Mvc;</strong></p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">Remote(<span class="hljs-meta-string">"CheckUserName"</span>,<span class="hljs-meta-string">"Home"</span>,ErrorMessage = <span class="hljs-meta-string">"用户名已被注册"</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> UserName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;</code></pre></div><p>然后在<strong>Home</strong>这个Controller里面添加<strong>CheckUserName</strong>方法，判断用户名是否存在需要从数据库读取判断，此处只是demo</p><div class="hljs"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> ActionResult CheckUserName()&#123;    string LastName = Request[<span class="hljs-string">"LastName"</span>];    <span class="hljs-keyword">if</span> (<span class="hljs-string">"admin"</span>.Equals(LastName))        <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">Json</span><span class="hljs-params">(<span class="hljs-keyword">false</span>, JsonRequestBehavior.AllowGet)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">Json</span><span class="hljs-params">(<span class="hljs-keyword">true</span>, JsonRequestBehavior.AllowGet)</span></span>;&#125;</code></pre></div></li></ul></li><li><p>添加视图，在视图页面确保已添加 <strong>Jquery库、Jquery.Validate、Jquery.Validate.unobtrusive这三个文件。</strong></p><h5 id="小贴士：在创建视图时选择-Create-模板，自带上面这三个，亲测有用哦。"><a href="#小贴士：在创建视图时选择-Create-模板，自带上面这三个，亲测有用哦。" class="headerlink" title="小贴士：在创建视图时选择 Create 模板，自带上面这三个，亲测有用哦。"></a>小贴士：在创建视图时选择 <strong><em>Create</em></strong> 模板，自带上面这三个，亲测有用哦。</h5><p><img src="https://i.loli.net/2020/06/21/fQ569yNbk3dTSDJ.png" srcset="/img/loading.gif" alt="QQ截图20200621091244.png"></p></li></ol><h3 id="2-Action过滤器"><a href="#2-Action过滤器" class="headerlink" title="2. Action过滤器"></a>2. Action过滤器</h3><h5 id="自定义Actioon过滤器"><a href="#自定义Actioon过滤器" class="headerlink" title="自定义Actioon过滤器"></a>自定义Actioon过滤器</h5><ol><li>首先新建Filters文件夹，在Filters下新建如下图所示</li></ol><p><img src="https://i.loli.net/2020/06/21/4OYxz9wnPNgbQVv.png" srcset="/img/loading.gif" alt="filter.png"></p><div class="hljs"><pre><code class="hljs cs"><span class="hljs-keyword">using</span> System;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> System.Linq;<span class="hljs-keyword">using</span> System.Web;<span class="hljs-keyword">using</span> System.Web.Mvc;<span class="hljs-keyword">namespace</span> <span class="hljs-title">Demo.Filters</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyActionFilterAttribute</span> : <span class="hljs-title">ActionFilterAttribute</span>    &#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Message &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnActionExecuting</span>(<span class="hljs-params">ActionExecutingContext filterContext</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">base</span>.OnActionExecuting(filterContext);            filterContext.HttpContext.Response.Write(<span class="hljs-string">"Action执行之前"</span> + Message + <span class="hljs-string">"&lt;br /&gt;"</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnActionExecuted</span>(<span class="hljs-params">ActionExecutedContext filterContext</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">base</span>.OnActionExecuted(filterContext);            filterContext.HttpContext.Response.Write(<span class="hljs-string">"Action执行之后"</span> + Message + <span class="hljs-string">"&lt;br /&gt;"</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnResultExecuting</span>(<span class="hljs-params">ResultExecutingContext filterContext</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">base</span>.OnResultExecuting(filterContext);            filterContext.HttpContext.Response.Write(<span class="hljs-string">"返回Result之前"</span> + Message + <span class="hljs-string">"&lt;br /&gt;"</span>);        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnResultExecuted</span>(<span class="hljs-params">ResultExecutedContext filterContext</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">base</span>.OnResultExecuted(filterContext);            filterContext.HttpContext.Response.Write(<span class="hljs-string">"返回Result之后"</span> + Message + <span class="hljs-string">"&lt;br /&gt;"</span>);        &#125;    &#125;&#125;</code></pre></div><ol start="2"><li><p>在需要的控制器下添加方法</p><div class="hljs"><pre><code class="hljs aspectj">[MyActionFilter] <span class="hljs-comment">//也可以加参数 [MyActionFilter(Message="lwjppz")]</span><span class="hljs-keyword">public</span> ActionResult ActionFilterDemo()&#123;    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">View</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div></li></ol><p>添加视图后，运行结果：</p><p><img src="https://i.loli.net/2020/06/21/9ftKIJz8onX3OFm.png" srcset="/img/loading.gif" alt="filter.png"></p><h3 id="3-Authorization过滤器"><a href="#3-Authorization过滤器" class="headerlink" title="3. Authorization过滤器"></a>3. Authorization过滤器</h3><p>在MVC中使用AuthorizeAttribute实现登陆和权限控制。</p><p>在执行需要登录和权限的Action前先判断用户是否登陆，若没登陆就跳转到登陆页，然后再判断用户是否有权限访问该Action对应的视图页面，若没有则跳转到特定提示页。</p><h4 id="范例："><a href="#范例：" class="headerlink" title="范例："></a>范例：</h4><p>先添加一个控制器AccountController：</p><div class="hljs"><pre><code class="hljs c#">public class AccountController : Controller&#123;    public ActionResult Index()    &#123;      return View();    &#125;&#125;</code></pre></div><p>然后再web.config文件中的&lt;system.web&gt;节中添加：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">authentication</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"Forms"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">forms</span> <span class="hljs-attr">loginUrl</span>=<span class="hljs-string">"~/Account/Index"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"2880"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">authentication</span>&gt;</span></code></pre></div><p>用来启用登录和权限验证，当用户未登录时将跳转到loginUrl指定的页面。</p><p>Forms 身份验证将身份验证标记保留在 Cookie 或页的 URL 中。Forms 身份验证通过 FormsAuthenticationModule 类参与到 ASP.NET 页面的生命周期中。可以通过 FormsAuthentication 类访问 Forms 身份验证信息和功能。</p><p>然后，在filterConfig.cs文件中的RegisterGlobalFilters方法中添加：</p><div class="hljs"><pre><code class="hljs c#">public static void RegisterGlobalFilters(GlobalFilterCollection filters)&#123;    filters.Add(new HandleErrorAttribute());    filters.Add(new AuthorizeAttribute());&#125;</code></pre></div><p>运行程序，当访问Home控制器下的Index页面时会跳转到Account控制器的Index页面，显示如下页面：</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/85eb06c7b5d28967a657a407f9c4c8bb.png" srcset="/img/loading.gif" alt="img"><br>某一些页面是需要未登录也能访问的，此时我们可以在相应的Action上添加匿名登录标记[<strong>AllowAnonymous</strong>]，例如上面的Home控制器中的Index页面和Account控制器中的Index页面都需要匿名访问权限：</p><div class="hljs"><pre><code class="hljs c#">[AllowAnonymous]public ActionResult Index()&#123;    return View();&#125;</code></pre></div><p>此时再访问Home控制器中的Index页面就能正常显示了。</p><p>需要注意的是，如果在能够匿名访问的页面中嵌套了需要登录和权限的子页面，则匿名访问的页面不能正常显示。例如：</p><p>在Home控制器中的Index视图页面中嵌套了@{Html.RenderAction(“ChildActionOnly”);}语句，即内嵌了ChildActionOnly页面，而该页面是需要登录才能访问的，则Index页面也不能正常显示。</p><p>此时再运行程序，访问需要登录的页面时会跳转到登录页面：</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/815dad3c682f9cb2b3bfb25b1f0f282c.png" srcset="/img/loading.gif" alt="img">注意，如果Account控制器的Index登录页面没有匿名访问标记则会提示错误：</p><p><img src="http://p.ananas.chaoxing.com/star3/origin/85eb06c7b5d28967a657a407f9c4c8bb.png" srcset="/img/loading.gif" alt="img"></p><h4 id="登录系统"><a href="#登录系统" class="headerlink" title="登录系统"></a>登录系统</h4><p>登录的控制器中在用户名和密码验证成功之后，应添加代码</p><p><strong>FormsAuthentication.SetAuthCookie(username, false);</strong></p><p>可用User.Identity.Name来获取当前的登录名，如：</p><p><strong>string userid = HttpContext.User.Identity.Name;</strong></p><h5 id="范例：-1"><a href="#范例：-1" class="headerlink" title="范例："></a>范例：</h5><p>修改Account控制器中的Index方法：</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">AllowAnonymous</span>]<span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Index</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">string</span> returnURL = Request[<span class="hljs-string">"ReturnUrl"</span>];    ViewBag.returnURL = returnURL;    <span class="hljs-keyword">return</span> View();&#125;</code></pre></div><p>在Account控制器中添加一个Action，用于校验用户输入的用户名和密码是否正确：      </p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-literal">[A<span class="hljs-identifier">llowAnonymous</span>]</span>public ActionResult <span class="hljs-constructor">Login(<span class="hljs-params">string</span> <span class="hljs-params">username</span>,<span class="hljs-params">string</span> <span class="hljs-params">password</span>,<span class="hljs-params">string</span> <span class="hljs-params">returnURL</span>)</span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-string">"admin"</span>.<span class="hljs-constructor">Equals(<span class="hljs-params">username</span>)</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-string">"123456"</span>.<span class="hljs-constructor">Equals(<span class="hljs-params">password</span>)</span>)    &#123;        FormsAuthentication.<span class="hljs-constructor">SetAuthCookie(<span class="hljs-params">username</span>, <span class="hljs-params">false</span>)</span>;<span class="hljs-comment">//设置用户登录成功（设置cookie），false表示cookie不要持久保存**</span>        <span class="hljs-keyword">if</span> (Url.<span class="hljs-constructor">IsLocalUrl(<span class="hljs-params">returnURL</span>)</span>)        &#123;            return <span class="hljs-constructor">Redirect(<span class="hljs-params">returnURL</span>)</span>;        &#125;        return <span class="hljs-constructor">RedirectToAction(<span class="hljs-string">"Index"</span>,<span class="hljs-string">"Home"</span>)</span>;    &#125;    return <span class="hljs-constructor">View()</span>;&#125;</code></pre></div><p>此时再访问需要登录才能访问的页面会跳转到登录页面，在登录页面输入正确的用户名和密码后就可以访问所有需要登录才能访问的页面了。</p><h5 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h5><p>使用如下的语句来退出登录：</p><p>FormsAuthentication.SignOut();//通过Forms验证来删除Cookie</p><h5 id="权限的验证"><a href="#权限的验证" class="headerlink" title="权限的验证"></a>权限的验证</h5><p>可以指定某个Controller或某个Action只能由指定的用户或角色访问。</p><h5 id="指定特定用户访问"><a href="#指定特定用户访问" class="headerlink" title="指定特定用户访问"></a>指定特定用户访问</h5><p>可以使用[Authorize(Users=”登录的用户名”)]的方式来限定。</p><p>如果可以由多个用户访问，在不同用户间用逗号分隔。</p><h5 id="范例：-2"><a href="#范例：-2" class="headerlink" title="范例："></a>范例：</h5><p>在Home控制器中修改Action：</p><p>在一个Action前面加上：</p><p><strong>[Authorize(Users=”admin”)]</strong></p><p>表示该Action只能由用户admin访问。</p><p>在另一个Action前面加上：</p><p><strong>[Authorize(Users=”sysadmin”)]</strong></p><p>表示该Action只能由用户sysadmin访问。</p><h5 id="指定特定角色访问"><a href="#指定特定角色访问" class="headerlink" title="指定特定角色访问"></a>指定特定角色访问</h5><p>可以使用[Authorize(Roles=”登录的用户名所属的角色”)]的方式来限定。</p><p>如果可以由多个角色访问，在不同角色间用逗号分隔。</p><h5 id="范例：-3"><a href="#范例：-3" class="headerlink" title="范例："></a>范例：</h5><p>在Home控制器中修改Action：</p><p>在一个Action前面加上：</p><p><strong>[Authorize(Roles=”admin”)]</strong></p><p>表示该Action只能由角色admin访问。</p><p>在另一个Action前面加上：</p><p><strong>[Authorize(Roles=”sysadmin”)]</strong></p><p>表示该Action只能由角色sysadmin访问。</p><p>需要注意的是：</p><p>1、我们必须实现自己的RoleProvider，主要是从RoleProvider这个抽象类派生出自己的子类，并重写其中的GetRolesForUser方法：</p><div class="hljs"><pre><code class="hljs c#">public class CustomRoleProvider:RoleProvider&#123;    public override string[] GetRolesForUser(string username)    &#123;        var cookie &#x3D; HttpContext.Current.Request.Cookies[FormsAuthentication.FormsCookieName];        var ticket &#x3D; FormsAuthentication.Decrypt(cookie.Value);        string role &#x3D; ticket.UserData;        return role.Split(&#39;,&#39;);    &#125;    public override void AddUsersToRoles(string[] usernames, string[] roleNames)    &#123;        throw new NotImplementedException();    &#125;    public override string ApplicationName    &#123;        get &#123;            throw new NotImplementedException();        &#125;        set &#123;            throw new NotImplementedException();        &#125;    &#125;    public override void CreateRole(string roleName)    &#123;        throw new NotImplementedException();    &#125;    public override bool DeleteRole(string roleName, bool throwOnPopulatedRole)    &#123;        throw new NotImplementedException();    &#125;    public override string[] FindUsersInRole(string roleName, string usernameToMatch)    &#123;        throw new NotImplementedException();    &#125;    public override string[] GetAllRoles()    &#123;        throw new NotImplementedException();    &#125;    public override string[] GetUsersInRole(string roleName)    &#123;        throw new NotImplementedException();    &#125;        public override bool IsUserInRole(string username, string roleName)    &#123;        throw new NotImplementedException();    &#125;    public override void RemoveUsersFromRoles(string[] usernames, string[] roleNames)    &#123;        throw new NotImplementedException();    &#125;    public override bool RoleExists(string roleName)    &#123;        throw new NotImplementedException();    &#125;&#125;</code></pre></div><p>2、必须修改web.config文件中的设置：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">roleManager</span> <span class="hljs-attr">enabled</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">defaultProvider</span>=<span class="hljs-string">"CustomRoleProvider"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">providers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">clear</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">add</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"CustomRoleProvider"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"FilterDemo.Filters.CustomRoleProvider"</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">providers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">roleManager</span>&gt;</span></code></pre></div><p>注意：这里type必须改成自己的命名空间.文件夹.类名。name的值可以与类名不同。但必须保证defaultProvider的值必须是下面add中某个name的值。</p><p>3、在登录验证的Action中自己定义cookie来存放用户名和角色信息：</p><div class="hljs"><pre><code class="hljs cs">[<span class="hljs-meta">AllowAnonymous</span>]<span class="hljs-function"><span class="hljs-keyword">public</span> ActionResult <span class="hljs-title">Logon</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> username, <span class="hljs-keyword">string</span> password, <span class="hljs-keyword">string</span> returnUrl</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-string">"admin"</span>.Equals(username) &amp;&amp; <span class="hljs-string">"123456"</span>.Equals(password))    &#123;        <span class="hljs-keyword">string</span> role = <span class="hljs-string">"admin,sysadmin"</span>;        <span class="hljs-keyword">var</span> authTicket = <span class="hljs-keyword">new</span> FormsAuthenticationTicket(            <span class="hljs-number">1</span>,               <span class="hljs-comment">// 版本</span>            username,           <span class="hljs-comment">// 用户名称</span>            DateTime.Now,         <span class="hljs-comment">// 创建日期</span>            DateTime.Now.AddMinutes(<span class="hljs-number">20</span>),  <span class="hljs-comment">// 过期时间</span>            <span class="hljs-literal">false</span>,             <span class="hljs-comment">// 是否记住</span>            role              <span class="hljs-comment">// 用户角色</span>        );        <span class="hljs-keyword">string</span> encryptedTicket = FormsAuthentication.Encrypt(authTicket);        <span class="hljs-keyword">var</span> authCookie = <span class="hljs-keyword">new</span> HttpCookie(FormsAuthentication.FormsCookieName, encryptedTicket);        authCookie.HttpOnly = <span class="hljs-literal">true</span>;<span class="hljs-comment">//客户端脚本不能访问</span>        authCookie.Secure = FormsAuthentication.RequireSSL;<span class="hljs-comment">//是否仅用https传递cookie</span>        authCookie.Domain = FormsAuthentication.CookieDomain;<span class="hljs-comment">//与cookie关联的域</span>        authCookie.Path = FormsAuthentication.FormsCookiePath;<span class="hljs-comment">//cookie关联的虚拟路径</span>        Response.Cookies.Add(authCookie);        <span class="hljs-keyword">if</span> (Url.IsLocalUrl(returnUrl))        &#123;            <span class="hljs-keyword">return</span> Redirect(returnUrl);        &#125;        <span class="hljs-keyword">return</span> RedirectToAction(<span class="hljs-string">"Index"</span>, <span class="hljs-string">"Account"</span>);    &#125;    <span class="hljs-keyword">return</span> RedirectToAction(<span class="hljs-string">"Index"</span>, <span class="hljs-string">"Account"</span>);&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>ASP.NET MVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ASP.NET MVC</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eternal</title>
    <link href="/2020/06/21/Eternal/"/>
    <url>/2020/06/21/Eternal/</url>
    
    <content type="html"><![CDATA[<h1 align="center"><a href="https://github.com/halo-dev" target="_blank">Eternal</a></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>Eternal</strong> <code>[ɪˈtɜːrnl]</code>，意为永恒。</p><p>一个清新简约的博客系统，可适配多主题</p><blockquote><p><a href="http://39.106.117.247/" target="_blank" rel="noopener">预览地址</a></p></blockquote><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><blockquote><p>本项目只是为了个人使用而开发，<br>项目起初是很简陋的，后来由于学校课程各种设计，所以博客的功能越来越多，也越来越完善，有兴趣的童鞋可以看看</p></blockquote><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><ul><li>项目采用Vue + SpringBoot开发，对于练习SpringBoot和Vue是个不错的练手项目</li><li>后台管理使用Vue + ant-design-vue搭建，后台是通用模板，当然如果不喜欢的话可以独立开发，对于其他功能并不影响</li><li>前台使用thymeleaf模板引擎渲染，可通过api进行主题适配</li><li>…………..</li></ul><h2 id="预览图"><a href="#预览图" class="headerlink" title="预览图"></a>预览图</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/sJYBuHCA8DX6mjr.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/4MGgua3qVcK9Q8f.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/4lb6KwjnveS9REk.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/njVu791hOPgxedt.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/Cnva7NUES5w4lsu.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/g5MN1kl4K9pz6da.png" srcset="/img/loading.gif" alt=""></h2><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="https://i.loli.net/2020/06/28/GjImg7lX6preMW8.png" srcset="/img/loading.gif" alt=""></h2><p><img src="https://i.loli.net/2020/06/28/JPf6GazQmbyOD89.png" srcset="/img/loading.gif" alt=""></p><hr>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Eternal</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用css实现的一个loading效果</title>
    <link href="/2020/05/05/%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AAloading%E6%95%88%E6%9E%9C/"/>
    <url>/2020/05/05/%E7%94%A8css%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%B8%AAloading%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>最终的效果是这样的<br><img src="D:%5Cblog%5CHexo%5Cmy-hexo-blog%5Cimgs%5Clove-loading-9c168462618d4863a1f74be7b0f4f6ab.gif" srcset="/img/loading.gif" alt="loveloading.gif"></p><p>Html代码：</p><div class="hljs"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Love_Loading<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/style.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>css代码：</p><div class="hljs"><pre><code class="hljs CSS">* &#123;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-tag">ul</span>, <span class="hljs-selector-tag">ol</span> &#123;  <span class="hljs-attribute">list-style</span>: none;&#125;<span class="hljs-selector-tag">body</span> &#123;  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">justify-content</span>: center;  <span class="hljs-attribute">align-items</span>: center;&#125;<span class="hljs-selector-tag">ul</span> &#123;  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">display</span>: flex;&#125;<span class="hljs-selector-tag">li</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">background-color</span>: red;  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">20px</span>;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(1)</span> &#123;  <span class="hljs-attribute">background-color</span>: red;  <span class="hljs-attribute">animation</span>: love1 <span class="hljs-number">3s</span> <span class="hljs-number">0s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(2)</span> &#123;  <span class="hljs-attribute">background-color</span>: darkturquoise;  <span class="hljs-attribute">animation</span>: love2 <span class="hljs-number">3s</span> <span class="hljs-number">0.1s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(3)</span> &#123;  <span class="hljs-attribute">background-color</span>: darksalmon;  <span class="hljs-attribute">animation</span>: love3 <span class="hljs-number">3s</span> <span class="hljs-number">0.2s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(4)</span> &#123;  <span class="hljs-attribute">background-color</span>: deeppink;  <span class="hljs-attribute">animation</span>: love4 <span class="hljs-number">3s</span> <span class="hljs-number">0.3s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(5)</span> &#123;  <span class="hljs-attribute">background-color</span>: yellow;  <span class="hljs-attribute">animation</span>: love5 <span class="hljs-number">3s</span> <span class="hljs-number">0.4s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(6)</span> &#123;  <span class="hljs-attribute">background-color</span>: deeppink;  <span class="hljs-attribute">animation</span>: love4 <span class="hljs-number">3s</span> <span class="hljs-number">0.5s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(7)</span> &#123;  <span class="hljs-attribute">background-color</span>: darksalmon;  <span class="hljs-attribute">animation</span>: love3 <span class="hljs-number">3s</span> <span class="hljs-number">0.6s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(8)</span> &#123;  <span class="hljs-attribute">background-color</span>: darkturquoise;  <span class="hljs-attribute">animation</span>: love2 <span class="hljs-number">3s</span> <span class="hljs-number">0.7s</span> infinite;&#125;<span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:nth-child(9)</span> &#123;  <span class="hljs-attribute">background-color</span>: red;  <span class="hljs-attribute">animation</span>: love1 <span class="hljs-number">3s</span> <span class="hljs-number">0.8s</span> infinite;&#125;<span class="hljs-keyword">@keyframes</span> love1 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">30px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;<span class="hljs-keyword">@keyframes</span> love2 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">125px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">60px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;<span class="hljs-keyword">@keyframes</span> love3 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">160px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">75px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;<span class="hljs-keyword">@keyframes</span> love4 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">180px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">30px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;<span class="hljs-keyword">@keyframes</span> love5 &#123;  30%,50% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(-<span class="hljs-number">45px</span>);  &#125;  70%,100% &#123;    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0px</span>);  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>博客美化</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
